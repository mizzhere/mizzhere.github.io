<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Đấu Trường Sinh Tử</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');

        html, body {
            margin: 0; padding: 0; overflow: hidden;
            height: 100dvh; width: 100dvw;
            background-color: #0a0a0a;
            font-family: 'Inter', sans-serif;
        }
        #game-container {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            height: 100%; width: 100%; padding: 1rem; box-sizing: border-box;
            position: relative;
        }
        canvas {
            background-color: #2d3748; border: 2px solid #a0aec0; border-radius: 0.5rem;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            max-width: 100%; max-height: 100%; aspect-ratio: 1 / 1;
            transition: transform 0.1s ease-out;
        }
        .screen-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(10, 10, 10, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
            backdrop-filter: blur(8px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease-in-out;
        }
        .screen-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .dialog-card {
            background-color: #1a1a1d;
            padding: 2.5rem;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.3), 0 10px 10px -5px rgba(0,0,0,0.2);
            width: clamp(300px, 90vw, 1000px);
            animation: fadeInScale 0.5s cubic-bezier(0.165, 0.84, 0.44, 1) forwards;
        }
        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .material-button {
            text-transform: uppercase;
            letter-spacing: 1.25px;
            font-weight: 500;
            box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14), 0 3px 1px -2px rgba(0,0,0,0.12), 0 1px 5px 0 rgba(0,0,0,0.2);
            transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease;
        }
        .material-button:active {
            box-shadow: 0 4px 5px 0 rgba(0,0,0,0.14), 0 1px 10px 0 rgba(0,0,0,0.12), 0 2px 4px -1px rgba(0,0,0,0.2);
            transform: translateY(1px);
        }
        .cooldown-circle {
            position: relative; width: 36px; height: 36px;
        }
        .cooldown-circle svg {
            transform: rotate(-90deg);
        }
        .cooldown-circle .icon {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
        }
        .cooldown-circle .text {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 13px; font-weight: bold;
        }
        .ban-pick-item {
            position: relative;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
        }
        .ban-pick-item.selectable:hover {
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px) scale(1.05);
        }
        .ban-pick-item .overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.7);
            display: flex; justify-content: center; align-items: center;
            font-size: 2rem;
            color: #ef4444;
            border-radius: 8px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        .ban-pick-item.banned .overlay { opacity: 1; }
        .ban-pick-item.picked-p1 { border-color: #3b82f6; transform: scale(1.05); }
        .ban-pick-item.picked-p2 { border-color: #ef4444; transform: scale(1.05); }
        .ban-pick-item .type-icon {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #tooltip {
            position: fixed;
            background-color: #1a1a1d;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 1rem;
            max-width: 250px;
            z-index: 99;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: top left;
        }
        .animate-pulse-fast { animation: pulse 0.5s cubic-bezier(0.4, 0.6, 1) infinite; }
        @keyframes pulse { 50% { opacity: .5; } }

        @keyframes pulse-border {
            50% { border-color: rgba(255, 255, 255, 0.6); }
        }
        .pulsing-slot {
            animation: pulse-border 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @media (max-width: 768px) {
             #game-container {
                display: flex; flex-direction: column; justify-content: center; align-items: center;
                padding: 0.5rem;
            }
            #ban-pick-screen .dialog-card {
                padding: 1rem;
                display: flex;
                flex-direction: column;
                max-height: 90vh;
            }
            #ban-pick-screen > div > div {
                flex-direction: column;
            }
            #ban-pick-screen .w-1\/4, #ban-pick-screen .w-1\/2 {
                width: 100%;
                padding: 0;
                margin-bottom: 1rem;
            }
            #ban-pick-screen .text-left, #ban-pick-screen .text-right {
                text-align: center;
            }
             #p1-bans, #p1-picks, #p2-bans, #p2-picks {
                justify-content: center;
            }
             #ban-pick-grid-container {
                max-height: 21vh; 
                overflow-y: auto;
                scrollbar-width: thin;
                scrollbar-color: #4a5568 #1a1a1d;
             }
            #ban-pick-grid-container::-webkit-scrollbar { width: 8px; }
            #ban-pick-grid-container::-webkit-scrollbar-track { background: #1a1a1d; }
            #ban-pick-grid-container::-webkit-scrollbar-thumb {
                background-color: #4a5568;
                border-radius: 4px;
                border: 2px solid #1a1a1d;
            }
        }
    </style>
</head>
<body class="text-white">

    <div id="game-container">
      <div id="top-ui" class="w-full flex flex-col items-center invisible px-2 py-2 md:py-0">
        <div id="player1-info" class="w-full max-w-lg mb-2">
            <div class="flex justify-between items-center">
                <h2 class="font-bold text-lg text-blue-500 flex items-center">
                    <span>Người chơi 1</span>
                    <span id="player1-status-icons" class="flex items-center ml-2 space-x-1"></span>
                </h2>
                <span id="player1-score" class="font-bold text-2xl text-white bg-black/20 px-3 rounded-md">0</span>
            </div>
             <div id="player1-active-effects" class="flex items-center space-x-2 mt-1 h-6"></div>
            <div id="player1-lives" class="flex items-center space-x-1 mt-1"></div>
        </div>
        <div id="player1-cooldown-timers" class="w-full max-w-lg flex justify-center flex-wrap gap-x-4 gap-y-1 mb-1 text-sm text-gray-300"></div>
        <div id="neutral-cooldown-timers" class="w-full max-w-lg flex justify-center flex-wrap gap-x-4 gap-y-1 text-sm text-gray-300"></div>
    </div>

   <canvas id="gameCanvas" class="my-2"></canvas>
    <div id="countdown-screen" class="screen-overlay">
        <h1 id="countdown-text" class="text-9xl font-bold text-white" style="text-shadow: 0 0 20px rgba(0,0,0,0.5);"></h1>
    </div>
    <div id="bottom-ui" class="w-full flex flex-col items-center invisible px-2 py-2 md:py-0">
       <div id="player2-info" class="w-full max-w-lg mt-2">
            <div class="flex justify-between items-center">
                <h2 class="font-bold text-lg text-red-500 flex items-center">
                    <span>Người chơi 2</span>
                    <span id="player2-status-icons" class="flex items-center ml-2 space-x-1"></span>
                </h2>
                <span id="player2-score" class="font-bold text-2xl text-white bg-black/20 px-3 rounded-md">0</span>
            </div>
             <div id="player2-active-effects" class="flex items-center space-x-2 mt-1 h-6"></div>
            <div id="player2-lives" class="flex items-center space-x-1 mt-1"></div>
        </div>
        <div id="player2-cooldown-timers" class="w-full max-w-lg flex justify-center flex-wrap gap-x-4 gap-y-1 mt-2 text-sm text-gray-300"></div>
    </div>

        <div id="start-screen" class="screen-overlay visible">
            <div class="dialog-card">
                <h1 class="text-5xl font-bold mb-8 text-gray-100">Đấu Trường Sinh Tử</h1>
                <button id="start-button" class="material-button bg-blue-600 hover:bg-blue-700 text-white py-4 px-8 rounded-lg text-2xl">Bắt đầu</button>
            </div>
        </div>

        <div id="ban-pick-screen" class="screen-overlay">
            <div class="dialog-card">
                <div class="flex justify-between w-full">
                    <!-- Player 1 Side -->
                    <div class="w-1/4 text-left">
                        <h3 class="text-lg font-bold text-blue-500">CẤM</h3>
                        <div id="p1-bans" class="flex space-x-2 mt-2 h-12"></div>
                        <h3 class="text-lg font-bold text-blue-500 mt-4">CHỌN</h3>
                        <div id="p1-picks" class="flex space-x-2 mt-2 h-12"></div>
                    </div>
                    
                    <!-- Center Grid -->
                    <div class="w-1/2 px-4 flex flex-col">
                        <div id="ban-pick-header-container" class="text-center mb-4 flex flex-col justify-center min-h-[112px] md:min-h-0">
                            <h2 id="ban-pick-title" class="text-2xl md:text-3xl font-bold text-gray-100"></h2>
                             <div id="ban-pick-info-mobile" class="hidden md:hidden p-2 bg-gray-900 rounded-lg text-left"></div>
                        </div>
                        <div id="ban-pick-grid-container" class="flex-grow">
                             <div id="ban-pick-grid" class="grid grid-cols-4 gap-4"></div>
                        </div>
                    </div>
        
                    <!-- Player 2 Side -->
                    <div class="w-1/4 text-right">
                        <h3 class="text-lg font-bold text-red-500">CẤM</h3>
                        <div id="p2-bans" class="flex space-x-2 mt-2 justify-end h-12"></div>
                        <h3 class="text-lg font-bold text-red-500 mt-4">CHỌN</h3>
                        <div id="p2-picks" class="flex space-x-2 mt-2 justify-end h-12"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="game-over-screen" class="screen-overlay">
             <div class="dialog-card">
                <h2 id="winner-text" class="text-4xl font-bold mb-4"></h2>
                <div id="results-details" class="my-6 text-lg"></div>
                <button id="restart-button" class="material-button mt-4 bg-green-600 hover:bg-green-700 text-white py-3 px-6 rounded-lg text-xl">Chơi lại</button>
            </div>
        </div>
    </div>
    <div id="tooltip"></div>

    <script>
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const banPickScreen = document.getElementById('ban-pick-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const winnerText = document.getElementById('winner-text');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const tooltip = document.getElementById('tooltip');
        let wakeLockSentinel = null;

        // Sound Manager using Tone.js
        const soundManager = {
            synth: null,
            polySynth: null,
            noise: null,
            isInitialized: false,
            init() {
                if (typeof Tone === 'undefined') {
                    console.warn("Tone.js not loaded, sounds will be disabled.");
                    return;
                }
                this.synth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.2 } }).toDestination();
                this.polySynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 0.4 } }).toDestination();
                this.noise = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination();
                this.isInitialized = true;
            },
            _canPlay() {
                return this.isInitialized && typeof Tone !== 'undefined' && Tone.context.state === 'running';
            },
            playClick: () => { if (!soundManager._canPlay()) return; soundManager.synth.triggerAttackRelease('C5', '8n'); },
            playSelect: () => { if (!soundManager._canPlay()) return; soundManager.synth.triggerAttackRelease('E5', '8n'); },
            playStart: () => { if (!soundManager._canPlay()) return; soundManager.polySynth.triggerAttackRelease(['C4', 'E4', 'G4'], '4n'); },
            playPickup: (type) => { if (!soundManager._canPlay()) return; soundManager.polySynth.triggerAttackRelease(ITEM_CONFIG[type].type === 'buff' ? ['C5', 'G5'] : ['A4', 'E5'], '16n'); },
            playDamage: () => { if (!soundManager._canPlay()) return; soundManager.noise.triggerAttackRelease('2n'); soundManager.synth.triggerAttackRelease('A2', '8n', Tone.now() + 0.01); },
            playGameOver: (win) => { if (!soundManager._canPlay()) return; win ? soundManager.polySynth.triggerAttackRelease(['C5', 'E5', 'G5', 'C6'], '2n') : soundManager.polySynth.triggerAttackRelease(['C3', 'D#3', 'G3'], '2n'); }
        };

        const ICONS = {
            weapon: `<svg class="h-8 w-8 text-yellow-400" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l2.5 6.5L21 9l-5 4.5L17 21l-5-3.5L7 21l1-7.5L3 9l6.5-.5L12 2z"/></svg>`,
            health: `<svg class="h-8 w-8 text-green-400" viewBox="0 0 24 24" fill="currentColor"><path d="M19 11h-6V5h-2v6H5v2h6v6h2v-6h6z"/></svg>`,
            bomb: `<svg class="h-8 w-8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="14" r="8" fill="#4a5568"/><rect x="10" y="3" width="4" height="4" rx="1" fill="#2d3748"/><circle cx="12" cy="2" r="1.5" fill="#ef4444"/></svg>`,
            shield: `<svg class="h-8 w-8 text-sky-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z"/></svg>`,
            grow: `<svg class="h-8 w-8 text-blue-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 8l-6 6h12l-6-6z"/></svg>`,
            shrink: `<svg class="h-8 w-8 text-orange-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 16l6-6H6l6 6z"/></svg>`,
            speedBoost: `<svg class="h-8 w-8 text-teal-400" viewBox="0 0 24 24" fill="currentColor"><path d="M13 2L3 14h9l-1 8 11-12h-9z"/></svg>`,
            rain: `<svg class="h-8 w-8 text-blue-300" viewBox="0 0 24 24" fill="currentColor"><path d="M19.35 10.04A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.04A5.994 5.994 0 0 0 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM9 19H7v-4h2v4zm4 0h-2v-4h2v4zm4 0h-2v-4h2v4z"/></svg>`,
            invisibility: `<svg class="h-8 w-8 text-gray-400" viewBox="0 0 24 24" fill="currentColor"><path d="M12,2A9,9 0 0,0 3,11V22L6,19L9,22L12,19L15,22L18,19L21,22V11A9,9 0 0,0 12,2M9,8A2,2 0 0,1 11,10A2,2 0 0,1 9,12A2,2 0 0,1 7,10A2,2 0 0,1 9,8M15,8A2,2 0 0,1 17,10A2,2 0 0,1 15,12A2,2 0 0,1 13,10A2,2 0 0,1 15,8Z" /></svg>`,
            wallSpikes: `<svg class="h-8 w-8 text-red-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 20h20v2H2v-2zM3.414 4L12 12.586 20.586 4 22 5.414 13.414 14 22 22.586 20.586 24 12 15.414 3.414 24 2 22.586 10.586 14 2 5.414 3.414 4z"/></svg>`,
            diagonalWall: `<svg class="h-8 w-8 text-indigo-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 21.0001L21 3.00006L19.5 1.50006L1.5 19.5L3 21.0001Z"/></svg>`,
            clone: `<svg class="h-8 w-8 text-purple-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3a9 9 0 0 0-9 9 9 9 0 0 0 9 9 9 9 0 0 0 9-9 9 9 0 0 0-9-9zm0 16a7 7 0 0 1-7-7 7 7 0 0 1 7-7 7 7 0 0 1 7 7 7 7 0 0 1-7 7zm-3-7a3 3 0 1 1 6 0 3 3 0 0 1-6 0z"/></svg>`,
            cannotEat: `<svg class="h-8 w-8 text-green-300" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8zm-2.8-10.2L11 11.6V8h2v5.1l-1.8 1.8-1.4-1.4 1.2-1.2-3.8-3.7z"/></svg>`,
            laserGun: `<svg class="h-8 w-8 text-pink-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M6 2L8 8H2V6H4.6L2.8 2.8L4.2 1.4L6 2M2 16H8L6 22L4.2 20.6L2.8 21.2L4.6 18H2V16M9 3H15V5H9V3M20.6 1.4L19.2 2.8L21.4 6H18V8H24L22 2L20.6 1.4M15 19H9V21H15V19M22 16H18V18H21.4L19.2 21.2L20.6 22.6L24 16Z"/></svg>`,
            slow: `<svg class="h-8 w-8 text-amber-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="m15 5-1.41 1.41L15 7.83V14.17l-1.41-1.41L12.17 14 17 18.83 21.83 14 20.41 12.59 19 14.17V7.83l1.41 1.41L21.83 8 17 3.17 12.17 8l1.41 1.41L15 7.83zM7 5l-1.41 1.41L7 7.83v6.34l-1.41-1.41L4.17 14 9 18.83 13.83 14 12.41 12.59 11 14.17V7.83l1.41 1.41L13.83 8 9 3.17 4.17 8l1.41 1.41L7 7.83z"/></svg>`,
            homingMissile: `<svg class="h-8 w-8 text-orange-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L9.91 5.95L6 6.18L8.73 9.09L8.09 13.05L12 11L15.91 13.05L15.27 9.09L18 6.18L14.09 5.95L12 2M22 13V15H17V13H22M2 13V15H15V13H2Z" /></svg>`,
            reflectiveCloak: `<svg class="h-8 w-8 text-fuchsia-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L1 9l4 1.5V21h14v-9.5L23 9l-11-7zm0 2.5l7 4.5-2 .75V19H7v-9.25L5 8l7-4.5zM9 13v2h6v-2H9z"/></svg>`,
            thieuThan: `<svg class="h-8 w-8 text-orange-500" viewBox="0 0 24 24" fill="currentColor"><path d="M9.1 5.2c1.3-2.1 3.1-3.7 5.2-4.5-1.2.9-2.1 2.2-2.7 3.7-1.1.2-2.1.6-2.9 1.2.4-.8.6-1.7.4-2.4zM16 3c.3.5.5 1.1.5 1.7 0 .5-.1 1-.3 1.5.8.5 1.5 1.2 1.9 2.1-.3-.1-.5-.2-.8-.3-.9-.2-1.8-.1-2.6.3.3-1 .5-2.1.2-3.1-.3-.8-.8-1.5-1.4-2 .8.3 1.5.8 2.5 1.8zM8.2 8.9c-.3.4-.6.8-.8 1.3-.2.9-.1 1.8.3 2.6.4.8 1 1.5 1.8 2 .3-.7.5-1.4.5-2.2 0-1.4-.5-2.8-1.4-3.9-.1 0-.2-.1-.4-.2zM15.1 11.8c-.8.7-1.3 1.6-1.5 2.6-.1.6 0 1.2.2 1.8.8.1 1.6-.2 2.2-.7.9-.7 1.4-1.7 1.5-2.8 0-.3 0-.6-.1-.9-.6-.2-1.2-.5-1.9-1.2-.2.1-.3.2-.4.2zM8.8 15.3c-.5.8-1.2 1.5-2.1 1.9.1-.3.2-.5.3-.8.2-1 .1-1.9-.3-2.7-.4-.8-1-1.5-1.8-2 .7-.3 1.5-.5 2.2-.5 1.4 0 2.8.5 3.9 1.4.1.2.2.3.2.4-.7.5-1.4 1-2.1 2.3zm8.3 1.9c.4.3.8.6 1.3.8.9.2 1.8.1 2.6-.3.8-.4 1.5-1 2-1.8-.7.3-1.4.5-2.2.5-1.4 0-2.8-.5-3.9-1.4-.2-.1-.3-.2-.4-.2.5.8 1.1 1.5 1.8 2.2.1.1.2.1.4.2z"/></svg>`,
			snare: `<svg class="h-8 w-8 text-lime-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12H17A5,5 0 0,0 12,7V4M4,12A8,8 0 0,1 12,4V7A5,5 0 0,0 7,12H4M12,20A8,8 0 0,1 4,12H7A5,5 0 0,0 12,17V20M20,12A8,8 0 0,1 12,20V17A5,5 0 0,0 17,12H20Z" /></svg>`
        };
        const ITEM_COLORS = {
            weapon: '#f6e05e', health: '#48bb78', bomb: '#f56565', shield: '#38bdf8',
            grow: '#63b3ed', shrink: '#f6ad55', speedBoost: '#4fd1c5', rain: '#3b82f6', 
            invisibility: '#9ca3af', wallSpikes: '#ef4444', diagonalWall: '#818cf8', clone: '#c084fc', 
            cannotEat: '#86efac', laserGun: '#f472b6', slow: '#f59e0b', homingMissile: '#f97316',
            reflectiveCloak: '#e879f9', thieuThan: '#f97316', snare: '#a3e635'
        };

        let players = [], items = {}, animationFrameId, gameEndTime, activeLaser = null, activeMissile = null;
        let activeRainZone = null, activeSpikeWall = null, activeDiagonalWall = null;
        let itemSpawnTimeouts = [];
        let particles = [];
        const TOTAL_GAME_TIME = 90 * 1000;
        const INITIAL_SPAWN_TIME = 5000;
        let banPickState = { currentIndex: 0, p1Bans: [], p2Bans: [], p1Picks: [], p2Picks: [], selectionCandidate: null };

        const ITEM_CONFIG = {
            weapon: { name: 'Vũ Khí Gai', baseRespawn: 10000, type: 'neutral', desc: 'Nhận một lớp gai tồn tại trong 5s. Va chạm với đối thủ sẽ gây sát thương và phá vỡ gai.', stats: { 'Thời gian': '5s', 'Hiệu ứng': '1 lần tấn công' } }, 
            health: { name: 'Hồi Máu', baseRespawn: 10000, type: 'neutral', desc: 'Hồi lại 1 mạng nếu chưa đầy máu. Không tự biến mất.', stats: { 'Hồi phục': '+1 Mạng' } }, 
            bomb: { name: 'Bom', baseRespawn: 5000, type: 'debuff', desc: 'Đặt một quả bom trên bản đồ. Đối thủ của người nhặt sẽ bị mất mạng nếu chạm phải.', stats: {} },
            shield: { name: 'Khiên', baseRespawn: 10000, type: 'neutral', desc: 'Nhận 1 lớp khiên chặn đòn tấn công hoặc hiệu ứng bất lợi tiếp theo.', stats: { 'Hiệu ứng': 'Chặn 1 đòn' } }, 
            reflectiveCloak: { name: 'Áo Choàng Phản', baseRespawn: 15000, type: 'buff', desc: 'Tồn tại 10s hoặc đến khi bị tấn công, sẽ phản lại sát thương cho đối thủ.', stats: { 'Thời gian': '10s', 'Hiệu ứng': '1 lần phản đòn'} },
            snare: { name: 'Trói Chân', baseRespawn: 15000, type: 'debuff', desc: 'Đặt một chiếc bẫy. Đối thủ của người nhặt sẽ bị trói chân trong 3 giây nếu dẫm phải.', stats: { 'Thời gian trói': '3s'} },
            grow: { name: 'Phóng To', baseRespawn: 12000, type: 'debuff', desc: 'Phóng to kích thước của đối thủ.', stats: { 'Thời gian': '10s', 'Kích thước': '+25%' } }, 
            shrink: { name: 'Thu Nhỏ', baseRespawn: 12000, type: 'buff', desc: 'Thu nhỏ kích thước bản thân.', stats: { 'Thời gian': '10s', 'Kích thước': '-25%' } }, 
            speedBoost: { name: 'Tăng Tốc', baseRespawn: 12000, type: 'buff', desc: 'Tăng mạnh tốc độ di chuyển.', stats: { 'Thời gian': '5s', 'Tốc độ': '+50%' } }, 
            slow: { name: 'Làm Chậm', baseRespawn: 12000, type: 'debuff', desc: 'Giảm tốc độ di chuyển của đối thủ.', stats: { 'Thời gian': '5s', 'Tốc độ': '-50%'}},
            rain: { name: 'Mưa bom', baseRespawn: 10000, type: 'debuff', desc: 'Tạo một vùng mưa gây sát thương lên đối thủ.', stats: { 'Thời gian': '5s', 'Sát thương': '3 lần' } }, 
            invisibility: { name: 'Tàng Hình', baseRespawn: 15000, type: 'buff', desc: 'Trở nên bất tử, miễn nhiễm sát thương.', stats: { 'Thời gian': '3s' } },
            wallSpikes: { name: 'Tường Gai', baseRespawn: 15000, type: 'map_effect', desc: 'Tạo gai trên một cạnh tường ngẫu nhiên. Người nhặt sẽ luôn miễn nhiễm.', stats: { 'Độ bền': '1 lần chạm' } }, 
            diagonalWall: { name: 'Tường Chéo', baseRespawn: 20000, type: 'map_effect', desc: 'Tạo một bức tường chéo ở góc.', stats: { 'Độ bền': '5 lần chạm' } }, 
            clone: { name: 'Phân Thân', baseRespawn: 15000, type: 'buff', desc: 'Tạo ra một bản sao của bản thân. Các bản thể chia sẻ chung trạng thái.', stats: { 'Tối đa': '3 bản thể' } },
            cannotEat: { name: 'Cấm Ăn', baseRespawn: 10000, type: 'debuff', desc: 'Khiến đối thủ không thể nhặt vật phẩm.', stats: { 'Thời gian': '5s' } },
            laserGun: { name: 'Súng Laze', baseRespawn: 20000, type: 'debuff', desc: 'Bắn một tia laze bật tường gây sát thương cho đối thủ.', stats: { 'Thời gian': '2s', 'Bật tường': '5 lần' }},
			thieuThan: { 
                name: 'Thiêu Thân', 
                baseRespawn: 10000, 
                type: 'buff', 
                desc: 'Tự động lao về phía đối thủ với tốc độ tăng dần khi đang có Vũ Khí Gai. Hiệu ứng kết thúc khi va chạm thành công.', 
                stats: { 'Tốc độ tối đa': 'x1.25', 'Điều kiện': 'Phải có Vũ Khí Gai' } 
            },
            homingMissile: { name: 'Tên Lửa', baseRespawn: 15000, type: 'debuff', desc: 'Bắn một tên lửa bám đuổi đối thủ. Nổ khi va chạm tường.', stats: {'Tồn tại': '10s'}}
        };

        const requestWakeLock = async () => {
            if ('wakeLock' in navigator) {
                try {
                    wakeLockSentinel = await navigator.wakeLock.request('screen');
                } catch (err) {
                    console.error(`Wake Lock failed: ${err.name}, ${err.message}`);
                }
            }
        };

        const releaseWakeLock = async () => {
            if (wakeLockSentinel) {
                await wakeLockSentinel.release();
                wakeLockSentinel = null;
            }
        };
					 
        const banPickSequence = [
            { phase: 'ban', player: 1 }, { phase: 'ban', player: 2 }, 
            { phase: 'pick', player: 1 }, { phase: 'pick', player: 2 }, { phase: 'pick', player: 1 }, 
            { phase: 'ban', player: 2 }, { phase: 'ban', player: 1 }, 
            { phase: 'pick', player: 2 }, { phase: 'pick', player: 2 }, 
            { phase: 'pick', player: 1 },
        ];

        function setCanvasSize() {
            const container = document.getElementById('game-container');
            const multiplier = window.innerWidth <= 768 ? 0.8 : 0.7;
            const size = Math.min(container.clientWidth, container.clientHeight) * multiplier;
            canvas.width = size; canvas.height = size;
        }

        class Particle {
            constructor(x, y, dx, dy, radius, color, life, friction = 1) { this.x = x; this.y = y; this.dx = dx; this.dy = dy; this.radius = radius; this.color = color; this.life = life; this.initialLife = life; this.friction = friction; }
            draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.globalAlpha = Math.max(0, this.life / this.initialLife); ctx.fillStyle = this.color; ctx.fill(); ctx.globalAlpha = 1; }
            update() { this.dx *= this.friction; this.dy *= this.friction; this.x += this.dx; this.y += this.dy; this.life--; }
        }
        
        class Laser {
            constructor(startPos, initialDir, owner) { this.owner = owner; this.startTime = Date.now(); this.endTime = this.startTime + 2000; this.segments = []; this.maxBounces = 5; this.calculatePath(startPos, initialDir); }
            calculatePath(currentPos, currentDir) { if (this.segments.length > this.maxBounces) return; let endPoint = null; let reflectionDir = { ...currentDir }; let minT = Infinity; if (currentDir.y < 0) { let t = -currentPos.y / currentDir.y; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: currentPos.x + t * currentDir.x, y: 0}; reflectionDir = {x: currentDir.x, y: -currentDir.y}; } } if (currentDir.y > 0) { let t = (canvas.height - currentPos.y) / currentDir.y; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: currentPos.x + t * currentDir.x, y: canvas.height}; reflectionDir = {x: currentDir.x, y: -currentDir.y}; } } if (currentDir.x < 0) { let t = -currentPos.x / currentDir.x; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: 0, y: currentPos.y + t * currentDir.y}; reflectionDir = {x: -currentDir.x, y: currentDir.y}; } } if (currentDir.x > 0) { let t = (canvas.width - currentPos.x) / currentDir.x; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: canvas.width, y: currentPos.y + t * currentDir.y}; reflectionDir = {x: -currentDir.x, y: currentDir.y}; } } if (endPoint) { this.segments.push({ p1: currentPos, p2: endPoint }); this.calculatePath(endPoint, reflectionDir); } }
            draw() { const lifeLeft = (this.endTime - Date.now()) / 2000; if (lifeLeft < 0) return; ctx.strokeStyle = this.owner.color; ctx.lineWidth = 4; ctx.shadowBlur = 10; ctx.shadowColor = this.owner.color; ctx.globalAlpha = lifeLeft; this.segments.forEach(seg => { ctx.beginPath(); ctx.moveTo(seg.p1.x, seg.p1.y); ctx.lineTo(seg.p2.x, seg.p2.y); ctx.stroke(); }); ctx.globalAlpha = 1; ctx.shadowBlur = 0; }
            checkCollision(ball) { for (const seg of this.segments) { const A = seg.p1, B = seg.p2, C = { x: ball.x, y: ball.y }, R = ball.radius; let AC = { x: C.x - A.x, y: C.y - A.y }; let AB = { x: B.x - A.x, y: B.y - A.y }; let magAB2 = AB.x * AB.x + AB.y * AB.y; let dot = AC.x * AB.x + AC.y * AB.y; let t = dot / magAB2; let closestX, closestY; if (t < 0) { closestX = A.x; closestY = A.y; } else if (t > 1) { closestX = B.x; closestY = B.y; } else { closestX = A.x + t * AB.x; closestY = A.y + t * AB.y; } let distSq = (C.x - closestX)**2 + (C.y - closestY)**2; if (distSq < R**2) { return true; } } return false; }
        }

        class RainZone {
            constructor(x, y, radius, owner) { this.x = x; this.y = y; this.radius = radius; this.owner = owner; this.startTime = Date.now(); this.endTime = this.startTime + 5000; this.drops = [ { time: 1000, triggered: false }, { time: 2500, triggered: false }, { time: 4000, triggered: false }]; }
            draw() { const progress = (Date.now() - this.startTime) / 5000; const alpha = 0.5 * (1 - progress); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = `rgba(56, 189, 248, ${alpha * 0.5})`; ctx.fill(); ctx.strokeStyle = `rgba(56, 189, 248, ${alpha})`; ctx.lineWidth = 2; ctx.stroke(); this.drops.forEach(drop => { const dropTime = this.startTime + drop.time; if (Date.now() > dropTime && Date.now() < dropTime + 200) { for(let i=0; i<15; i++) { const rainX = this.x + (Math.random() - 0.5) * this.radius * 2; const rainY = this.y + (Math.random() - 0.5) * this.radius * 2; if(Math.hypot(rainX - this.x, rainY - this.y) < this.radius) { ctx.beginPath(); ctx.moveTo(rainX, rainY - 5); ctx.lineTo(rainX, rainY + 5); ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)'; ctx.lineWidth = 1; ctx.stroke(); } } } }); }
            update() { const now = Date.now(); this.drops.forEach(drop => { if (!drop.triggered && now > this.startTime + drop.time) { getAllPlayerBalls().forEach(ball => { if (ball.controller !== this.owner && Math.hypot(ball.x - this.x, ball.y - this.y) < ball.radius + this.radius) { ball.controller.takeDamage(ball); } }); drop.triggered = true; } }); if (now > this.endTime) activeRainZone = null; }
        }

        class DiagonalWall {
            constructor() { this.hits = 5; this.corner = Math.floor(Math.random() * 4); const w = canvas.width; const h = canvas.height; const midW = w / 2; const midH = h / 2; const corners = [ { p1: { x: 0, y: midH }, p2: { x: midW, y: 0 } }, { p1: { x: midW, y: 0 }, p2: { x: w, y: midH } }, { p1: { x: w, y: midH }, p2: { x: midW, y: h } }, { p1: { x: midW, y: h }, p2: { x: 0, y: midH } } ]; this.p1 = corners[this.corner].p1; this.p2 = corners[this.corner].p2; let dx = this.p2.x - this.p1.x; let dy = this.p2.y - this.p1.y; this.normal = { x: -dy, y: dx }; const mag = Math.hypot(this.normal.x, this.normal.y); this.normal.x /= mag; this.normal.y /= mag; }
            draw() { ctx.beginPath(); ctx.moveTo(this.p1.x, this.p1.y); ctx.lineTo(this.p2.x, this.p2.y); ctx.strokeStyle = `rgba(129, 140, 248, ${0.4 + (this.hits / 5) * 0.6})`; ctx.lineWidth = 5; ctx.stroke(); }
        }
        
        class HomingMissile {
            constructor(owner, targetController) { this.owner = owner; this.targetController = targetController; const startBall = owner.balls[0]; this.x = startBall.x; this.y = startBall.y; this.baseSpeed = startBall.baseSpeed; this.currentSpeed = this.baseSpeed; this.angle = Math.random() * 2 * Math.PI; this.turnSpeed = 0.04; this.endTime = Date.now() + 10000; this.radius = 5; }
            update() { if (Date.now() > this.endTime || !this.targetController.balls.length) { activeMissile = null; return; } const target = this.targetController.balls[0]; const targetAngle = Math.atan2(target.y - this.y, target.x - this.x); let angleDiff = targetAngle - this.angle; while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI; while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI; const distToTarget = Math.hypot(this.x - target.x, this.y - target.y); if (Math.abs(angleDiff) > Math.PI / 2) { this.currentSpeed = this.baseSpeed * 0.75; } else if (distToTarget < canvas.width / 4) { this.currentSpeed = this.baseSpeed * 1.25; } else { this.currentSpeed = this.baseSpeed; } this.angle += angleDiff * this.turnSpeed; const dx = Math.cos(this.angle) * this.currentSpeed; const dy = Math.sin(this.angle) * this.currentSpeed; this.x += dx; this.y += dy; if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) { triggerEffect(this.x, this.y, ITEM_COLORS.homingMissile, { count: 20 }); activeMissile = null; return; } if(distToTarget < this.radius + target.radius) { this.targetController.takeDamage(target, this.owner); triggerEffect(this.x, this.y, ITEM_COLORS.homingMissile, { count: 30, speed: 4 }); activeMissile = null; } }
            draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = this.owner.color; ctx.shadowBlur = 10; ctx.shadowColor = this.owner.color; ctx.beginPath(); ctx.moveTo(this.radius, 0); ctx.lineTo(-this.radius, -this.radius / 1.5); ctx.lineTo(-this.radius, this.radius / 1.5); ctx.closePath(); ctx.fill(); ctx.restore(); ctx.shadowBlur = 0; }
        }
        
        class PlayerBall {
            constructor(x, y, baseRadius, controller) { this.controller = controller; this.x = x; this.y = y; this.baseRadius = baseRadius; this.baseSpeed = (canvas.width / 200) * 4.5 * 0.75 * 0.9; this.speed = this.baseSpeed; let angle = Math.random() * Math.PI * 2; this.dx = Math.cos(angle) * this.speed; this.dy = Math.sin(angle) * this.speed; }
            get radius() { return this.controller.sizeEffect === 'shrink' ? this.baseRadius * 0.75 : (this.controller.sizeEffect === 'grow' ? this.baseRadius * 1.25 : this.baseRadius); }
            get isSnared() { return this.controller.snaredUntil && Date.now() < this.controller.snaredUntil; }
            
            draw() {
                ctx.globalAlpha = 1;
                if (this.controller.invincibleUntil && Date.now() < this.controller.invincibleUntil) { if (Math.floor(Date.now() / 150) % 2 === 0) { ctx.globalAlpha = 0.5; } }
                
                // Draw Speed Boost Tail
                if (this.controller.speedMultiplier > 1 && this.controller.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(this.controller.trail[0].x, this.controller.trail[0].y);
                    for(let i = 1; i < this.controller.trail.length; i++) {
                        const p = this.controller.trail[i];
                        const progress = i / this.controller.trail.length;
                        ctx.globalAlpha = progress * 0.6;
                        ctx.lineTo(p.x, p.y);
                    }
                    ctx.strokeStyle = ITEM_COLORS.speedBoost;
                    ctx.lineWidth = this.radius * 0.8;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                // Draw armor layers
                this.controller.armor.forEach((armorType, index) => { if (armorType === 'weapon') return; const armorRadius = this.radius + 5 + (index * 4); const armorColor = ITEM_COLORS[armorType] || '#ffffff'; ctx.beginPath(); ctx.arc(this.x, this.y, armorRadius, 0, Math.PI * 2); ctx.strokeStyle = armorColor; ctx.lineWidth = 2; ctx.stroke(); ctx.closePath(); });

                // Draw ball
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.controller.color; ctx.fill();
                
                // Draw Weapon Spikes
                if (this.controller.armor.includes('weapon')) {
                    const spikes = 8; const angleStep = (Math.PI * 2) / spikes; const spikeLength = this.radius * 0.6; const rotation = (Date.now() / 150);
                    ctx.strokeStyle = ITEM_COLORS.weapon; ctx.lineWidth = 3; ctx.beginPath();
                    for (let i = 0; i < spikes; i++) {
                        const angle = i * angleStep + rotation;
                        const startX = this.x + Math.cos(angle) * this.radius; const startY = this.y + Math.sin(angle) * this.radius;
                        const endX = this.x + Math.cos(angle) * (this.radius + spikeLength); const endY = this.y + Math.sin(angle) * (this.radius + spikeLength);
                        ctx.moveTo(startX, startY); ctx.lineTo(endX, endY);
                    }
                    ctx.stroke();
                }

                // Other effects
                if (this.controller.sizeEffect) { ctx.strokeStyle = this.controller.sizeEffect === 'grow' ? '#f6ad55' : '#63b3ed'; ctx.lineWidth = 4; ctx.stroke(); }
                if (this.controller.cannotEatUntil && Date.now() < this.controller.cannotEatUntil) { ctx.strokeStyle = ITEM_COLORS.cannotEat; ctx.lineWidth = 4; ctx.stroke(); }
                if (this.isSnared) { ctx.strokeStyle = ITEM_COLORS.snare; ctx.lineWidth = 4; ctx.stroke(); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2); ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]); }
                
                ctx.closePath();
                ctx.globalAlpha = 1;
            }
            update() { if (!this.isSnared) { this.x += this.dx; this.y += this.dy; } }
        }

        class PlayerController {
            constructor(name, color, initialBall) { this.name = name; this.color = color; this.lives = 5; this.balls = [initialBall]; this.hasSpikeWallImmunity = false; this.armor = []; this.invincibleUntil = null; this.sizeEffect = null; this.speedMultiplier = 1.0; this.effectTimeouts = {}; this.timedEffects = {}; this.cannotEatUntil = null; this.snaredUntil = null; this.score = 0; this.hasThieuThanBuff = false; this.isThieuThanActive = false; this.trail = []; }
            
            takeDamage(ball, attacker = null, isReflectedDamage = false) {
                const now = Date.now();
                if (this.invincibleUntil && now < this.invincibleUntil) return false;
                soundManager.playDamage();

                const realArmorIndex = this.armor.findIndex(type => type !== 'weapon');
                if (realArmorIndex > -1) {
                    const armorType = this.armor.splice(realArmorIndex, 1)[0]; 
                    if (armorType === 'shield') { const shieldData = items['shield']; if (shieldData) { shieldData.cooldownEndTime = Date.now() + shieldData.currentRespawn; itemSpawnTimeouts.push(setTimeout(() => spawnItem('shield'), shieldData.currentRespawn)); } }
                    if (armorType === 'reflectiveCloak') { clearTimeout(this.effectTimeouts.reflectiveCloak); delete this.timedEffects.reflectiveCloak; }
                    triggerEffect(ball.x, ball.y, ITEM_COLORS[armorType] || this.color, { count: 25, speed: 5 });
                    
                    if (!isReflectedDamage && (armorType === 'reflectiveCloak') && attacker && attacker.balls.length > 0) { attacker.takeDamage(attacker.balls[0], this, true); }
                    updateLivesUI();
                    return false;
                }

                this.lives--; 
                this.invincibleUntil = now + 2000; 
                updateLivesUI();
                if (attacker) { attacker.score++; updateScoreUI(); if (attacker.score >= 10) { endGame(false, attacker); return true; } }

                if (this.lives <= 0) { triggerDeath(this); } else { pauseGameForEffect({ duration: 1200, shake: 5 }); } 
                return true;
            } 
            
            addBall() { if (this.balls.length >= 3) return; const parentBall = this.balls[0]; const newBall = new PlayerBall(parentBall.x + (Math.random() - 0.5) * 20, parentBall.y + (Math.random() - 0.5) * 20, this.balls[0].baseRadius, this); let angle = Math.random() * Math.PI * 2; newBall.dx = Math.cos(angle) * newBall.speed; newBall.dy = Math.sin(angle) * newBall.speed; updatePlayerVelocity(newBall); this.balls.push(newBall); triggerEffect(newBall.x, newBall.y, this.color, { count: 30, speed: 4 }); }
            removeBall(ball) { const index = this.balls.indexOf(ball); if (index > -1) { triggerEffect(ball.x, ball.y, this.color, { count: 15, speed: 3, life: 30 }); this.balls.splice(index, 1); } }
            
            applyEffect(effectType, duration, value) {
                clearTimeout(this.effectTimeouts[effectType]);
                const endTime = Date.now() + duration;
                this.timedEffects[effectType] = { endTime, duration };
                
                switch(effectType) {
                    case 'size': this.sizeEffect = value; break;
                    case 'speed': this.speedMultiplier = value; break;
                    case 'cannotEat': this.cannotEatUntil = endTime; break;
                    case 'snare': this.snaredUntil = endTime; break;
                    case 'reflectiveCloak': if (!this.armor.includes('reflectiveCloak')) { this.armor.push('reflectiveCloak'); } updateLivesUI(); break;
                }

                this.effectTimeouts[effectType] = setTimeout(() => {
                    delete this.timedEffects[effectType];
                    switch(effectType) {
                        case 'size': this.sizeEffect = null; break;
                        case 'speed': this.speedMultiplier = 1.0; this.trail = []; break;
                        case 'cannotEat': this.cannotEatUntil = null; break;
                        case 'snare': this.snaredUntil = null; break;
                        case 'reflectiveCloak':
                            const index = this.armor.indexOf('reflectiveCloak');
                            if(index > -1) this.armor.splice(index, 1);
                            const itemData = items['reflectiveCloak'];
                            if (itemData) { const respawnTime = itemData.currentRespawn; itemData.cooldownEndTime = Date.now() + respawnTime; itemSpawnTimeouts.push(setTimeout(() => spawnItem('reflectiveCloak'), respawnTime)); }
                            updateLivesUI();
                            break;
                    }
                    updatePlayerStatusUI();
                }, duration);
                updatePlayerStatusUI();
            }
        }
        
        class Item {
            constructor(x, y, radius, type, owner, duration = null) { this.x = x; this.y = y; this.radius = radius; this.type = type; this.owner = owner; }
            draw() { if (this.owner && this.owner !== 'neutral') { ctx.shadowBlur = 15; ctx.shadowColor = this.owner.color; } const drawFunc = ITEM_DRAW_LOGIC[this.type]; if (drawFunc) drawFunc(this); ctx.shadowBlur = 0; }
        }

        const ITEM_DRAW_LOGIC = {
            weapon: (item) => { ctx.fillStyle = '#f6e05e'; ctx.strokeStyle = '#b7791f'; for (let i = 0; i < 8; i++) { let angle = (i / 8) * (Math.PI * 2); let outerRadius = item.radius * 1.4; ctx.beginPath(); ctx.moveTo(item.x, item.y); ctx.lineTo(item.x + Math.cos(angle) * outerRadius, item.y + Math.sin(angle) * outerRadius); ctx.stroke(); } ctx.beginPath(); ctx.arc(item.x, item.y, item.radius * 0.8, 0, Math.PI * 2); ctx.fill(); },
            health: (item) => { ctx.fillStyle = '#48bb78'; ctx.strokeStyle = '#2f855a'; const barWidth = item.radius * 1.5; const barHeight = item.radius * 0.5; ctx.fillRect(item.x - barWidth / 2, item.y - barHeight / 2, barWidth, barHeight); ctx.strokeRect(item.x - barWidth / 2, item.y - barHeight / 2, barWidth, barHeight); ctx.fillRect(item.x - barHeight / 2, item.y - barWidth / 2, barHeight, barWidth); ctx.strokeRect(item.x - barHeight / 2, item.y - barWidth / 2, barHeight, barWidth); },
            bomb: (item) => { ctx.fillStyle = '#4a5568'; ctx.strokeStyle = '#1a202c'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#2d3748'; ctx.fillRect(item.x - item.radius * 0.2, item.y - item.radius * 1.2, item.radius * 0.4, item.radius * 0.4); const pulse = Math.abs(Math.sin(Date.now() / 150)); ctx.fillStyle = `rgba(255, ${150 + pulse * 105}, 0, ${0.8 + pulse * 0.2})`; ctx.beginPath(); ctx.arc(item.x, item.y - item.radius * 1.2, 3, 0, Math.PI * 2); ctx.fill(); },
			thieuThan: (item) => { const iconContainer = document.createElement('div'); iconContainer.innerHTML = ICONS.thieuThan; const svg = iconContainer.firstChild; const path = svg.querySelector('path'); const color = ITEM_COLORS.thieuThan; ctx.fillStyle = color; ctx.strokeStyle = '#dd6b20'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.save(); ctx.translate(item.x, item.y); const scale = (item.radius * 1.6) / 24; ctx.scale(scale, scale); ctx.fillStyle = color; ctx.fill(new Path2D(path.getAttribute('d'))); ctx.restore(); },
            shield: (item) => { ctx.fillStyle = '#38bdf8'; ctx.strokeStyle = '#0284c7'; ctx.beginPath(); ctx.moveTo(item.x, item.y - item.radius); ctx.lineTo(item.x - item.radius, item.y - item.radius * 0.3); ctx.lineTo(item.x - item.radius, item.y + item.radius * 0.5); ctx.arc(item.x, item.y + item.radius * 0.5, item.radius, Math.PI, 0, false); ctx.lineTo(item.x + item.radius, item.y - item.radius * 0.3); ctx.closePath(); ctx.fill(); ctx.stroke(); },
            grow: (item) => { const isGrow = true; ctx.fillStyle = isGrow ? '#63b3ed' : '#f6ad55'; ctx.strokeStyle = isGrow ? '#3182ce' : '#dd6b20'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; const arrowHeight = item.radius * 0.5; const arrowWidth = item.radius * 0.6; const direction = isGrow ? -1 : 1; ctx.beginPath(); ctx.moveTo(item.x - arrowWidth, item.y + direction * arrowHeight); ctx.lineTo(item.x, item.y - direction * arrowHeight); ctx.lineTo(item.x + arrowWidth, item.y + direction * arrowHeight); ctx.closePath(); ctx.fill(); },
            shrink: (item) => { const isGrow = false; ctx.fillStyle = isGrow ? '#63b3ed' : '#f6ad55'; ctx.strokeStyle = isGrow ? '#3182ce' : '#dd6b20'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; const arrowHeight = item.radius * 0.5; const arrowWidth = item.radius * 0.6; const direction = isGrow ? -1 : 1; ctx.beginPath(); ctx.moveTo(item.x - arrowWidth, item.y + direction * arrowHeight); ctx.lineTo(item.x, item.y - direction * arrowHeight); ctx.lineTo(item.x + arrowWidth, item.y + direction * arrowHeight); ctx.closePath(); ctx.fill(); },
            speedBoost: (item) => { ctx.fillStyle = '#4fd1c5'; ctx.strokeStyle = '#319795'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; ctx.beginPath(); ctx.moveTo(item.x + item.radius * 0.3, item.y - item.radius * 0.6); ctx.lineTo(item.x - item.radius * 0.4, item.y); ctx.lineTo(item.x, item.y); ctx.lineTo(item.x - item.radius * 0.3, item.y + item.radius * 0.6); ctx.lineTo(item.x + item.radius * 0.4, item.y); ctx.lineTo(item.x, item.y); ctx.closePath(); ctx.fill(); },
            rain: (item) => { ctx.fillStyle = ITEM_COLORS.rain; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; ctx.fillRect(item.x - item.radius * 0.5, item.y, 2, 5); ctx.fillRect(item.x, item.y + item.radius * 0.2, 2, 5); ctx.fillRect(item.x + item.radius * 0.5, item.y, 2, 5); },
            invisibility: (item) => { ctx.fillStyle = ITEM_COLORS.invisibility; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(item.x - item.radius * 0.3, item.y - item.radius * 0.2, item.radius * 0.15, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(item.x + item.radius * 0.3, item.y - item.radius * 0.2, item.radius * 0.15, 0, Math.PI * 2); ctx.fill(); },
            wallSpikes: (item) => { ctx.fillStyle = ITEM_COLORS.wallSpikes; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.rect(item.x - item.radius, item.y + item.radius * 0.5, item.radius * 2, item.radius * 0.5); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; for (let i = 0; i < 3; i++) { const xPos = item.x - item.radius * 0.6 + i * item.radius * 0.6; ctx.beginPath(); ctx.moveTo(xPos - item.radius * 0.2, item.y + item.radius * 0.5); ctx.lineTo(xPos, item.y - item.radius * 0.5); ctx.lineTo(xPos + item.radius * 0.2, item.y + item.radius * 0.5); ctx.closePath(); ctx.fill(); } },
            diagonalWall: (item) => { ctx.fillStyle = ITEM_COLORS.diagonalWall; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(item.x - item.radius * 0.7, item.y + item.radius * 0.7); ctx.lineTo(item.x + item.radius * 0.7, item.y - item.radius * 0.7); ctx.stroke(); },
            clone: (item) => { ctx.fillStyle = ITEM_COLORS.clone; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x - item.radius * 0.3, item.y, item.radius * 0.8, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.arc(item.x + item.radius * 0.3, item.y, item.radius * 0.8, 0, Math.PI * 2); ctx.globalAlpha = 0.7; ctx.fill(); ctx.stroke(); ctx.globalAlpha = 1; },
            cannotEat: (item) => { ctx.fillStyle = ITEM_COLORS.cannotEat; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius * 0.6, Math.PI * 0.2, Math.PI * 1.8); ctx.stroke(); },
            laserGun: (item) => { ctx.fillStyle = ITEM_COLORS.laserGun; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(item.x - item.radius * 0.5, item.y); ctx.lineTo(item.x + item.radius * 0.5, item.y); ctx.stroke(); ctx.beginPath(); ctx.moveTo(item.x, item.y - item.radius * 0.5); ctx.lineTo(item.x, item.y + item.radius * 0.5); ctx.stroke(); },
            slow: (item) => { ctx.fillStyle = ITEM_COLORS.slow; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; ctx.beginPath(); ctx.moveTo(item.x - 5, item.y + 5); ctx.lineTo(item.x, item.y); ctx.lineTo(item.x + 5, item.y + 5); ctx.moveTo(item.x - 5, item.y); ctx.lineTo(item.x, item.y - 5); ctx.lineTo(item.x + 5, item.y); ctx.lineWidth = 2; ctx.stroke(); },
            homingMissile: (item) => { ctx.fillStyle = ITEM_COLORS.homingMissile; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.moveTo(item.x, item.y - item.radius); ctx.lineTo(item.x - item.radius, item.y + item.radius * 0.5); ctx.lineTo(item.x + item.radius, item.y + item.radius * 0.5); ctx.closePath(); ctx.fill(); ctx.stroke(); },
            reflectiveCloak: (item) => { ctx.fillStyle = ITEM_COLORS.reflectiveCloak; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); },
            snare: (item) => { ctx.fillStyle = ITEM_COLORS.snare; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); },
            snare_trap: (item) => { ctx.strokeStyle = ITEM_COLORS.snare; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.stroke(); ctx.beginPath(); ctx.arc(item.x, item.y, item.radius * 0.5, 0, Math.PI * 2); ctx.stroke(); },
            bomb_trap: (item) => { ctx.fillStyle = '#4a5568'; ctx.strokeStyle = '#1a202c'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#2d3748'; ctx.fillRect(item.x - item.radius * 0.2, item.y - item.radius * 1.2, item.radius * 0.4, item.radius * 0.4); const pulse = Math.abs(Math.sin(Date.now() / 150)); ctx.fillStyle = `rgba(255, ${150 + pulse * 105}, 0, ${0.8 + pulse * 0.2})`; ctx.beginPath(); ctx.arc(item.x, item.y - item.radius * 1.2, 3, 0, Math.PI * 2); ctx.fill(); }
        };
        
        function updateLivesUI() {
            if (!players[0] || !players[1]) return;
            const p1LivesDiv = document.getElementById('player1-lives');
            const p2LivesDiv = document.getElementById('player2-lives');
            
            const renderLives = (container, player, colorClass) => {
                container.innerHTML = '';
                for (let i = 0; i < 5; i++) { container.innerHTML += `<div class="w-4 h-4 ${i < player.lives ? colorClass : 'bg-gray-700'} rounded-full"></div>`; }
                const armorContainer = document.createElement('div');
                armorContainer.className = 'flex items-center space-x-1 ml-2';
                player.armor.forEach(armorType => { armorContainer.innerHTML += `<div class="w-4 h-4">${ICONS[armorType].replace('h-8 w-8', 'h-4 w-4')}</div>`; });
                container.appendChild(armorContainer);
            };

            renderLives(p1LivesDiv, players[0], 'bg-blue-500');
            renderLives(p2LivesDiv, players[1], 'bg-red-500');
        }
		function updateScoreUI() {
            if (!players[0] || !players[1]) return;
            document.getElementById('player1-score').textContent = players[0].score;
            document.getElementById('player2-score').textContent = players[1].score;
        }

        function updatePlayerStatusUI() {
            if (!players[0] || !players[1]) return;
            const p1_icons = document.getElementById('player1-status-icons');
            const p2_icons = document.getElementById('player2-status-icons');
            const p1_effects = document.getElementById('player1-active-effects');
            const p2_effects = document.getElementById('player2-active-effects');

            const smallIcon = (svg) => svg ? svg.replace('h-8 w-8', 'h-4 w-4') : '';

            const updateUIForPlayer = (player, iconContainer, effectContainer) => {
                iconContainer.innerHTML = '';
                effectContainer.innerHTML = '';

                if (player.isThieuThanActive) { iconContainer.innerHTML += `<div class="w-4 h-4 text-orange-500 animate-pulse-fast">${smallIcon(ICONS.thieuThan)}</div>`; } 
                else if (player.hasThieuThanBuff) { iconContainer.innerHTML += `<div class="w-4 h-4 text-gray-600">${smallIcon(ICONS.thieuThan)}</div>`; }
                if (player.hasSpikeWallImmunity) iconContainer.innerHTML += smallIcon(ICONS.wallSpikes);
                if (player.balls.length > 1) iconContainer.innerHTML += `<span class="text-sm font-bold text-purple-400">x${player.balls.length}</span>`;

                const now = Date.now();
                for (const type in player.timedEffects) {
                    const effect = player.timedEffects[type];
                    const remaining = effect.endTime - now;
                    if (remaining > 0) {
                        let iconType = type;
                        if (type === 'size') {
                            iconType = player.sizeEffect; // 'grow' or 'shrink'
                        } else if (type === 'speed') {
                            iconType = player.speedMultiplier > 1 ? 'speedBoost' : 'slow';
                        }
                        
                        if (ICONS[iconType]) {
                            const progress = (remaining / effect.duration) * 100;
                            effectContainer.innerHTML += `
                                <div class="flex items-center space-x-1 bg-black/30 rounded-full px-2 py-0.5 h-full">
                                    ${smallIcon(ICONS[iconType])}
                                    <div class="w-8 h-1 bg-gray-600 rounded-full overflow-hidden">
                                        <div class="h-full bg-white rounded-full" style="width: ${progress}%"></div>
                                    </div>
                                </div>`;
                        }
                    }
                }
            };
            
            updateUIForPlayer(players[0], p1_icons, p1_effects);
            updateUIForPlayer(players[1], p2_icons, p2_effects);
        }
        
        function getRandomPosition(radius) { return { x: Math.random() * (canvas.width - radius * 2) + radius, y: Math.random() * (canvas.height - radius * 2) + radius } }
        function triggerEffect(x, y, color, { count = 20, speed = 3, life = 40, friction = 0.95 } = {}) { for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const currentSpeed = Math.random() * speed + 1; particles.push(new Particle( x, y, Math.cos(angle) * currentSpeed, Math.sin(angle) * currentSpeed, Math.random() * 2 + 1, color, life, friction )); } }
        function spawnItem(type) { if (type === 'shield' || type === 'weapon') { if (players.some(p => p.armor.includes(type))) return; }; if (items[type] && items[type].item) return; const radius = canvas.width / 40; const pos = getRandomPosition(radius); items[type].item = new Item(pos.x, pos.y, radius, type, items[type].owner); items[type].cooldownEndTime = null; }
        function updatePlayerVelocity(playerBall) { const mag = Math.hypot(playerBall.dx, playerBall.dy); if (mag > 0) { playerBall.dx = (playerBall.dx / mag) * playerBall.speed; playerBall.dy = (playerBall.dy / mag) * playerBall.speed; } }
        const getAllPlayerBalls = () => players.flatMap(p => p.balls);

        function handleDiagonalWallCollision(ball) { if (!activeDiagonalWall) return; const p1 = activeDiagonalWall.p1; const p2 = activeDiagonalWall.p2; const p1_to_player = { x: ball.x - p1.x, y: ball.y - p1.y }; const p1_to_p2 = { x: p2.x - p1.x, y: p2.y - p1.y }; const len_p1_p2_sq = p1_to_p2.x * p1_to_p2.x + p1_to_p2.y * p1_to_p2.y; const dot = p1_to_player.x * p1_to_p2.x + p1_to_player.y * p1_to_p2.y; const t = Math.max(0, Math.min(1, dot / len_p1_p2_sq)); const closestPoint = { x: p1.x + t * p1_to_p2.x, y: p1.y + t * p1_to_p2.y }; const distSq = (ball.x - closestPoint.x)**2 + (ball.y - closestPoint.y)**2; if (distSq < ball.radius**2) { const dist = Math.sqrt(distSq); const overlap = ball.radius - dist; if (dist > 0) { ball.x += overlap * (ball.x - closestPoint.x) / dist; ball.y += overlap * (ball.y - closestPoint.y) / dist; } const v = { x: ball.dx, y: ball.dy }; const n = { ...activeDiagonalWall.normal }; const side_check = (ball.x - p1.x) * n.y - (ball.y - p1.y) * n.x; if (side_check > 0) { n.x *= -1; n.y *= -1; } const dot_v_n = v.x * n.x + v.y * n.y; ball.dx = v.x - 2 * dot_v_n * n.x; ball.dy = v.y - 2 * dot_v_n * n.y; activeDiagonalWall.hits--; triggerEffect(closestPoint.x, closestPoint.y, ITEM_COLORS.diagonalWall, { count: 10, speed: 2 }); if (activeDiagonalWall.hits <= 0) { triggerEffect(closestPoint.x, closestPoint.y, ITEM_COLORS.diagonalWall, { count: 30, speed: 5 }); activeDiagonalWall = null; } } }
        function handleWallCollisions(ball) { const now = Date.now(); let bounced = false; if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) { ball.dx = -ball.dx; bounced = true; } if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) { ball.dy = -ball.dy; bounced = true; } ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x)); ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y)); if (activeSpikeWall && bounced) { const sideHit = (ball.x - ball.radius <= 1 && activeSpikeWall.side === 'left') || (ball.x + ball.radius >= canvas.width - 1 && activeSpikeWall.side === 'right') || (ball.y - ball.radius <= 1 && activeSpikeWall.side === 'top') || (ball.y + ball.radius >= canvas.height - 1 && activeSpikeWall.side === 'bottom'); if (sideHit) { if (ball.controller !== activeSpikeWall.owner) { ball.controller.takeDamage(ball); triggerEffect(ball.x, ball.y, ITEM_COLORS.wallSpikes, { count: 20, speed: 5 }); activeSpikeWall = null; updatePlayerStatusUI(); } } } }
        function deactivateThieuThan(player) {
            if (!player.hasThieuThanBuff) return;
            player.isThieuThanActive = false;
            player.hasThieuThanBuff = false; // Mất buff sau khi tấn công
            const itemData = items['thieuThan'];
            if (itemData) { const respawnTime = itemData.currentRespawn; itemData.cooldownEndTime = Date.now() + respawnTime; itemSpawnTimeouts.push(setTimeout(() => spawnItem('thieuThan'), respawnTime)); }
            updatePlayerStatusUI();
        }
        function handleCollisions() {
            const allBalls = getAllPlayerBalls();
            for (let i = 0; i < allBalls.length; i++) {
                for (let j = i + 1; j < allBalls.length; j++) {
                    const b1 = allBalls[i]; const b2 = allBalls[j];
                    if (b1.controller === b2.controller) continue;
                    const dist = Math.hypot(b1.x - b2.x, b1.y - b2.y);
                    if (dist < b1.radius + b2.radius) {
                        const overlap = b1.radius + b2.radius - dist; const nx = (b2.x - b1.x) / dist; const ny = (b2.y - b1.y) / dist;
                        if (!b1.isSnared && !b2.isSnared) { b1.x -= overlap / 2 * nx; b1.y -= overlap / 2 * ny; b2.x += overlap / 2 * nx; b2.y += overlap / 2 * ny; } 
                        else if (b1.isSnared && !b2.isSnared) { b2.x += overlap * nx; b2.y += overlap * ny; } 
                        else if (!b1.isSnared && b2.isSnared) { b1.x -= overlap * nx; b1.y -= overlap * ny; }
                        const tx = -ny; const ty = nx; const dpTan1 = b1.dx * tx + b1.dy * ty; const dpTan2 = b2.dx * tx + b2.dy * ty; const dpNorm1 = b1.dx * nx + b1.dy * ny; const dpNorm2 = b2.dx * nx + b2.dy * ny;
                        if (!b1.isSnared) { b1.dx = tx * dpTan1 + nx * dpNorm2; b1.dy = ty * dpTan1 + ny * dpNorm2; }
                        if (!b2.isSnared) { b2.dx = tx * dpTan2 + nx * dpNorm1; b2.dy = ty * dpTan2 + ny * dpNorm1; }
                        updatePlayerVelocity(b1); updatePlayerVelocity(b2);

                        const b1HasGai = b1.controller.armor.includes('weapon');
                        const b2HasGai = b2.controller.armor.includes('weapon');

                        const startWeaponCooldown = () => { const weaponData = items['weapon']; if (weaponData) { weaponData.cooldownEndTime = Date.now() + weaponData.currentRespawn; itemSpawnTimeouts.push(setTimeout(() => spawnItem('weapon'), weaponData.currentRespawn)); } };

                        if (b1HasGai) {
                            const damageDealt = b2.controller.takeDamage(b2, b1.controller);
                            if (damageDealt) { // Only remove if damage was successfully dealt (not blocked)
                                const b1GaiIndex = b1.controller.armor.lastIndexOf('weapon');
                                if (b1GaiIndex > -1) { b1.controller.armor.splice(b1GaiIndex, 1); clearTimeout(b1.controller.effectTimeouts.weapon); delete b1.controller.timedEffects.weapon; startWeaponCooldown(); }
                                deactivateThieuThan(b1.controller);
                            }
                        }
                        if (b2HasGai) {
                            const damageDealt = b1.controller.takeDamage(b1, b2.controller);
                             if (damageDealt) {
                                const b2GaiIndex = b2.controller.armor.lastIndexOf('weapon');
                                if (b2GaiIndex > -1) { b2.controller.armor.splice(b2GaiIndex, 1); clearTimeout(b2.controller.effectTimeouts.weapon); delete b2.controller.timedEffects.weapon; startWeaponCooldown(); }
                                deactivateThieuThan(b2.controller);
                            }
                        }
                        updateLivesUI();
                    }
                }
                 const ball = allBalls[i];
                 for (const type in items) {
                    const itemData = items[type];
                    if (itemData.item && Math.hypot(ball.x - itemData.item.x, ball.y - itemData.item.y) < ball.radius + itemData.item.radius) {
                        handleItemPickup(ball, type);
                    }
                }
            }
        }

        const ITEM_PICKUP_LOGIC = {
            weapon: (ball) => { const player = ball.controller; clearTimeout(player.effectTimeouts.weapon); if (!player.armor.includes('weapon')) { player.armor.push('weapon'); } const duration = 5000; player.timedEffects.weapon = { endTime: Date.now() + duration, duration }; player.effectTimeouts.weapon = setTimeout(() => { const index = player.armor.indexOf('weapon'); if (index > -1) { player.armor.splice(index, 1); updateLivesUI(); } delete player.timedEffects.weapon; }, duration); updateLivesUI(); return true; },
            health: (ball) => { if (ball.controller.lives < 5) { ball.controller.lives++; updateLivesUI(); return true; } return false; },
            bomb: (ball) => { const radius = canvas.width / 40; const pos = getRandomPosition(radius); items['bomb_trap'] = { item: new Item(pos.x, pos.y, radius, 'bomb_trap', ball.controller, 7000) }; return true; },
            bomb_trap: (ball, itemData) => { const trapOwner = itemData.item.owner; const steppingPlayer = ball.controller; let trigger = false; if (trapOwner === 'neutral' || steppingPlayer !== trapOwner) { trigger = true; } if (trigger) { const bombPos = { x: itemData.item.x, y: itemData.item.y }; triggerEffect(bombPos.x, bombPos.y, ITEM_COLORS.bomb, { count: 40, speed: 7, life: 60 }); steppingPlayer.takeDamage(ball, trapOwner === 'neutral' ? null : trapOwner); return true; } return false; },
            shield: (ball) => { if (ball.controller.armor.includes('shield')) return false; ball.controller.armor.push('shield'); updateLivesUI(); return true; },
            reflectiveCloak: (ball) => { ball.controller.applyEffect('reflectiveCloak', 10000); return true; },
            snare: (ball) => { const opponent = players.find(p => p !== ball.controller); if (opponent) { const radius = canvas.width / 40; const pos = getRandomPosition(radius); items['snare_trap'] = { item: new Item(pos.x, pos.y, radius, 'snare_trap', ball.controller, 5000) }; } return true; },
            snare_trap: (ball, itemData) => { const trapOwner = itemData.item.owner; const steppingPlayer = ball.controller; let trigger = false; if (trapOwner === 'neutral' || steppingPlayer !== trapOwner) { trigger = true; } if (trigger) { steppingPlayer.applyEffect('snare', 3000); return true; } return false; },
            grow: (ball) => { const opponent = players.find(p => p !== ball.controller); if (opponent) opponent.applyEffect('size', 10000, 'grow'); return true; },
            shrink: (ball) => { ball.controller.applyEffect('size', 10000, 'shrink'); setTimeout(() => { const itemData = items['shrink']; if (itemData) { const respawnTime = itemData.currentRespawn; itemData.cooldownEndTime = Date.now() + respawnTime; itemSpawnTimeouts.push(setTimeout(() => spawnItem('shrink'), respawnTime)); } }, 10000); return true; },
            speedBoost: (ball) => { ball.controller.applyEffect('speed', 5000, 1.5); setTimeout(() => { const itemData = items['speedBoost']; if (itemData) { const respawnTime = itemData.currentRespawn; itemData.cooldownEndTime = Date.now() + respawnTime; itemSpawnTimeouts.push(setTimeout(() => spawnItem('speedBoost'), respawnTime)); } }, 5000); return true; },
            slow: (ball) => { const opponent = players.find(p => p !== ball.controller); if (opponent) opponent.applyEffect('speed', 5000, 0.5); return true; },
            rain: (ball) => { const rainRadius = (ball.baseRadius) * 5; const pos = getRandomPosition(rainRadius); activeRainZone = new RainZone(pos.x, pos.y, rainRadius, ball.controller); return true; },
            invisibility: (ball) => { const duration = 3000; ball.controller.invincibleUntil = Date.now() + duration; ball.controller.timedEffects.invisibility = { endTime: Date.now() + duration, duration }; setTimeout(() => { delete ball.controller.timedEffects.invisibility; const itemData = items['invisibility']; if (itemData) { const respawnTime = itemData.currentRespawn; itemData.cooldownEndTime = Date.now() + respawnTime; itemSpawnTimeouts.push(setTimeout(() => spawnItem('invisibility'), respawnTime)); } }, duration); return true; },
            wallSpikes: (ball) => { const sides = ['top', 'right', 'bottom', 'left']; activeSpikeWall = { side: sides[Math.floor(Math.random() * 4)], owner: ball.controller }; return true; },
            diagonalWall: (ball) => { if (activeDiagonalWall) return false; activeDiagonalWall = new DiagonalWall(); return true; },
            clone: (ball) => { ball.controller.addBall(); return true; },
            cannotEat: (ball) => { const opponent = players.find(p => p !== ball.controller); if (opponent) opponent.applyEffect('cannotEat', 5000); return true; },
            laserGun: (ball) => { if(activeLaser) return false; const owner = ball.controller; const opponent = players.find(p => p !== owner); if (!opponent || opponent.balls.length === 0) return false; const targetBall = opponent.balls[0]; const dir = { x: targetBall.x - ball.x, y: targetBall.y - ball.y }; const mag = Math.hypot(dir.x, dir.y); if (mag > 0) { dir.x /= mag; dir.y /= mag; } else { dir.x = Math.random() - 0.5; dir.y = Math.random() - 0.5; } activeLaser = new Laser({ x: ball.x, y: ball.y }, dir, owner); return true; },
             thieuThan: (ball) => { const player = ball.controller; if (player.hasThieuThanBuff) return false; player.hasThieuThanBuff = true; updatePlayerStatusUI(); return true; },
			homingMissile: (ball) => { if(activeMissile) return false; const owner = ball.controller; const opponent = players.find(p => p !== owner); if (opponent) { activeMissile = new HomingMissile(owner, opponent); } return true;}
        };

        function handleItemPickup(ball, type) { 
            const itemData = items[type]; 
            if (!itemData || !itemData.item || (ball.controller.cannotEatUntil && Date.now() < ball.controller.cannotEatUntil)) return; 
            const itemOwner = itemData.item.owner; 
            const configType = ITEM_CONFIG[type] ? ITEM_CONFIG[type].type : 'trap';
            if (configType === 'buff' && itemOwner !== 'neutral' && itemOwner !== ball.controller) return; 
            if ((configType === 'debuff' || configType === 'map_effect') && itemOwner !== 'neutral' && itemOwner !== ball.controller) return; 
            const logic = ITEM_PICKUP_LOGIC[type]; 
            if (!logic) return; 
            const pickupSuccessful = logic(ball, itemData); 
            if (pickupSuccessful) { 
                soundManager.playPickup(type);
                triggerEffect(ball.x, ball.y, ITEM_COLORS[type], { count: 15, speed: 2, life: 25 }); 
                const respawnTime = itemData.currentRespawn; 
                itemData.item = null; 
				
                const cooldownOnExpireItems = ['shield', 'weapon', 'reflectiveCloak', 'shrink', 'speedBoost', 'invisibility', 'thieuThan'];
                if (respawnTime && !cooldownOnExpireItems.includes(type)) {
                    itemData.cooldownEndTime = Date.now() + respawnTime; 
                    itemSpawnTimeouts.push(setTimeout(() => spawnItem(type), respawnTime)); 
                }
                if ((type === 'bomb_trap' || type === 'snare_trap') && ball.controller.lives <= 0) { triggerDeath(ball.controller); }
            } 
            updatePlayerStatusUI(); 
        }
        
        function updateCooldownUI() {
            const neutralDiv = document.getElementById('neutral-cooldown-timers'); const p1Div = document.getElementById('player1-cooldown-timers'); const p2Div = document.getElementById('player2-cooldown-timers');
            if (!neutralDiv || !p1Div || !p2Div) return;
            let neutralHtml = '', p1Html = '', p2Html = '';
            const createTimerCircle = (type) => { const itemData = items[type]; if (!itemData || !ITEM_CONFIG[type]) return ''; const radius = 16; const circumference = 2 * Math.PI * radius; const endTime = itemData.cooldownEndTime; const baseTime = (itemData.initialCooldownUsed) ? itemData.currentRespawn : INITIAL_SPAWN_TIME; let textContent = ''; let strokeDashoffset = circumference; const ownerColor = itemData.owner === players[0] ? '#3b82f6' : (itemData.owner === players[1] ? '#ef4444' : '#a0aec0'); if (endTime && Date.now() < endTime) { const remaining = endTime - Date.now(); const progress = Math.max(0, remaining / baseTime); strokeDashoffset = circumference * progress; textContent = Math.ceil(remaining / 1000); } else { strokeDashoffset = 0; } return ` <div class="cooldown-circle"> <svg class="w-full h-full"> <circle cx="18" cy="18" r="${radius}" stroke="#4a5568" stroke-width="3" fill="none" /> <circle cx="18" cy="18" r="${radius}" stroke="${ownerColor}" stroke-width="3" fill="none" stroke-dasharray="${circumference}" stroke-dashoffset="${strokeDashoffset}" style="transition: stroke-dashoffset 0.25s linear;" /> </svg> <div class="icon">${!textContent ? ICONS[type].replace('h-8 w-8', 'h-5 w-5') : ''}</div> <div class="text">${textContent}</div> </div> `; };
            Object.keys(items).forEach(type => { const itemData = items[type]; if (!itemData || !ITEM_CONFIG[type]) return; const circleHtml = createTimerCircle(type); if (itemData.owner === 'neutral') { neutralHtml += circleHtml; } else if (players[0] && itemData.owner === players[0]) { p1Html += circleHtml; } else if (players[1] && itemData.owner === players[1]) { p2Html += circleHtml; } });
            neutralDiv.innerHTML = neutralHtml; p1Div.innerHTML = p1Html; p2Div.innerHTML = p2Html;
        }
        function calculateCurrentMultiplier(remainingTime) { const stage2Start = 45000; const stage3Start = 15000; const stage4Start = 5000; if (remainingTime > stage2Start) { const progress = (TOTAL_GAME_TIME - remainingTime) / (TOTAL_GAME_TIME - stage2Start); return 1 + progress; } else if (remainingTime > stage3Start) { const progress = (stage2Start - remainingTime) / (stage2Start - stage3Start); return 2 + progress; } else if (remainingTime > stage4Start) { const progress = (stage3Start - remainingTime) / (stage3Start - stage4Start); return 3 + progress; } else { return 4; } }
        
        function drawTimer() { const remaining = Math.max(0, gameEndTime - Date.now()); const remainingPercent = remaining / TOTAL_GAME_TIME; if (remaining > 0) { let color = 'rgba(255, 255, 255, 0.08)'; if(remaining <= 5000) color = 'rgba(239, 68, 68, 0.2)'; else if(remaining <= 15000) color = 'rgba(239, 68, 68, 0.15)'; else if(remaining <= 45000) color = 'rgba(239, 68, 68, 0.1)'; ctx.fillStyle = color; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#2d3748'; const wipeHeight = canvas.height * (1 - remainingPercent); ctx.fillRect(0, 0, canvas.width, wipeHeight); } const seconds = Math.ceil(remaining / 1000); ctx.font = `bold ${canvas.width / 4}px Inter, sans-serif`; ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(seconds, canvas.width / 2, canvas.height / 2); }
        function drawSpikeWall() { if (!activeSpikeWall) return; ctx.fillStyle = ITEM_COLORS.wallSpikes; const spikeSize = canvas.width / 40; const numSpikes = Math.floor(canvas.width / spikeSize); for (let i = 0; i < numSpikes; i++) { const pos = i * spikeSize + spikeSize / 2; ctx.beginPath(); if (activeSpikeWall.side === 'top') { ctx.moveTo(pos - spikeSize / 2, 0); ctx.lineTo(pos, spikeSize); ctx.lineTo(pos + spikeSize / 2, 0); } else if (activeSpikeWall.side === 'bottom') { ctx.moveTo(pos - spikeSize / 2, canvas.height); ctx.lineTo(pos, canvas.height - spikeSize); ctx.lineTo(pos + spikeSize / 2, canvas.height); } else if (activeSpikeWall.side === 'left') { ctx.moveTo(0, pos - spikeSize / 2); ctx.lineTo(spikeSize, pos); ctx.lineTo(0, pos + spikeSize / 2); } else if (activeSpikeWall.side === 'right') { ctx.moveTo(canvas.width, pos - spikeSize / 2); ctx.lineTo(canvas.width - spikeSize, pos); ctx.lineTo(canvas.width, pos + spikeSize / 2); } ctx.fill(); } }

        function gameLoop() {
            if (!animationFrameId) return;
            const remaining = Math.max(0, gameEndTime - Date.now());
            const currentMultiplier = calculateCurrentMultiplier(remaining);
            for (const type in items) { if(items[type] && items[type].baseRespawn) items[type].currentRespawn = items[type].baseRespawn / currentMultiplier; }
            getAllPlayerBalls().forEach(b => { b.speed = b.baseSpeed * currentMultiplier * b.controller.speedMultiplier; updatePlayerVelocity(b); });
            if (remaining <= 0) { endGame(true); return; }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawTimer(); drawSpikeWall();
            if(activeDiagonalWall) activeDiagonalWall.draw();
            if(activeRainZone) { activeRainZone.draw(); activeRainZone.update(); }
            if(activeLaser) { activeLaser.draw(); const opponent = players.find(p => p !== activeLaser.owner); if (opponent) { opponent.balls.forEach(ball => { if (activeLaser && activeLaser.checkCollision(ball)) { opponent.takeDamage(ball, activeLaser.owner); activeLaser = null; } }); } if (activeLaser && Date.now() > activeLaser.endTime) activeLaser = null; }
            if(activeMissile) { activeMissile.draw(); activeMissile.update(); }

            players.forEach(player => { const hasWeapon = player.armor.includes('weapon'); if (player.hasThieuThanBuff && hasWeapon && !player.isThieuThanActive) { player.isThieuThanActive = true; updatePlayerStatusUI(); } if (player.isThieuThanActive && !hasWeapon) { player.isThieuThanActive = false; /* Don't deactivate buff here */ updatePlayerStatusUI(); } });

            getAllPlayerBalls().forEach(ball => {
                const player = ball.controller;
                if (player.isThieuThanActive) {
                    const opponent = players.find(p => p !== player);
                    if (opponent && opponent.balls.length > 0) {
                        const target = opponent.balls[0]; const dist = Math.hypot(target.x - ball.x, target.y - ball.y); const maxDistForScaling = canvas.width * 0.75; const proximity = Math.max(0, 1 - (dist / maxDistForScaling)); const speedMultiplier = 1 + (proximity * 0.25); const angle = Math.atan2(target.y - ball.y, target.x - ball.x);
                        ball.dx = Math.cos(angle) * ball.speed * speedMultiplier; ball.dy = Math.sin(angle) * ball.speed * speedMultiplier;
                    }
                }
                ball.update();
                // Update speed trail
                if (player.speedMultiplier > 1) { player.trail.push({ x: ball.x, y: ball.y }); if (player.trail.length > 15) { player.trail.shift(); } } 
                else if (player.trail.length > 0) { player.trail.shift(); }
            });
            
            getAllPlayerBalls().forEach(handleWallCollisions);
            getAllPlayerBalls().forEach(handleDiagonalWallCollision);
            handleCollisions();
            getAllPlayerBalls().forEach(ball => ball.draw());
            for (const type in items) if(items[type] && items[type].item) items[type].item.draw();
            particles.forEach((p, index) => { p.update(); p.draw(); if (p.life <= 0) particles.splice(index, 1); });
            
            updateCooldownUI(); 
            updatePlayerStatusUI();
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        let effectLoopId = null;
        function pauseGameForEffect({duration, shake = 0}) { if (!animationFrameId) return; cancelAnimationFrame(animationFrameId); animationFrameId = null; let startTime = Date.now(); let shakeX = 0, shakeY = 0; function effectLoop() { const elapsed = Date.now() - startTime; if(elapsed > duration) { canvas.style.transform = ''; animationFrameId = requestAnimationFrame(gameLoop); return; } if (shake > 0) { shakeX = (Math.random() - 0.5) * shake * (1 - elapsed/duration); shakeY = (Math.random() - 0.5) * shake * (1 - elapsed/duration); canvas.style.transform = `translate(${shakeX}px, ${shakeY}px)`; } effectLoopId = requestAnimationFrame(effectLoop); } effectLoop(); }
        function triggerDeath(deadPlayerController) { const winner = players.find(p => p !== deadPlayerController); const lastBall = deadPlayerController.balls[0] || {x: canvas.width / 2, y: canvas.height/2}; triggerEffect(lastBall.x, lastBall.y, deadPlayerController.color, { count: 50, speed: 8, friction: 0.98, life: 80 }); endGame(false, winner); }
        function stopGame() { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } if (effectLoopId) { cancelAnimationFrame(effectLoopId); effectLoopId = null; } itemSpawnTimeouts.forEach(clearTimeout); itemSpawnTimeouts = []; }

        function endGame(isTimeUp = false, winnerPlayer = null) {
            releaseWakeLock();
            stopGame();
            gameOverScreen.classList.add('visible'); 
            document.getElementById('top-ui').classList.add('invisible'); document.getElementById('bottom-ui').classList.add('invisible');
            
            let winner = ''; const p1 = players.find(p => p.name === 'Người chơi 1'); const p2 = players.find(p => p.name === 'Người chơi 2'); const p1Lives = p1 ? Math.max(0, p1.lives) : 0; const p2Lives = p2 ? Math.max(0, p2.lives) : 0; const p1Score = p1 ? p1.score : 0; const p2Score = p2 ? p2.score : 0;

            if (winnerPlayer) { winner = winnerPlayer.name === 'Người chơi 1' ? 'p1' : 'p2'; } 
            else if (isTimeUp) { if (p1Score > p2Score) { winner = 'p1'; } else if (p2Score > p1Score) { winner = 'p2'; } else { if (p1Lives > p2Lives) winner = 'p1'; else if (p2Lives > p1Lives) winner = 'p2'; else winner = 'draw'; } }
           
            winnerText.className = 'text-4xl font-bold mb-4';
            if (winner === 'p1') { winnerText.textContent = `Người chơi 1 chiến thắng!`; winnerText.classList.add('text-blue-500'); soundManager.playGameOver(true); } 
            else if (winner === 'p2') { winnerText.textContent = `Người chơi 2 chiến thắng!`; winnerText.classList.add('text-red-500'); soundManager.playGameOver(true); } 
            else { winnerText.textContent = `Hòa!`; soundManager.playGameOver(false); }
            
            document.getElementById('results-details').innerHTML = `<div class="flex justify-around items-center text-center"> <div class="p-4 bg-gray-800 rounded-lg w-2/5"> <p class="font-bold text-blue-500">Người chơi 1</p> <p>Điểm: <span class="font-bold text-2xl">${p1Score}</span></p> <p class="text-sm">Mạng còn lại: <span class="font-bold">${p1Lives}</span></p> </div> <div class="text-2xl font-bold px-2">VS</div> <div class="p-4 bg-gray-800 rounded-lg w-2/5"> <p class="font-bold text-red-500">Người chơi 2</p> <p>Điểm: <span class="font-bold text-2xl">${p2Score}</span></p> <p class="text-sm">Mạng còn lại: <span class="font-bold">${p2Lives}</span></p> </div> </div>`;
        }
        
        function init() {
			releaseWakeLock();
            stopGame(); setCanvasSize(); players = []; items = {};
            startScreen.classList.add('visible'); banPickScreen.classList.remove('visible'); gameOverScreen.classList.remove('visible');
            document.getElementById('top-ui').classList.add('invisible'); document.getElementById('bottom-ui').classList.add('invisible');
            winnerText.textContent = ''; winnerText.className = 'text-4xl font-bold mb-4';
            particles = []; activeRainZone = null; activeSpikeWall = null; activeDiagonalWall = null; activeLaser = null; activeMissile = null;
            ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.font = `bold ${canvas.width / 10}px Inter, sans-serif`; ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("Sẵn Sàng...", canvas.width / 2, canvas.height / 2);
        }

        function showBanPickPhase() {
            startScreen.classList.remove('visible'); banPickScreen.classList.add('visible');
            banPickState = { currentIndex: 0, p1Bans: [], p2Bans: [], p1Picks: [], p2Picks: [], selectionCandidate: null };
            
            const bannableItems = Object.keys(ITEM_CONFIG).filter(type => ITEM_CONFIG[type].type !== 'neutral');
            const itemGroups = { buff: [], debuff: [], map_effect: [] };
            bannableItems.forEach(type => { const itemType = ITEM_CONFIG[type].type; if (itemGroups[itemType]) { itemGroups[itemType].push(type); } });
            const sortedItems = [...itemGroups.buff.sort(), ...itemGroups.debuff.sort(), ...itemGroups.map_effect.sort()];

            const grid = document.getElementById('ban-pick-grid'); grid.innerHTML = '';
            sortedItems.forEach(type => {
                const itemDiv = document.createElement('div'); itemDiv.id = `bp-item-${type}`; itemDiv.className = 'ban-pick-item selectable';
                let typeIcon = '';
                if(ITEM_CONFIG[type].type === 'buff') typeIcon = `<div class="type-icon text-green-400">▲</div>`
                else if (ITEM_CONFIG[type].type === 'debuff') typeIcon = `<div class="type-icon text-red-400">▼</div>`
                else if (ITEM_CONFIG[type].type === 'map_effect') typeIcon = `<div class="type-icon text-yellow-400">♦</div>`
                itemDiv.innerHTML = `${ICONS[type]}${typeIcon}<div class="overlay">/</div>`;
                const isTouchDevice = 'ontouchstart' in window;
                if (isTouchDevice) { itemDiv.addEventListener('click', () => handleBanPickSelection(type)); } 
                else { itemDiv.onclick = () => handleBanPickSelection(type); itemDiv.onmouseenter = (e) => showTooltip(e, type); itemDiv.onmouseleave = hideTooltip; }
                grid.appendChild(itemDiv);
            });
            updateBanPickUI();
        }
        
        function showTooltip(event, type) { const item = ITEM_CONFIG[type]; let statsHTML = `<p class="text-gray-400 text-sm mt-1">Hồi chiêu: ${item.baseRespawn / 1000}s</p>`; if (item.stats && Object.keys(item.stats).length > 0) { statsHTML += `<div class="mt-2 border-t border-gray-600 pt-2">`; for (const [key, value] of Object.entries(item.stats)) { statsHTML += `<p class="text-sm"><span class="font-semibold text-gray-300">${key}:</span> ${value}</p>`; } statsHTML += `</div>`; } tooltip.innerHTML = `<h4 class="font-bold mb-1">${item.name}</h4><p class="text-gray-400">${item.desc}</p>${statsHTML}`; tooltip.style.opacity = '1'; const tooltipRect = tooltip.getBoundingClientRect(); const margin = 15; let left = event.clientX + margin; let top = event.clientY + margin; if (left + tooltipRect.width > window.innerWidth) { left = event.clientX - tooltipRect.width - margin; } if (top + tooltipRect.height > window.innerHeight) { top = event.clientY - tooltipRect.height - margin; } if (left < 0) left = margin; if (top < 0) top = margin; tooltip.style.left = `${left}px`; tooltip.style.top = `${top}px`; }
        function hideTooltip() { tooltip.style.opacity = '0'; }
        
        function updateBanPickUI() { const title = document.getElementById('ban-pick-title'); const mobileInfo = document.getElementById('ban-pick-info-mobile'); const p1PicksDiv = document.getElementById('p1-picks'); const p2PicksDiv = document.getElementById('p2-picks'); const p1BansDiv = document.getElementById('p1-bans'); const p2BansDiv = document.getElementById('p2-bans'); document.querySelectorAll('.pulsing-slot').forEach(el => el.classList.remove('pulsing-slot')); document.querySelectorAll('.border-yellow-400').forEach(el => el.classList.remove('border-yellow-400')); const renderSlots = (container, items, maxSlots, isBan = false) => { container.innerHTML = ''; for (let i = 0; i < maxSlots; i++) { let content = ''; if (items[i]) { content = ICONS[items[i]].replace('h-8 w-8', 'h-full w-full'); if (isBan) { content += '<div class="absolute inset-0 bg-red-800 bg-opacity-70 flex items-center justify-center text-white text-3xl font-bold">/</div>'; } } const banClass = isBan ? 'p-1 aspect-square bg-gray-900 border-2 border-gray-700 rounded flex justify-center items-center relative' : 'p-1 aspect-square bg-gray-900 border-2 border-dashed border-gray-700 rounded flex justify-center items-center'; container.innerHTML += `<div class="${banClass}">${content}</div>`; } }; renderSlots(p1BansDiv, banPickState.p1Bans, 2, true); renderSlots(p2BansDiv, banPickState.p2Bans, 2, true); renderSlots(p1PicksDiv, banPickState.p1Picks, 3); renderSlots(p2PicksDiv, banPickState.p2Picks, 3); const currentStep = banPickSequence[banPickState.currentIndex]; if (currentStep) { const isP1 = currentStep.player === 1; const phaseText = currentStep.phase === 'ban' ? 'Cấm' : 'Chọn'; title.className = 'text-2xl md:text-3xl font-bold'; title.classList.add(isP1 ? 'text-blue-500' : 'text-red-500'); title.textContent = `Người chơi ${currentStep.player} - ${phaseText}`; const container = currentStep.phase === 'ban' ? (isP1 ? p1BansDiv : p2BansDiv) : (isP1 ? p1PicksDiv : p2PicksDiv); const itemsList = currentStep.phase === 'ban' ? (isP1 ? banPickState.p1Bans : banPickState.p2Bans) : (isP1 ? banPickState.p1Picks : banPickState.p2Picks); const maxItems = currentStep.phase === 'ban' ? 2 : 3; if (itemsList.length < maxItems) { const slot = container.children[itemsList.length]; if(slot) slot.classList.add('pulsing-slot'); } } const banned = [...banPickState.p1Bans, ...banPickState.p2Bans]; document.querySelectorAll('.ban-pick-item').forEach(el => { const type = el.id.replace('bp-item-', ''); el.classList.remove('banned', 'picked-p1', 'picked-p2', 'selectable', 'opacity-50'); if(banPickState.selectionCandidate === type) el.classList.add('border-yellow-400'); if (banned.includes(type)) el.classList.add('banned'); else if (banPickState.p1Picks.includes(type)) el.classList.add('picked-p1'); else if (banPickState.p2Picks.includes(type)) el.classList.add('picked-p2'); else el.classList.add('selectable'); }); }
        
        function handleBanPickSelection(type) {
            const currentStep = banPickSequence[banPickState.currentIndex]; if (!currentStep) return; const banned = [...banPickState.p1Bans, ...banPickState.p2Bans]; const picked = [...banPickState.p1Picks, ...banPickState.p2Picks]; if (banned.includes(type) || picked.includes(type)) return;
            soundManager.playSelect();
            if (banPickState.selectionCandidate === type) { if (currentStep.phase === 'ban') { if (currentStep.player === 1) banPickState.p1Bans.push(type); else banPickState.p2Bans.push(type); } else { if (currentStep.player === 1) banPickState.p1Picks.push(type); else banPickState.p2Picks.push(type); } banPickState.currentIndex++; banPickState.selectionCandidate = null; if (banPickState.currentIndex >= banPickSequence.length) { finalizeSelectionsAndStart(); } else { updateBanPickUI(); } } else { banPickState.selectionCandidate = type; updateBanPickUI(); }
        }
        
        function finalizeSelectionsAndStart() { banPickScreen.classList.remove('visible'); const allItems = Object.keys(ITEM_CONFIG); const banned = [...banPickState.p1Bans, ...banPickState.p2Bans]; const picked = [...banPickState.p1Picks, ...banPickState.p2Picks]; let availableItems = allItems.filter(type => !banned.includes(type) && !picked.includes(type) && ITEM_CONFIG[type].type !== 'neutral'); let commonItems = []; while(commonItems.length < 2 && availableItems.length > 0) { const randomIndex = Math.floor(Math.random() * availableItems.length); commonItems.push(availableItems.splice(randomIndex, 1)[0]); } const activeItemTypes = {}; ['health', 'weapon', 'shield'].forEach(type => activeItemTypes[type] = { owner: 'neutral' }); banPickState.p1Picks.forEach(type => activeItemTypes[type] = { owner: 'p1' }); banPickState.p2Picks.forEach(type => activeItemTypes[type] = { owner: 'p2' }); commonItems.forEach(type => activeItemTypes[type] = { owner: 'neutral' }); startCountdown(activeItemTypes); }

        function startCountdown(activeItemTypes) {
            const countdownScreen = document.getElementById('countdown-screen'); const countdownText = document.getElementById('countdown-text');
            countdownScreen.classList.add('visible'); setupGame(activeItemTypes); let count = 3; countdownText.textContent = count;
            const interval = setInterval(() => {
                count--;
                if (count > 0) { countdownText.textContent = count; soundManager.playClick(); } 
                else if (count === 0) { countdownText.textContent = "Bắt Đầu!"; countdownText.classList.remove('text-9xl'); countdownText.classList.add('text-7xl'); soundManager.playStart(); } 
                else { clearInterval(interval); countdownScreen.classList.remove('visible'); countdownText.classList.add('text-9xl'); countdownText.classList.remove('text-7xl'); startGame(); }
            }, 1000);
        }

        function setupGame(activeItemTypes) {
            document.getElementById('top-ui').classList.remove('invisible'); document.getElementById('bottom-ui').classList.remove('invisible');
            players = []; const playerRadius = (canvas.width / 25) * 1.4 * 0.7; const centerX = canvas.width / 2; const centerY = canvas.height / 2; const p1Spawn = { x: centerX + centerX / 2, y: centerY / 2 }; const p2Spawn = { x: centerX / 2, y: centerY + centerY / 2 };
            const p1 = new PlayerController('Người chơi 1', '#3b82f6', new PlayerBall(p1Spawn.x, p1Spawn.y, playerRadius)); p1.balls[0].controller = p1;
            const p2 = new PlayerController('Người chơi 2', '#ef4444', new PlayerBall(p2Spawn.x, p2Spawn.y, playerRadius)); p2.balls[0].controller = p2;
            players.push(p1, p2); items = {};
            for (const type in activeItemTypes) { let owner = 'neutral'; if(activeItemTypes[type].owner === 'p1') owner = p1; if(activeItemTypes[type].owner === 'p2') owner = p2; items[type] = { ...ITEM_CONFIG[type], owner: owner, item: null, cooldownEndTime: Date.now() + INITIAL_SPAWN_TIME, initialCooldownUsed: false }; }
            updateLivesUI(); updatePlayerStatusUI(); updateCooldownUI(); updateScoreUI();
            ctx.clearRect(0, 0, canvas.width, canvas.height); getAllPlayerBalls().forEach(ball => ball.draw());
        }

        function startGame() {
			requestWakeLock();
            gameEndTime = Date.now() + TOTAL_GAME_TIME;
            for (const type in items) { itemSpawnTimeouts.push(setTimeout(() => { spawnItem(type); items[type].initialCooldownUsed = true; }, INITIAL_SPAWN_TIME)); }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        window.addEventListener('resize', init);
        startButton.addEventListener('click', async () => {
            if (typeof Tone !== 'undefined' && !soundManager.isInitialized) {
                try {
                    await Tone.start();
                    soundManager.init();
                    console.log("Audio context started.");
                } catch (e) {
                    console.error("Could not start audio context:", e);
                }
            }
            soundManager.playClick();
            showBanPickPhase();
        });
        restartButton.addEventListener('click', () => { soundManager.playClick(); init(); });
        document.addEventListener('visibilitychange', async () => { if (document.visibilityState === 'visible' && animationFrameId) { await requestWakeLock(); } });
        
        init();
    </script>

</body>
</html>

