<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Đấu Trường Sinh Tử</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');

        html, body {
            margin: 0; padding: 0; overflow: hidden;
            height: 100dvh; width: 100dvw;
            background-color: #0a0a0a;
            font-family: 'Inter', sans-serif;
        }
        #game-container {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            height: 100%; width: 100%; padding: 1rem; box-sizing: border-box;
            position: relative;
        }
        canvas {
            background-color: #2d3748; border: 2px solid #a0aec0; border-radius: 0.5rem;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            max-width: 100%; max-height: 100%; aspect-ratio: 1 / 1;
            transition: transform 0.1s ease-out;
        }
        .screen-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(10, 10, 10, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
            backdrop-filter: blur(8px);
        }
        .dialog-card {
            background-color: #1a1a1d;
            padding: 2.5rem;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.3), 0 10px 10px -5px rgba(0,0,0,0.2);
            width: clamp(300px, 90vw, 1000px);
        }
        .material-button {
            text-transform: uppercase;
            letter-spacing: 1.25px;
            font-weight: 500;
            box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14), 0 3px 1px -2px rgba(0,0,0,0.12), 0 1px 5px 0 rgba(0,0,0,0.2);
            transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease;
        }
        .material-button:active {
            box-shadow: 0 4px 5px 0 rgba(0,0,0,0.14), 0 1px 10px 0 rgba(0,0,0,0.12), 0 2px 4px -1px rgba(0,0,0,0.2);
            transform: translateY(1px);
        }
        .cooldown-circle {
            position: relative; width: 36px; height: 36px;
        }
        .cooldown-circle svg {
            transform: rotate(-90deg);
        }
        .cooldown-circle .icon {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
        }
        .cooldown-circle .text {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 13px; font-weight: bold;
        }
        .ban-pick-item {
            position: relative;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
        }
        .ban-pick-item.selectable:hover {
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }
        .ban-pick-item .overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.7);
            display: flex; justify-content: center; align-items: center;
            font-size: 2rem;
            color: #ef4444;
            border-radius: 8px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        .ban-pick-item.banned .overlay { opacity: 1; }
        .ban-pick-item.picked-p1 { border-color: #3b82f6; }
        .ban-pick-item.picked-p2 { border-color: #ef4444; }
        .ban-pick-item .type-icon {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #tooltip {
            position: fixed;
            background-color: #1a1a1d;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 1rem;
            max-width: 250px;
            z-index: 99;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform-origin: top left;
        }
        .animate-pulse-fast { animation: pulse 0.5s cubic-bezier(0.4, 0.6, 1) infinite; }
        @keyframes pulse { 50% { opacity: .5; } }

        @keyframes pulse-border {
            50% { border-color: rgba(255, 255, 255, 0.6); }
        }
        .pulsing-slot {
            animation: pulse-border 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @media (max-width: 768px) {
             #game-container {
			  display: flex; flex-direction: column; justify-content: center; align-items: center;
                padding: 0.5rem;
               
            }
            #game-ui {
                flex-shrink: 0;
            }
            #ban-pick-screen .dialog-card {
                padding: 1rem;
                display: flex;
                flex-direction: column;
                max-height: 90vh;
            }
            #ban-pick-screen > div > div {
                flex-direction: column;
            }
            #ban-pick-screen .w-1\/4, #ban-pick-screen .w-1\/2 {
                width: 100%;
                padding: 0;
                margin-bottom: 1rem;
            }
            #ban-pick-screen .text-left, #ban-pick-screen .text-right {
                text-align: center;
            }
             #p1-bans, #p1-picks, #p2-bans, #p2-picks {
                justify-content: center;
            }
             #ban-pick-grid-container {
                /* Height of 3 items (approx 65px) + 2 gaps (16px) */
                max-height: 21vh; 
                overflow-y: auto;
                scrollbar-width: thin;
                scrollbar-color: #4a5568 #1a1a1d;
             }
            #ban-pick-grid-container::-webkit-scrollbar { width: 8px; }
            #ban-pick-grid-container::-webkit-scrollbar-track { background: #1a1a1d; }
            #ban-pick-grid-container::-webkit-scrollbar-thumb {
                background-color: #4a5568;
                border-radius: 4px;
                border: 2px solid #1a1a1d;
            }
        }
    </style>
</head>
<body class="text-white">

    <div id="game-container">
      <div id="top-ui" class="w-full flex flex-col items-center invisible px-2 py-2 md:py-0">
    <div id="player1-info" class="w-full max-w-lg mb-2">
    <div class="flex justify-between items-center">
        <h2 class="font-bold text-lg text-blue-500 flex items-center">
            <span>Người chơi 1</span>
            <span id="player1-status-icons" class="flex items-center ml-2 space-x-1"></span>
        </h2>
        <span id="player1-score" class="font-bold text-2xl text-white bg-black/20 px-3 rounded-md">0</span>
    </div>
    <div id="player1-lives" class="flex items-center space-x-1 mt-1"></div>
</div>
    <div id="player1-cooldown-timers" class="w-full max-w-lg flex justify-center flex-wrap gap-x-4 gap-y-1 mb-1 text-sm text-gray-300"></div>
<div id="player1-cooldown-timers" class="w-full max-w-lg flex justify-center flex-wrap gap-x-4 gap-y-1 mb-1 text-sm text-gray-300"></div>
        <div id="neutral-cooldown-timers" class="w-full max-w-lg flex justify-center flex-wrap gap-x-4 gap-y-1 text-sm text-gray-300"></div>
    </div>

   <canvas id="gameCanvas" class="my-2"></canvas>
<div id="countdown-screen" class="screen-overlay hidden">
    <h1 id="countdown-text" class="text-9xl font-bold text-white" style="text-shadow: 0 0 20px rgba(0,0,0,0.5);"></h1>
</div>
<div id="bottom-ui" class="w-full flex flex-col items-center invisible px-2 py-2 md:py-0">
   <div id="player2-info" class="w-full max-w-lg mt-2">
    <div class="flex justify-between items-center">
        <h2 class="font-bold text-lg text-red-500 flex items-center">
            <span>Người chơi 2</span>
            <span id="player2-status-icons" class="flex items-center ml-2 space-x-1"></span>
        </h2>
        <span id="player2-score" class="font-bold text-2xl text-white bg-black/20 px-3 rounded-md">0</span>
    </div>
    <div id="player2-lives" class="flex items-center space-x-1 mt-1"></div>
</div>
    <div id="player2-cooldown-timers" class="w-full max-w-lg flex justify-center flex-wrap gap-x-4 gap-y-1 mt-2 text-sm text-gray-300"></div>
</div>

        <div id="start-screen" class="screen-overlay">
            <div class="dialog-card">
                <h1 class="text-5xl font-bold mb-8 text-gray-100">Đấu Trường Sinh Tử</h1>
                <button id="start-button" class="material-button bg-blue-600 hover:bg-blue-700 text-white py-4 px-8 rounded-lg text-2xl">Bắt đầu</button>
            </div>
        </div>

        <div id="ban-pick-screen" class="screen-overlay hidden">
            <div class="dialog-card">
                <div class="flex justify-between w-full">
                    <!-- Player 1 Side -->
                    <div class="w-1/4 text-left">
                        <h3 class="text-lg font-bold text-blue-500">CẤM</h3>
                        <div id="p1-bans" class="flex space-x-2 mt-2 h-12"></div>
                        <h3 class="text-lg font-bold text-blue-500 mt-4">CHỌN</h3>
                        <div id="p1-picks" class="flex space-x-2 mt-2 h-12"></div>
                    </div>
                    
                    <!-- Center Grid -->
                    <div class="w-1/2 px-4 flex flex-col">
                        <div id="ban-pick-header-container" class="text-center mb-4 flex flex-col justify-center min-h-[112px] md:min-h-0">
                            <h2 id="ban-pick-title" class="text-2xl md:text-3xl font-bold text-gray-100"></h2>
                             <div id="ban-pick-info-mobile" class="hidden md:hidden p-2 bg-gray-900 rounded-lg text-left"></div>
                        </div>
                        <div id="ban-pick-grid-container" class="flex-grow">
                             <div id="ban-pick-grid" class="grid grid-cols-4 gap-4"></div>
                        </div>
                    </div>
        
                    <!-- Player 2 Side -->
                    <div class="w-1/4 text-right">
                        <h3 class="text-lg font-bold text-red-500">CẤM</h3>
                        <div id="p2-bans" class="flex space-x-2 mt-2 justify-end h-12"></div>
                        <h3 class="text-lg font-bold text-red-500 mt-4">CHỌN</h3>
                        <div id="p2-picks" class="flex space-x-2 mt-2 justify-end h-12"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="game-over-screen" class="screen-overlay hidden">
             <div class="dialog-card">
                <h2 id="winner-text" class="text-4xl font-bold mb-4"></h2>
                <div id="results-details" class="my-6 text-lg"></div>
                <button id="restart-button" class="material-button mt-4 bg-green-600 hover:bg-green-700 text-white py-3 px-6 rounded-lg text-xl">Chơi lại</button>
            </div>
        </div>
    </div>
    <div id="tooltip"></div>

    <script>
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const banPickScreen = document.getElementById('ban-pick-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const winnerText = document.getElementById('winner-text');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const gameUI = document.getElementById('game-ui');
        const tooltip = document.getElementById('tooltip');
let wakeLockSentinel = null; 
        const ICONS = {
            weapon: `<svg class="h-8 w-8 text-yellow-400" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l2.5 6.5L21 9l-5 4.5L17 21l-5-3.5L7 21l1-7.5L3 9l6.5-.5L12 2z"/></svg>`,
            health: `<svg class="h-8 w-8 text-green-400" viewBox="0 0 24 24" fill="currentColor"><path d="M19 11h-6V5h-2v6H5v2h6v6h2v-6h6z"/></svg>`,
            bomb: `<svg class="h-8 w-8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="14" r="8" fill="#4a5568"/><rect x="10" y="3" width="4" height="4" rx="1" fill="#2d3748"/><circle cx="12" cy="2" r="1.5" fill="#ef4444"/></svg>`,
            shield: `<svg class="h-8 w-8 text-sky-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z"/></svg>`,
            grow: `<svg class="h-8 w-8 text-blue-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 8l-6 6h12l-6-6z"/></svg>`,
            shrink: `<svg class="h-8 w-8 text-orange-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 16l6-6H6l6 6z"/></svg>`,
            speedBoost: `<svg class="h-8 w-8 text-teal-400" viewBox="0 0 24 24" fill="currentColor"><path d="M13 2L3 14h9l-1 8 11-12h-9z"/></svg>`,
            rain: `<svg class="h-8 w-8 text-blue-300" viewBox="0 0 24 24" fill="currentColor"><path d="M19.35 10.04A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.04A5.994 5.994 0 0 0 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM9 19H7v-4h2v4zm4 0h-2v-4h2v4zm4 0h-2v-4h2v4z"/></svg>`,
            invisibility: `<svg class="h-8 w-8 text-gray-400" viewBox="0 0 24 24" fill="currentColor"><path d="M12,2A9,9 0 0,0 3,11V22L6,19L9,22L12,19L15,22L18,19L21,22V11A9,9 0 0,0 12,2M9,8A2,2 0 0,1 11,10A2,2 0 0,1 9,12A2,2 0 0,1 7,10A2,2 0 0,1 9,8M15,8A2,2 0 0,1 17,10A2,2 0 0,1 15,12A2,2 0 0,1 13,10A2,2 0 0,1 15,8Z" /></svg>`,
            wallSpikes: `<svg class="h-8 w-8 text-red-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 20h20v2H2v-2zM3.414 4L12 12.586 20.586 4 22 5.414 13.414 14 22 22.586 20.586 24 12 15.414 3.414 24 2 22.586 10.586 14 2 5.414 3.414 4z"/></svg>`,
            diagonalWall: `<svg class="h-8 w-8 text-indigo-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 21.0001L21 3.00006L19.5 1.50006L1.5 19.5L3 21.0001Z"/></svg>`,
            clone: `<svg class="h-8 w-8 text-purple-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3a9 9 0 0 0-9 9 9 9 0 0 0 9 9 9 9 0 0 0 9-9 9 9 0 0 0-9-9zm0 16a7 7 0 0 1-7-7 7 7 0 0 1 7-7 7 7 0 0 1 7 7 7 7 0 0 1-7 7zm-3-7a3 3 0 1 1 6 0 3 3 0 0 1-6 0z"/></svg>`,
            cannotEat: `<svg class="h-8 w-8 text-green-300" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8zm-2.8-10.2L11 11.6V8h2v5.1l-1.8 1.8-1.4-1.4 1.2-1.2-3.8-3.7z"/></svg>`,
            laserGun: `<svg class="h-8 w-8 text-pink-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M6 2L8 8H2V6H4.6L2.8 2.8L4.2 1.4L6 2M2 16H8L6 22L4.2 20.6L2.8 21.2L4.6 18H2V16M9 3H15V5H9V3M20.6 1.4L19.2 2.8L21.4 6H18V8H24L22 2L20.6 1.4M15 19H9V21H15V19M22 16H18V18H21.4L19.2 21.2L20.6 22.6L24 16Z"/></svg>`,
            slow: `<svg class="h-8 w-8 text-amber-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="m15 5-1.41 1.41L15 7.83V14.17l-1.41-1.41L12.17 14 17 18.83 21.83 14 20.41 12.59 19 14.17V7.83l1.41 1.41L21.83 8 17 3.17 12.17 8l1.41 1.41L15 7.83zM7 5l-1.41 1.41L7 7.83v6.34l-1.41-1.41L4.17 14 9 18.83 13.83 14 12.41 12.59 11 14.17V7.83l1.41 1.41L13.83 8 9 3.17 4.17 8l1.41 1.41L7 7.83z"/></svg>`,
            homingMissile: `<svg class="h-8 w-8 text-orange-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L9.91 5.95L6 6.18L8.73 9.09L8.09 13.05L12 11L15.91 13.05L15.27 9.09L18 6.18L14.09 5.95L12 2M22 13V15H17V13H22M2 13V15H15V13H2Z" /></svg>`,
            reflectiveCloak: `<svg class="h-8 w-8 text-fuchsia-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L1 9l4 1.5V21h14v-9.5L23 9l-11-7zm0 2.5l7 4.5-2 .75V19H7v-9.25L5 8l7-4.5zM9 13v2h6v-2H9z"/></svg>`,
            snare: `<svg class="h-8 w-8 text-lime-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12H17A5,5 0 0,0 12,7V4M4,12A8,8 0 0,1 12,4V7A5,5 0 0,0 7,12H4M12,20A8,8 0 0,1 4,12H7A5,5 0 0,0 12,17V20M20,12A8,8 0 0,1 12,20V17A5,5 0 0,0 17,12H20Z" /></svg>`
        };
        const ITEM_COLORS = {
            weapon: '#f6e05e', health: '#48bb78', bomb: '#f56565', shield: '#38bdf8',
            grow: '#63b3ed', shrink: '#f6ad55', speedBoost: '#4fd1c5', rain: '#3b82f6', 
            invisibility: '#9ca3af', wallSpikes: '#ef4444', diagonalWall: '#818cf8', clone: '#c084fc', 
            cannotEat: '#86efac', laserGun: '#f472b6', slow: '#f59e0b', homingMissile: '#f97316',
            reflectiveCloak: '#e879f9', snare: '#a3e635'
        };

        let players = [], items = {}, animationFrameId, gameEndTime, activeLaser = null, activeMissile = null;
        let activeRainZone = null, activeSpikeWall = null, activeDiagonalWall = null;
        let itemSpawnTimeouts = [];
        let itemDisappearTimeouts = { health: null, bomb: null, snare: null };
        let particles = [];
        const TOTAL_GAME_TIME = 90 * 1000;
        const INITIAL_SPAWN_TIME = 5000;
        let banPickState = { currentIndex: 0, p1Bans: [], p2Bans: [], p1Picks: [], p2Picks: [], selectionCandidate: null };

        const ITEM_CONFIG = {
            weapon: { name: 'Vũ Khí Gai', baseRespawn: 10000, type: 'neutral', desc: 'Nhận một lớp gai tồn tại trong 5s. Va chạm với đối thủ sẽ gây sát thương và phá vỡ gai. Gai cũng sẽ vỡ khi chặn các sát thương khác.', stats: { 'Thời gian': '5s', 'Hiệu ứng': '1 lần tấn công/phòng thủ' } }, 
            health: { name: 'Hồi Máu', baseRespawn: 10000, type: 'neutral', desc: 'Hồi lại 1 mạng nếu chưa đầy máu.', stats: { 'Hồi phục': '+1 Mạng' } }, 
            bomb: { name: 'Bom', baseRespawn: 5000, type: 'debuff', desc: 'Đặt một quả bom trên bản đồ. Đối thủ của người nhặt sẽ bị mất mạng nếu chạm phải.', stats: {} },
            shield: { name: 'Khiên', baseRespawn: 10000, type: 'neutral', desc: 'Nhận 1 lớp khiên chặn đòn tấn công hoặc hiệu ứng bất lợi tiếp theo.', stats: { 'Hiệu ứng': 'Chặn 1 đòn' } }, 
            reflectiveCloak: { name: 'Áo Choàng Phản', baseRespawn: 15000, type: 'buff', desc: 'Tồn tại 10s hoặc đến khi bị tấn công, sẽ phản lại sát thương cho đối thủ.', stats: { 'Thời gian': '10s', 'Hiệu ứng': '1 lần phản đòn'} },
            snare: { name: 'Trói Chân', baseRespawn: 15000, type: 'debuff', desc: 'Đặt một chiếc bẫy. Đối thủ của người nhặt sẽ bị trói chân trong 3 giây nếu dẫm phải.', stats: { 'Thời gian trói': '3s'} },
            grow: { name: 'Phóng To', baseRespawn: 12000, type: 'debuff', desc: 'Phóng to kích thước của đối thủ.', stats: { 'Thời gian': '10s', 'Kích thước': '+25%' } }, 
            shrink: { name: 'Thu Nhỏ', baseRespawn: 12000, type: 'buff', desc: 'Thu nhỏ kích thước bản thân.', stats: { 'Thời gian': '10s', 'Kích thước': '-25%' } }, 
            speedBoost: { name: 'Tăng Tốc', baseRespawn: 12000, type: 'buff', desc: 'Tăng mạnh tốc độ di chuyển.', stats: { 'Thời gian': '5s', 'Tốc độ': '+50%' } }, 
            slow: { name: 'Làm Chậm', baseRespawn: 12000, type: 'debuff', desc: 'Giảm tốc độ di chuyển của đối thủ.', stats: { 'Thời gian': '5s', 'Tốc độ': '-50%'}},
            rain: { name: 'Mưa bom', baseRespawn: 10000, type: 'debuff', desc: 'Tạo một vùng mưa gây sát thương lên đối thủ.', stats: { 'Thời gian': '5s', 'Sát thương': '3 lần' } }, 
            invisibility: { name: 'Tàng Hình', baseRespawn: 15000, type: 'buff', desc: 'Trở nên bất tử, miễn nhiễm sát thương.', stats: { 'Thời gian': '3s' } },
            wallSpikes: { name: 'Tường Gai', baseRespawn: 15000, type: 'map_effect', desc: 'Tạo gai trên một cạnh tường ngẫu nhiên. Người nhặt sẽ luôn miễn nhiễm.', stats: { 'Độ bền': '1 lần chạm' } }, 
            diagonalWall: { name: 'Tường Chéo', baseRespawn: 20000, type: 'map_effect', desc: 'Tạo một bức tường chéo ở góc.', stats: { 'Độ bền': '5 lần chạm' } }, 
            clone: { name: 'Phân Thân', baseRespawn: 15000, type: 'buff', desc: 'Tạo ra một bản sao của bản thân. Các bản thể chia sẻ chung trạng thái.', stats: { 'Tối đa': '3 bản thể' } },
            cannotEat: { name: 'Cấm Ăn', baseRespawn: 10000, type: 'debuff', desc: 'Khiến đối thủ không thể nhặt vật phẩm.', stats: { 'Thời gian': '5s' } },
            laserGun: { name: 'Súng Laze', baseRespawn: 20000, type: 'debuff', desc: 'Bắn một tia laze bật tường gây sát thương cho đối thủ.', stats: { 'Thời gian': '2s', 'Bật tường': '5 lần' }},
            homingMissile: { name: 'Tên Lửa', baseRespawn: 15000, type: 'debuff', desc: 'Bắn một tên lửa bám đuổi đối thủ. Nổ khi va chạm tường.', stats: {'Tồn tại': '10s'}}
        };
// ... sau hằng số ITEM_CONFIG

// THÊM CẢ KHỐI CODE NÀY VÀO
const requestWakeLock = async () => {
    // Kiểm tra xem trình duyệt có hỗ trợ Wake Lock API không
    if ('wakeLock' in navigator) {
        try {
            // Yêu cầu khóa màn hình
            wakeLockSentinel = await navigator.wakeLock.request('screen');
            console.log('Screen Wake Lock đã được kích hoạt.');

            // Lắng nghe sự kiện khi khóa bị hủy bởi hệ thống (ví dụ: pin yếu)
            wakeLockSentinel.addEventListener('release', () => {
                console.log('Screen Wake Lock đã bị hủy.');
                wakeLockSentinel = null;
            });
        } catch (err) {
            console.error(`Không thể kích hoạt Wake Lock: ${err.name}, ${err.message}`);
        }
    } else {
        console.warn('Trình duyệt này không hỗ trợ Screen Wake Lock API.');
    }
};

const releaseWakeLock = async () => {
    if (wakeLockSentinel) {
        await wakeLockSentinel.release();
        wakeLockSentinel = null;
    }
};
// KẾT THÚC KHỐI CODE CẦN THÊM
					 
        const banPickSequence = [
            { phase: 'ban', player: 1 }, { phase: 'ban', player: 2 }, 
            { phase: 'pick', player: 1 }, { phase: 'pick', player: 2 }, { phase: 'pick', player: 1 }, 
            { phase: 'ban', player: 2 }, { phase: 'ban', player: 1 }, 
            { phase: 'pick', player: 2 }, { phase: 'pick', player: 2 }, 
            { phase: 'pick', player: 1 },
        ];

        function setCanvasSize() {
            const container = document.getElementById('game-container');
            const multiplier = window.innerWidth <= 768 ? 0.8 : 0.7;
            const size = Math.min(container.clientWidth, container.clientHeight) * multiplier;
            canvas.width = size; canvas.height = size;
        }

        class Particle {
            constructor(x, y, dx, dy, radius, color, life, friction = 1) { this.x = x; this.y = y; this.dx = dx; this.dy = dy; this.radius = radius; this.color = color; this.life = life; this.initialLife = life; this.friction = friction; }
            draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.globalAlpha = Math.max(0, this.life / this.initialLife); ctx.fillStyle = this.color; ctx.fill(); ctx.globalAlpha = 1; }
            update() { this.dx *= this.friction; this.dy *= this.friction; this.x += this.dx; this.y += this.dy; this.life--; }
        }
        
        class Laser {
            constructor(startPos, initialDir, owner) {
                this.owner = owner;
                this.startTime = Date.now();
                this.endTime = this.startTime + 2000;
                this.segments = [];
                this.maxBounces = 5;
                this.calculatePath(startPos, initialDir);
            }
            calculatePath(currentPos, currentDir) {
                if (this.segments.length > this.maxBounces) return;
                let endPoint = null;
                let reflectionDir = { ...currentDir };
                let minT = Infinity;
                if (currentDir.y < 0) { let t = -currentPos.y / currentDir.y; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: currentPos.x + t * currentDir.x, y: 0}; reflectionDir = {x: currentDir.x, y: -currentDir.y}; } }
                if (currentDir.y > 0) { let t = (canvas.height - currentPos.y) / currentDir.y; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: currentPos.x + t * currentDir.x, y: canvas.height}; reflectionDir = {x: currentDir.x, y: -currentDir.y}; } }
                if (currentDir.x < 0) { let t = -currentPos.x / currentDir.x; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: 0, y: currentPos.y + t * currentDir.y}; reflectionDir = {x: -currentDir.x, y: currentDir.y}; } }
                if (currentDir.x > 0) { let t = (canvas.width - currentPos.x) / currentDir.x; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: canvas.width, y: currentPos.y + t * currentDir.y}; reflectionDir = {x: -currentDir.x, y: currentDir.y}; } }
                if (endPoint) { this.segments.push({ p1: currentPos, p2: endPoint }); this.calculatePath(endPoint, reflectionDir); }
            }
            draw() { const lifeLeft = (this.endTime - Date.now()) / 2000; if (lifeLeft < 0) return; ctx.strokeStyle = this.owner.color; ctx.lineWidth = 4; ctx.shadowBlur = 10; ctx.shadowColor = this.owner.color; ctx.globalAlpha = lifeLeft; this.segments.forEach(seg => { ctx.beginPath(); ctx.moveTo(seg.p1.x, seg.p1.y); ctx.lineTo(seg.p2.x, seg.p2.y); ctx.stroke(); }); ctx.globalAlpha = 1; ctx.shadowBlur = 0; }
            checkCollision(ball) { for (const seg of this.segments) { const A = seg.p1, B = seg.p2, C = { x: ball.x, y: ball.y }, R = ball.radius; let AC = { x: C.x - A.x, y: C.y - A.y }; let AB = { x: B.x - A.x, y: B.y - A.y }; let magAB2 = AB.x * AB.x + AB.y * AB.y; let dot = AC.x * AB.x + AC.y * AB.y; let t = dot / magAB2; let closestX, closestY; if (t < 0) { closestX = A.x; closestY = A.y; } else if (t > 1) { closestX = B.x; closestY = B.y; } else { closestX = A.x + t * AB.x; closestY = A.y + t * AB.y; } let distSq = (C.x - closestX)**2 + (C.y - closestY)**2; if (distSq < R**2) { return true; } } return false; }
        }

        class RainZone {
            constructor(x, y, radius, owner) { this.x = x; this.y = y; this.radius = radius; this.owner = owner; this.startTime = Date.now(); this.endTime = this.startTime + 5000; this.drops = [ { time: 1000, triggered: false }, { time: 2500, triggered: false }, { time: 4000, triggered: false }]; }
            draw() { const progress = (Date.now() - this.startTime) / 5000; const alpha = 0.5 * (1 - progress); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = `rgba(56, 189, 248, ${alpha * 0.5})`; ctx.fill(); ctx.strokeStyle = `rgba(56, 189, 248, ${alpha})`; ctx.lineWidth = 2; ctx.stroke(); this.drops.forEach(drop => { const dropTime = this.startTime + drop.time; if (Date.now() > dropTime && Date.now() < dropTime + 200) { for(let i=0; i<15; i++) { const rainX = this.x + (Math.random() - 0.5) * this.radius * 2; const rainY = this.y + (Math.random() - 0.5) * this.radius * 2; if(Math.hypot(rainX - this.x, rainY - this.y) < this.radius) { ctx.beginPath(); ctx.moveTo(rainX, rainY - 5); ctx.lineTo(rainX, rainY + 5); ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)'; ctx.lineWidth = 1; ctx.stroke(); } } } }); }
            update() { const now = Date.now(); this.drops.forEach(drop => { if (!drop.triggered && now > this.startTime + drop.time) { getAllPlayerBalls().forEach(ball => { if (ball.controller !== this.owner && Math.hypot(ball.x - this.x, ball.y - this.y) < ball.radius + this.radius) { ball.controller.takeDamage(ball); } }); drop.triggered = true; } }); if (now > this.endTime) activeRainZone = null; }
        }

        class DiagonalWall {
            constructor() { this.hits = 5; this.corner = Math.floor(Math.random() * 4); const w = canvas.width; const h = canvas.height; const midW = w / 2; const midH = h / 2; const corners = [ { p1: { x: 0, y: midH }, p2: { x: midW, y: 0 } }, { p1: { x: midW, y: 0 }, p2: { x: w, y: midH } }, { p1: { x: w, y: midH }, p2: { x: midW, y: h } }, { p1: { x: midW, y: h }, p2: { x: 0, y: midH } } ]; this.p1 = corners[this.corner].p1; this.p2 = corners[this.corner].p2; let dx = this.p2.x - this.p1.x; let dy = this.p2.y - this.p1.y; this.normal = { x: -dy, y: dx }; const mag = Math.hypot(this.normal.x, this.normal.y); this.normal.x /= mag; this.normal.y /= mag; }
            draw() { ctx.beginPath(); ctx.moveTo(this.p1.x, this.p1.y); ctx.lineTo(this.p2.x, this.p2.y); ctx.strokeStyle = `rgba(129, 140, 248, ${0.4 + (this.hits / 5) * 0.6})`; ctx.lineWidth = 5; ctx.stroke(); }
        }
        
        class HomingMissile {
            constructor(owner, targetController) {
                this.owner = owner;
                this.targetController = targetController;
                const startBall = owner.balls[0];
                this.x = startBall.x; this.y = startBall.y;
                this.baseSpeed = startBall.baseSpeed;
                this.currentSpeed = this.baseSpeed;
                this.angle = Math.random() * 2 * Math.PI;
                this.turnSpeed = 0.04;
                this.endTime = Date.now() + 10000;
                this.radius = 5;
            }
            update() {
                if (Date.now() > this.endTime || !this.targetController.balls.length) { activeMissile = null; return; }
                const target = this.targetController.balls[0];
                const targetAngle = Math.atan2(target.y - this.y, target.x - this.x);
                let angleDiff = targetAngle - this.angle;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;

                const distToTarget = Math.hypot(this.x - target.x, this.y - target.y);
                if (Math.abs(angleDiff) > Math.PI / 2) {
                    this.currentSpeed = this.baseSpeed * 0.75;
                } else if (distToTarget < canvas.width / 4) {
                    this.currentSpeed = this.baseSpeed * 1.25;
                } else {
                    this.currentSpeed = this.baseSpeed;
                }
                
                this.angle += angleDiff * this.turnSpeed;
                const dx = Math.cos(this.angle) * this.currentSpeed;
                const dy = Math.sin(this.angle) * this.currentSpeed;
                this.x += dx; this.y += dy;

                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    triggerEffect(this.x, this.y, ITEM_COLORS.homingMissile, { count: 20 });
                    activeMissile = null;
                    return;
                }

                if(distToTarget < this.radius + target.radius) {
                    this.targetController.takeDamage(target, this.owner);
                    triggerEffect(this.x, this.y, ITEM_COLORS.homingMissile, { count: 30, speed: 4 });
                    activeMissile = null;
                }
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = this.owner.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.owner.color;
                ctx.beginPath();
                ctx.moveTo(this.radius, 0);
                ctx.lineTo(-this.radius, -this.radius / 1.5);
                ctx.lineTo(-this.radius, this.radius / 1.5);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                ctx.shadowBlur = 0;
            }
        }
        
        class PlayerBall {
            constructor(x, y, baseRadius, controller) {
                this.controller = controller; this.x = x; this.y = y; this.baseRadius = baseRadius;
                this.baseSpeed = (canvas.width / 200) * 4.5 * 0.75 * 0.9; this.speed = this.baseSpeed;
                let angle = Math.random() * Math.PI * 2; this.dx = Math.cos(angle) * this.speed; this.dy = Math.sin(angle) * this.speed;
            }
            get radius() { return this.controller.sizeEffect === 'shrink' ? this.baseRadius * 0.75 : (this.controller.sizeEffect === 'grow' ? this.baseRadius * 1.25 : this.baseRadius); }
            get invincibleUntil() { return this.controller.invincibleUntil; }
            get sizeEffect() { return this.controller.sizeEffect; }
            get cannotEatUntil() { return this.controller.cannotEatUntil; }
            get isSnared() { return this.controller.snaredUntil && Date.now() < this.controller.snaredUntil; }
            
            draw() {
                ctx.globalAlpha = 1;
                if (this.invincibleUntil && Date.now() < this.invincibleUntil) { if (Math.floor(Date.now() / 150) % 2 === 0) { ctx.globalAlpha = 0.5; } }
                
                // Draw armor layers underneath the ball
                this.controller.armor.forEach((armorType, index) => {
                    const armorRadius = this.radius + 5 + (index * 4);
                    const armorColor = ITEM_COLORS[armorType] || '#ffffff';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, armorRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = armorColor;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.closePath();
                });

                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.controller.color; ctx.fill();
                if (this.sizeEffect) { ctx.strokeStyle = this.sizeEffect === 'grow' ? '#f6ad55' : '#63b3ed'; ctx.lineWidth = 4; ctx.stroke(); }
                if (this.cannotEatUntil && Date.now() < this.cannotEatUntil) { ctx.strokeStyle = ITEM_COLORS.cannotEat; ctx.lineWidth = 4; ctx.stroke(); }
                if (this.isSnared) { 
                    ctx.strokeStyle = ITEM_COLORS.snare; ctx.lineWidth = 4; ctx.stroke(); 
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                ctx.closePath();
                ctx.globalAlpha = 1;
            }
            update() { 
                if (this.isSnared) {
                    // Không cập nhật vị trí, giữ nguyên vận tốc để khi hết hiệu lực có thể di chuyển lại
                    return; 
                }
                this.x += this.dx; 
                this.y += this.dy; 
            }
        }

        class PlayerController {
            constructor(name, color, initialBall) { this.name = name; this.color = color; this.lives = 5; this.balls = [initialBall]; this.hasSpikeWallImmunity = false; this.armor = []; this.invincibleUntil = null; this.sizeEffect = null; this.speedMultiplier = 1.0; this.effectTimeouts = { size: null, speed: null, shield: null, invincible: null, cannotEat: null, reflectiveCloak: null, weapon: null, snare: null }; this.cannotEatUntil = null; this.snaredUntil = null; this.score = 0; }
            
            takeDamage(ball, attacker = null, isReflectedDamage = false) {
                const now = Date.now();
                if (this.invincibleUntil && now < this.invincibleUntil) return false;

                const realArmorIndex = this.armor.findIndex(type => type !== 'weapon');

if (realArmorIndex > -1) {
    // Gỡ bỏ loại giáp đã tìm thấy
    const armorType = this.armor.splice(realArmorIndex, 1)[0]; 
 if (armorType === 'shield') {
        const shieldData = items['shield'];
        if (shieldData) {
            shieldData.cooldownEndTime = Date.now() + shieldData.currentRespawn;
            itemSpawnTimeouts.push(setTimeout(() => spawnItem('shield'), shieldData.currentRespawn));
        }
    }
    if (armorType === 'reflectiveCloak') {
        clearTimeout(this.effectTimeouts.reflectiveCloak);
    }
    triggerEffect(ball.x, ball.y, ITEM_COLORS[armorType] || this.color, { count: 25, speed: 5 });
    
    if (!isReflectedDamage && (armorType === 'reflectiveCloak') && attacker && attacker.balls.length > 0) {
        attacker.takeDamage(attacker.balls[0], this, true);
    }
    updateLivesUI();
    return false;
}

               // Logic mới
this.lives--; 
this.invincibleUntil = now + 2000; 
updateLivesUI();

// Cộng điểm cho người tấn công
if (attacker) {
    attacker.score++;
    updateScoreUI();
    if (attacker.score >= 10) {
        endGame(false, attacker); // Thắng ngay khi đủ 5 điểm
        return true;
    }
}

if (this.lives <= 0) { 
    triggerDeath(this); 
} else { 
    pauseGameForEffect({ duration: 1200, shake: 5 }); 
} 
return true;
                } 
            
            addBall() {
                if (this.balls.length >= 3) return;
                const parentBall = this.balls[0];
                const newBall = new PlayerBall(parentBall.x + (Math.random() - 0.5) * 20, parentBall.y + (Math.random() - 0.5) * 20, this.balls[0].baseRadius, this);
                let angle = Math.random() * Math.PI * 2; newBall.dx = Math.cos(angle) * newBall.speed; newBall.dy = Math.sin(angle) * newBall.speed;
                updatePlayerVelocity(newBall); this.balls.push(newBall);
                triggerEffect(newBall.x, newBall.y, this.color, { count: 30, speed: 4 });
            }
            removeBall(ball) { const index = this.balls.indexOf(ball); if (index > -1) { triggerEffect(ball.x, ball.y, this.color, { count: 15, speed: 3, life: 30 }); this.balls.splice(index, 1); } }
            
            applyEffect(effectType, duration, value) {
                clearTimeout(this.effectTimeouts[effectType]);
                switch(effectType) {
                    case 'size': this.sizeEffect = value; break;
                    case 'speed': this.speedMultiplier = value; break;
                    case 'cannotEat': this.cannotEatUntil = Date.now() + duration; break;
                    case 'snare': this.snaredUntil = Date.now() + duration; break;
                        case 'reflectiveCloak':
                        if (!this.armor.includes('reflectiveCloak')) {
                            this.armor.push('reflectiveCloak');
                        }
                        this.effectTimeouts.reflectiveCloak = setTimeout(() => {
                           const index = this.armor.indexOf('reflectiveCloak');
                           if(index > -1) this.armor.splice(index, 1);
                           // --- BẮT ĐẦU SỬA ---
                           // Thêm logic bắt đầu hồi chiêu khi áo choàng hết hạn
                           const itemData = items['reflectiveCloak'];
                           if (itemData) {
                               const respawnTime = itemData.currentRespawn;
                               itemData.cooldownEndTime = Date.now() + respawnTime;
                               itemSpawnTimeouts.push(setTimeout(() => spawnItem('reflectiveCloak'), respawnTime));
                           }
                           // --- KẾT THÚC SỬA ---
                           updateLivesUI();
                        }, duration);
                        updateLivesUI();
                        return; // Exit early to avoid standard timeout logic
                }
                 this.effectTimeouts[effectType] = setTimeout(() => {
                    switch(effectType) {
                        case 'size': this.sizeEffect = null; break;
                        case 'speed': this.speedMultiplier = 1.0; break;
                        case 'cannotEat': this.cannotEatUntil = null; break;
                        case 'snare': this.snaredUntil = null; break;
                    }
                    updatePlayerStatusUI();
                }, duration);
            }
        }
        
        class Item {
            constructor(x, y, radius, type, owner, duration = null) { this.x = x; this.y = y; this.radius = radius; this.type = type; this.owner = owner; this.disappearTime = duration ? Date.now() + duration : null; }
            draw() {
                if (this.owner && this.owner !== 'neutral') { ctx.shadowBlur = 15; ctx.shadowColor = this.owner.color; }
                const drawFunc = ITEM_DRAW_LOGIC[this.type]; if (drawFunc) drawFunc(this);
                ctx.shadowBlur = 0;
            }
        }

        const ITEM_DRAW_LOGIC = {
            weapon: (item) => { ctx.fillStyle = '#f6e05e'; ctx.strokeStyle = '#b7791f'; for (let i = 0; i < 8; i++) { let angle = (i / 8) * (Math.PI * 2); let outerRadius = item.radius * 1.4; ctx.beginPath(); ctx.moveTo(item.x, item.y); ctx.lineTo(item.x + Math.cos(angle) * outerRadius, item.y + Math.sin(angle) * outerRadius); ctx.stroke(); } ctx.beginPath(); ctx.arc(item.x, item.y, item.radius * 0.8, 0, Math.PI * 2); ctx.fill(); },
            health: (item) => { ctx.fillStyle = '#48bb78'; ctx.strokeStyle = '#2f855a'; const barWidth = item.radius * 1.5; const barHeight = item.radius * 0.5; ctx.fillRect(item.x - barWidth / 2, item.y - barHeight / 2, barWidth, barHeight); ctx.strokeRect(item.x - barWidth / 2, item.y - barHeight / 2, barWidth, barHeight); ctx.fillRect(item.x - barHeight / 2, item.y - barWidth / 2, barHeight, barWidth); ctx.strokeRect(item.x - barHeight / 2, item.y - barWidth / 2, barHeight, barWidth); },
            bomb: (item) => {
                ctx.fillStyle = '#4a5568';
                ctx.strokeStyle = '#1a202c';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = '#2d3748';
                ctx.fillRect(item.x - item.radius * 0.2, item.y - item.radius * 1.2, item.radius * 0.4, item.radius * 0.4);
                const pulse = Math.abs(Math.sin(Date.now() / 150));
                ctx.fillStyle = `rgba(255, ${150 + pulse * 105}, 0, ${0.8 + pulse * 0.2})`;
                ctx.beginPath();
                ctx.arc(item.x, item.y - item.radius * 1.2, 3, 0, Math.PI * 2);
                ctx.fill();
            },
            shield: (item) => { ctx.fillStyle = '#38bdf8'; ctx.strokeStyle = '#0284c7'; ctx.beginPath(); ctx.moveTo(item.x, item.y - item.radius); ctx.lineTo(item.x - item.radius, item.y - item.radius * 0.3); ctx.lineTo(item.x - item.radius, item.y + item.radius * 0.5); ctx.arc(item.x, item.y + item.radius * 0.5, item.radius, Math.PI, 0, false); ctx.lineTo(item.x + item.radius, item.y - item.radius * 0.3); ctx.closePath(); ctx.fill(); ctx.stroke(); },
            grow: (item) => { const isGrow = true; ctx.fillStyle = isGrow ? '#63b3ed' : '#f6ad55'; ctx.strokeStyle = isGrow ? '#3182ce' : '#dd6b20'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; const arrowHeight = item.radius * 0.5; const arrowWidth = item.radius * 0.6; const direction = isGrow ? -1 : 1; ctx.beginPath(); ctx.moveTo(item.x - arrowWidth, item.y + direction * arrowHeight); ctx.lineTo(item.x, item.y - direction * arrowHeight); ctx.lineTo(item.x + arrowWidth, item.y + direction * arrowHeight); ctx.closePath(); ctx.fill(); },
            shrink: (item) => { const isGrow = false; ctx.fillStyle = isGrow ? '#63b3ed' : '#f6ad55'; ctx.strokeStyle = isGrow ? '#3182ce' : '#dd6b20'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; const arrowHeight = item.radius * 0.5; const arrowWidth = item.radius * 0.6; const direction = isGrow ? -1 : 1; ctx.beginPath(); ctx.moveTo(item.x - arrowWidth, item.y + direction * arrowHeight); ctx.lineTo(item.x, item.y - direction * arrowHeight); ctx.lineTo(item.x + arrowWidth, item.y + direction * arrowHeight); ctx.closePath(); ctx.fill(); },
            speedBoost: (item) => { ctx.fillStyle = '#4fd1c5'; ctx.strokeStyle = '#319795'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; ctx.beginPath(); ctx.moveTo(item.x + item.radius * 0.3, item.y - item.radius * 0.6); ctx.lineTo(item.x - item.radius * 0.4, item.y); ctx.lineTo(item.x, item.y); ctx.lineTo(item.x - item.radius * 0.3, item.y + item.radius * 0.6); ctx.lineTo(item.x + item.radius * 0.4, item.y); ctx.lineTo(item.x, item.y); ctx.closePath(); ctx.fill(); },
            rain: (item) => { ctx.fillStyle = ITEM_COLORS.rain; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; ctx.fillRect(item.x - item.radius * 0.5, item.y, 2, 5); ctx.fillRect(item.x, item.y + item.radius * 0.2, 2, 5); ctx.fillRect(item.x + item.radius * 0.5, item.y, 2, 5); },
            invisibility: (item) => { ctx.fillStyle = ITEM_COLORS.invisibility; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(item.x - item.radius * 0.3, item.y - item.radius * 0.2, item.radius * 0.15, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(item.x + item.radius * 0.3, item.y - item.radius * 0.2, item.radius * 0.15, 0, Math.PI * 2); ctx.fill(); },
            wallSpikes: (item) => { ctx.fillStyle = ITEM_COLORS.wallSpikes; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.rect(item.x - item.radius, item.y + item.radius * 0.5, item.radius * 2, item.radius * 0.5); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; for (let i = 0; i < 3; i++) { const xPos = item.x - item.radius * 0.6 + i * item.radius * 0.6; ctx.beginPath(); ctx.moveTo(xPos - item.radius * 0.2, item.y + item.radius * 0.5); ctx.lineTo(xPos, item.y - item.radius * 0.5); ctx.lineTo(xPos + item.radius * 0.2, item.y + item.radius * 0.5); ctx.closePath(); ctx.fill(); } },
            diagonalWall: (item) => { ctx.fillStyle = ITEM_COLORS.diagonalWall; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(item.x - item.radius * 0.7, item.y + item.radius * 0.7); ctx.lineTo(item.x + item.radius * 0.7, item.y - item.radius * 0.7); ctx.stroke(); },
            clone: (item) => { ctx.fillStyle = ITEM_COLORS.clone; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x - item.radius * 0.3, item.y, item.radius * 0.8, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.arc(item.x + item.radius * 0.3, item.y, item.radius * 0.8, 0, Math.PI * 2); ctx.globalAlpha = 0.7; ctx.fill(); ctx.stroke(); ctx.globalAlpha = 1; },
            cannotEat: (item) => { ctx.fillStyle = ITEM_COLORS.cannotEat; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius * 0.6, Math.PI * 0.2, Math.PI * 1.8); ctx.stroke(); },
            laserGun: (item) => { ctx.fillStyle = ITEM_COLORS.laserGun; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(item.x - item.radius * 0.5, item.y); ctx.lineTo(item.x + item.radius * 0.5, item.y); ctx.stroke(); ctx.beginPath(); ctx.moveTo(item.x, item.y - item.radius * 0.5); ctx.lineTo(item.x, item.y + item.radius * 0.5); ctx.stroke(); },
            slow: (item) => { ctx.fillStyle = ITEM_COLORS.slow; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; ctx.beginPath(); ctx.moveTo(item.x - 5, item.y + 5); ctx.lineTo(item.x, item.y); ctx.lineTo(item.x + 5, item.y + 5); ctx.moveTo(item.x - 5, item.y); ctx.lineTo(item.x, item.y - 5); ctx.lineTo(item.x + 5, item.y); ctx.lineWidth = 2; ctx.stroke(); },
            homingMissile: (item) => { ctx.fillStyle = ITEM_COLORS.homingMissile; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.moveTo(item.x, item.y - item.radius); ctx.lineTo(item.x - item.radius, item.y + item.radius * 0.5); ctx.lineTo(item.x + item.radius, item.y + item.radius * 0.5); ctx.closePath(); ctx.fill(); ctx.stroke(); },
            reflectiveCloak: (item) => { ctx.fillStyle = ITEM_COLORS.reflectiveCloak; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); },
            snare: (item) => { ctx.fillStyle = ITEM_COLORS.snare; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); },
            snare_trap: (item) => { ctx.strokeStyle = ITEM_COLORS.snare; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.stroke(); ctx.beginPath(); ctx.arc(item.x, item.y, item.radius * 0.5, 0, Math.PI * 2); ctx.stroke(); },
            bomb_trap: (item) => {
                ctx.fillStyle = '#4a5568';
                ctx.strokeStyle = '#1a202c';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = '#2d3748';
                ctx.fillRect(item.x - item.radius * 0.2, item.y - item.radius * 1.2, item.radius * 0.4, item.radius * 0.4);

                const pulse = Math.abs(Math.sin(Date.now() / 150));
                ctx.fillStyle = `rgba(255, ${150 + pulse * 105}, 0, ${0.8 + pulse * 0.2})`;
                ctx.beginPath();
                ctx.arc(item.x, item.y - item.radius * 1.2, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        };
        
        function updateLivesUI() {
            if (!players[0] || !players[1]) return;
            const p1LivesDiv = document.getElementById('player1-lives');
            const p2LivesDiv = document.getElementById('player2-lives');
            
            const renderLives = (container, player, colorClass) => {
                container.innerHTML = '';
                // Render hearts
                for (let i = 0; i < 5; i++) {
                    if (i < player.lives) {
                        container.innerHTML += `<div class="w-4 h-4 ${colorClass} rounded-full"></div>`;
                    } else {
                        container.innerHTML += `<div class="w-4 h-4 bg-gray-700 rounded-full"></div>`;
                    }
                }
                // Render armor icons
                const armorContainer = document.createElement('div');
                armorContainer.className = 'flex items-center space-x-1 ml-2';
                player.armor.forEach(armorType => {
                     armorContainer.innerHTML += `<div class="w-4 h-4">${ICONS[armorType].replace('h-8 w-8', 'h-4 w-4')}</div>`;
                });
                container.appendChild(armorContainer);
            };

            renderLives(p1LivesDiv, players[0], 'bg-blue-500');
            renderLives(p2LivesDiv, players[1], 'bg-red-500');
        }
		function updateScoreUI() {
    if (!players[0] || !players[1]) return;
    const p1ScoreDiv = document.getElementById('player1-score');
    const p2ScoreDiv = document.getElementById('player2-score');
    p1ScoreDiv.textContent = players[0].score;
    p2ScoreDiv.textContent = players[1].score;
}
        function updatePlayerStatusUI() {
            const p1_icons = document.getElementById('player1-status-icons');
            const p2_icons = document.getElementById('player2-status-icons');
            p1_icons.innerHTML = ''; p2_icons.innerHTML = '';
            const smallIcon = (svg) => svg.replace('h-8 w-8', 'h-4 w-4');
            const addIcons = (player, container) => {
                if (!player) return;
                if (player.invincibleUntil && Date.now() < player.invincibleUntil) container.innerHTML += smallIcon(ICONS.invisibility);
                if (player.sizeEffect) container.innerHTML += smallIcon(ICONS[player.sizeEffect]);
                if (player.speedMultiplier !== 1.0) container.innerHTML += smallIcon(player.speedMultiplier > 1 ? ICONS.speedBoost : ICONS.slow);
                if (player.cannotEatUntil && Date.now() < player.cannotEatUntil) container.innerHTML += smallIcon(ICONS.cannotEat);
                if (player.snaredUntil && Date.now() < player.snaredUntil) container.innerHTML += smallIcon(ICONS.snare);
                if (player.hasSpikeWallImmunity) container.innerHTML += smallIcon(ICONS.wallSpikes);
                if (player.balls.length > 1) container.innerHTML += `<span class="text-sm font-bold text-purple-400">x${player.balls.length}</span>`;
            };
            addIcons(players[0], p1_icons);
            addIcons(players[1], p2_icons);
        }
        
        function getRandomPosition(radius) { return { x: Math.random() * (canvas.width - radius * 2) + radius, y: Math.random() * (canvas.height - radius * 2) + radius } }
        function triggerEffect(x, y, color, { count = 20, speed = 3, life = 40, friction = 0.95 } = {}) { for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const currentSpeed = Math.random() * speed + 1; particles.push(new Particle( x, y, Math.cos(angle) * currentSpeed, Math.sin(angle) * currentSpeed, Math.random() * 2 + 1, color, life, friction )); } }
        function spawnItem(type) { if (type === 'shield' || type === 'weapon') {
        const isHeld = players.some(p => p.armor.includes(type));
        if (isHeld) return; // Nếu có người chơi đang giữ thì không tạo ra
    };
			if (items[type] && items[type].item) return; const radius = canvas.width / 40; const pos = getRandomPosition(radius); let duration = null; if (type === 'health') duration = 7000; if (type === 'bomb' || type === 'snare_trap') duration = 5000; items[type].item = new Item(pos.x, pos.y, radius, type, items[type].owner, duration); items[type].cooldownEndTime = null; if (duration) { clearTimeout(itemDisappearTimeouts[type]); itemDisappearTimeouts[type] = setTimeout(() => { if (items[type] && items[type].item) { items[type].item = null; const respawnTime = items[type].currentRespawn; items[type].cooldownEndTime = Date.now() + respawnTime; itemSpawnTimeouts.push(setTimeout(() => spawnItem(type), respawnTime)); } }, duration); } }
        function updatePlayerVelocity(playerBall) { const mag = Math.hypot(playerBall.dx, playerBall.dy); if (mag > 0) { playerBall.dx = (playerBall.dx / mag) * playerBall.speed; playerBall.dy = (playerBall.dy / mag) * playerBall.speed; } }
        const getAllPlayerBalls = () => players.flatMap(p => p.balls);

        function handleDiagonalWallCollision(ball) { if (!activeDiagonalWall) return; const p1 = activeDiagonalWall.p1; const p2 = activeDiagonalWall.p2; const p1_to_player = { x: ball.x - p1.x, y: ball.y - p1.y }; const p1_to_p2 = { x: p2.x - p1.x, y: p2.y - p1.y }; const len_p1_p2_sq = p1_to_p2.x * p1_to_p2.x + p1_to_p2.y * p1_to_p2.y; const dot = p1_to_player.x * p1_to_p2.x + p1_to_player.y * p1_to_p2.y; const t = Math.max(0, Math.min(1, dot / len_p1_p2_sq)); const closestPoint = { x: p1.x + t * p1_to_p2.x, y: p1.y + t * p1_to_p2.y }; const distSq = (ball.x - closestPoint.x)**2 + (ball.y - closestPoint.y)**2; if (distSq < ball.radius**2) { const dist = Math.sqrt(distSq); const overlap = ball.radius - dist; if (dist > 0) { ball.x += overlap * (ball.x - closestPoint.x) / dist; ball.y += overlap * (ball.y - closestPoint.y) / dist; } const v = { x: ball.dx, y: ball.dy }; const n = { ...activeDiagonalWall.normal }; const side_check = (ball.x - p1.x) * n.y - (ball.y - p1.y) * n.x; if (side_check > 0) { n.x *= -1; n.y *= -1; } const dot_v_n = v.x * n.x + v.y * n.y; ball.dx = v.x - 2 * dot_v_n * n.x; ball.dy = v.y - 2 * dot_v_n * n.y; activeDiagonalWall.hits--; triggerEffect(closestPoint.x, closestPoint.y, ITEM_COLORS.diagonalWall, { count: 10, speed: 2 }); if (activeDiagonalWall.hits <= 0) { triggerEffect(closestPoint.x, closestPoint.y, ITEM_COLORS.diagonalWall, { count: 30, speed: 5 }); activeDiagonalWall = null; } } }
        function handleWallCollisions(ball) { const now = Date.now(); let bounced = false; if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) { ball.dx = -ball.dx; bounced = true; } if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) { ball.dy = -ball.dy; bounced = true; } ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x)); ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y)); if (activeSpikeWall && bounced) { const sideHit = (ball.x - ball.radius <= 1 && activeSpikeWall.side === 'left') || (ball.x + ball.radius >= canvas.width - 1 && activeSpikeWall.side === 'right') || (ball.y - ball.radius <= 1 && activeSpikeWall.side === 'top') || (ball.y + ball.radius >= canvas.height - 1 && activeSpikeWall.side === 'bottom'); if (sideHit) { if (ball.controller !== activeSpikeWall.owner) { ball.controller.takeDamage(ball); triggerEffect(ball.x, ball.y, ITEM_COLORS.wallSpikes, { count: 20, speed: 5 }); activeSpikeWall = null; updatePlayerStatusUI(); } } } }
        
        function handleCollisions() {
            const allBalls = getAllPlayerBalls();
            for (let i = 0; i < allBalls.length; i++) {
                for (let j = i + 1; j < allBalls.length; j++) {
                    const b1 = allBalls[i]; const b2 = allBalls[j];
                    if (b1.controller === b2.controller) continue;
                    const dist = Math.hypot(b1.x - b2.x, b1.y - b2.y);
                    if (dist < b1.radius + b2.radius) {
                        const overlap = b1.radius + b2.radius - dist;
                        const nx = (b2.x - b1.x) / dist; const ny = (b2.y - b1.y) / dist;

                        // Position correction based on snare state
                        if (!b1.isSnared && !b2.isSnared) {
                            b1.x -= overlap / 2 * nx; b1.y -= overlap / 2 * ny;
                            b2.x += overlap / 2 * nx; b2.y += overlap / 2 * ny;
                        } else if (b1.isSnared && !b2.isSnared) {
                            b2.x += overlap * nx; b2.y += overlap * ny;
                        } else if (!b1.isSnared && b2.isSnared) {
                            b1.x -= overlap * nx; b1.y -= overlap * ny;
                        }

                        const tx = -ny; const ty = nx;
                        const dpTan1 = b1.dx * tx + b1.dy * ty;
                        const dpTan2 = b2.dx * tx + b2.dy * ty;
                        const dpNorm1 = b1.dx * nx + b1.dy * ny;
                        const dpNorm2 = b2.dx * nx + b2.dy * ny;
                        
                        // Velocity change, snared balls are like immovable objects
                        if (!b1.isSnared) {
                            b1.dx = tx * dpTan1 + nx * dpNorm2;
                            b1.dy = ty * dpTan1 + ny * dpNorm2;
                        }
                        if (!b2.isSnared) {
                            b2.dx = tx * dpTan2 + nx * dpNorm1;
                            b2.dy = ty * dpTan2 + ny * dpNorm1;
                        }
                        
                        updatePlayerVelocity(b1); 
                        updatePlayerVelocity(b2);

                        const b1HasGai = b1.controller.armor.includes('weapon');
const b2HasGai = b2.controller.armor.includes('weapon');

// Hàm trợ giúp để bắt đầu hồi chiêu Gai
const startWeaponCooldown = () => {
    const weaponData = items['weapon'];
    if (weaponData) {
        weaponData.cooldownEndTime = Date.now() + weaponData.currentRespawn;
        itemSpawnTimeouts.push(setTimeout(() => spawnItem('weapon'), weaponData.currentRespawn));
    }
};

if (b1HasGai) {
    b2.controller.takeDamage(b2, b1.controller);
    const b1GaiIndex = b1.controller.armor.lastIndexOf('weapon');
    if (b1GaiIndex > -1) {
        b1.controller.armor.splice(b1GaiIndex, 1);
        clearTimeout(b1.controller.effectTimeouts.weapon);
        startWeaponCooldown(); // Bắt đầu hồi chiêu khi vũ khí được dùng
    }
}
if (b2HasGai) {
    b1.controller.takeDamage(b1, b2.controller);
    const b2GaiIndex = b2.controller.armor.lastIndexOf('weapon');
    if (b2GaiIndex > -1) {
        b2.controller.armor.splice(b2GaiIndex, 1);
        clearTimeout(b2.controller.effectTimeouts.weapon);
        startWeaponCooldown(); // Bắt đầu hồi chiêu khi vũ khí được dùng
    }
}
                        updateLivesUI();
                    }
                }
                 const ball = allBalls[i];
                 for (const type in items) {
                    const itemData = items[type];
                    if (itemData.item && Math.hypot(ball.x - itemData.item.x, ball.y - itemData.item.y) < ball.radius + itemData.item.radius) {
                        handleItemPickup(ball, type);
                    }
                }
            }
        }

        const ITEM_PICKUP_LOGIC = {
            weapon: (ball) => { 
                const player = ball.controller;
                clearTimeout(player.effectTimeouts.weapon); // Luôn làm mới thời gian

                if (!player.armor.includes('weapon')) {
                    player.armor.push('weapon'); // Chỉ thêm nếu chưa có
                }
                
                player.effectTimeouts.weapon = setTimeout(() => {
                    const index = player.armor.indexOf('weapon');
                    if (index > -1) {
                        player.armor.splice(index, 1);
                        updateLivesUI();
                    }
                }, 5000); // 5 seconds
                updateLivesUI(); 
                return true; 
            },
            health: (ball) => { if (ball.controller.lives < 5) { ball.controller.lives++; updateLivesUI(); return true; } return false; },
            bomb: (ball) => { 
                const radius = canvas.width / 40; 
                const pos = getRandomPosition(radius); 
                // Tạo một bẫy bom tạm thời trên bản đồ
                items['bomb_trap'] = { 
                    item: new Item(pos.x, pos.y, radius, 'bomb_trap', ball.controller, 7000) // 7 giây tồn tại
                };
                return true; 
            },
            bomb_trap: (ball, itemData) => {
                const trapOwner = itemData.item.owner;
                const steppingPlayer = ball.controller;

                let trigger = false;
                if (trapOwner === 'neutral') { // Bom chung
                    trigger = true;
                } else if (steppingPlayer !== trapOwner) { // Bom của đối thủ
                    trigger = true;
                }

                if (trigger) {
                    const bombPos = { x: itemData.item.x, y: itemData.item.y };
                    triggerEffect(bombPos.x, bombPos.y, ITEM_COLORS.bomb, { count: 40, speed: 7, life: 60 });
                    steppingPlayer.takeDamage(ball, trapOwner === 'neutral' ? null : trapOwner);
                    return true; // Kích hoạt và xóa bom
                }
                return false; // Người đặt dẫm phải, không có gì xảy ra
            },
            shield: (ball) => { 
                if (ball.controller.armor.includes('shield')) {
                    return false; // Đã có khiên, không nhặt thêm
                }
                ball.controller.armor.push('shield'); 
                updateLivesUI(); 
                return true; 
            },
            reflectiveCloak: (ball) => { ball.controller.applyEffect('reflectiveCloak', 10000); return true; },
            snare: (ball) => { 
                const opponent = players.find(p => p !== ball.controller);
                if (opponent) {
                     const radius = canvas.width / 40; 
                     const pos = getRandomPosition(radius); 
                     items['snare_trap'] = { item: new Item(pos.x, pos.y, radius, 'snare_trap', ball.controller, 5000) };
                }
                return true; 
            },
            snare_trap: (ball, itemData) => {
                const trapOwner = itemData.item.owner;
                const steppingPlayer = ball.controller;

                let trigger = false;
                if (trapOwner === 'neutral') {
                    // Bẫy chung tác dụng lên mọi người chơi
                    trigger = true;
                } else if (steppingPlayer !== trapOwner) {
                    // Bẫy riêng chỉ tác dụng lên đối thủ
                    trigger = true;
                }

                if (trigger) {
                    steppingPlayer.applyEffect('snare', 3000); // 3 giây
                    return true; 
                }
                
                return false;
            },
            grow: (ball) => { const opponent = players.find(p => p !== ball.controller); if (opponent) opponent.applyEffect('size', 10000, 'grow'); return true; },
            shrink: (ball) => { 
                ball.controller.applyEffect('size', 10000, 'shrink'); 
                // Thêm setTimeout riêng cho việc hồi chiêu
                setTimeout(() => {
                    const itemData = items['shrink'];
                    if (itemData) {
                        const respawnTime = itemData.currentRespawn;
                        itemData.cooldownEndTime = Date.now() + respawnTime;
                        itemSpawnTimeouts.push(setTimeout(() => spawnItem('shrink'), respawnTime));
                    }
                }, 10000);
                return true; 
            },
            speedBoost: (ball) => { 
                ball.controller.applyEffect('speed', 5000, 1.5);
                // Thêm setTimeout riêng cho việc hồi chiêu
                setTimeout(() => {
                    const itemData = items['speedBoost'];
                    if (itemData) {
                        const respawnTime = itemData.currentRespawn;
                        itemData.cooldownEndTime = Date.now() + respawnTime;
                        itemSpawnTimeouts.push(setTimeout(() => spawnItem('speedBoost'), respawnTime));
                    }
                }, 5000);
                return true; 
            },
            
            slow: (ball) => { const opponent = players.find(p => p !== ball.controller); if (opponent) opponent.applyEffect('speed', 5000, 0.5); return true; },
            rain: (ball) => { const rainRadius = (ball.baseRadius) * 5; const pos = getRandomPosition(rainRadius); activeRainZone = new RainZone(pos.x, pos.y, rainRadius, ball.controller); return true; },
            invisibility: (ball) => { 
                ball.controller.invincibleUntil = Date.now() + 3000; 
                // Thêm setTimeout để bắt đầu hồi chiêu sau khi hết 3 giây tàng hình
                setTimeout(() => {
                    const itemData = items['invisibility'];
                    if (itemData) {
                        const respawnTime = itemData.currentRespawn;
                        itemData.cooldownEndTime = Date.now() + respawnTime;
                        itemSpawnTimeouts.push(setTimeout(() => spawnItem('invisibility'), respawnTime));
                    }
                }, 3000);
                return true; 
            },
            wallSpikes: (ball) => { const sides = ['top', 'right', 'bottom', 'left']; activeSpikeWall = { side: sides[Math.floor(Math.random() * 4)], owner: ball.controller }; return true; },
            diagonalWall: (ball) => { if (activeDiagonalWall) return false; activeDiagonalWall = new DiagonalWall(); return true; },
            clone: (ball) => { ball.controller.addBall(); return true; },
            cannotEat: (ball) => { const opponent = players.find(p => p !== ball.controller); if (opponent) opponent.applyEffect('cannotEat', 5000); return true; },
            laserGun: (ball) => { if(activeLaser) return false; const owner = ball.controller; const opponent = players.find(p => p !== owner); if (!opponent || opponent.balls.length === 0) return false; const targetBall = opponent.balls[0]; const dir = { x: targetBall.x - ball.x, y: targetBall.y - ball.y }; const mag = Math.hypot(dir.x, dir.y); if (mag > 0) { dir.x /= mag; dir.y /= mag; } else { dir.x = Math.random() - 0.5; dir.y = Math.random() - 0.5; } activeLaser = new Laser({ x: ball.x, y: ball.y }, dir, owner); return true; },
            homingMissile: (ball) => { if(activeMissile) return false; const owner = ball.controller; const opponent = players.find(p => p !== owner); if (opponent) { activeMissile = new HomingMissile(owner, opponent); } return true;}
        };

        function handleItemPickup(ball, type) { 
            const itemData = items[type]; 
            if (!itemData || !itemData.item || (ball.controller.cannotEatUntil && Date.now() < ball.controller.cannotEatUntil)) return; 
            
            // Lấy chủ sở hữu từ item object, vì itemData.owner có thể là người chơi controller
            const itemOwner = itemData.item.owner; 

            const configType = ITEM_CONFIG[type] ? ITEM_CONFIG[type].type : 'trap';
            if (configType === 'buff' && itemOwner !== 'neutral' && itemOwner !== ball.controller) return; 
            if ((configType === 'debuff' || configType === 'map_effect') && itemOwner !== 'neutral' && itemOwner !== ball.controller) return; 
            const logic = ITEM_PICKUP_LOGIC[type]; 
            if (!logic) return; 
            const pickupSuccessful = logic(ball, itemData); 
            if (pickupSuccessful) { 
                triggerEffect(ball.x, ball.y, ITEM_COLORS[type], { count: 15, speed: 2, life: 25 }); 
                const respawnTime = itemData.currentRespawn; 
                if (itemData.item.disappearTime) clearTimeout(itemDisappearTimeouts[type]); 
                itemData.item = null; 
				
 const cooldownOnExpireItems = ['shield', 'weapon', 'reflectiveCloak', 'shrink', 'speedBoost', 'invisibility'];

                // Chỉ bắt đầu hồi chiêu ngay lập tức cho các vật phẩm KHÔNG có trong danh sách trên
                if (respawnTime && !cooldownOnExpireItems.includes(type)) {
                    itemData.cooldownEndTime = Date.now() + respawnTime; 
                    itemSpawnTimeouts.push(setTimeout(() => spawnItem(type), respawnTime)); 
                }
                if ((type === 'bomb_trap' || type === 'snare_trap') && ball.controller.lives <= 0) {
                    triggerDeath(ball.controller);
                }
            } 
            updatePlayerStatusUI(); 
        }
        
        function updateCooldownUI() {
            const neutralDiv = document.getElementById('neutral-cooldown-timers');
            const p1Div = document.getElementById('player1-cooldown-timers');
            const p2Div = document.getElementById('player2-cooldown-timers');
            
            if (!neutralDiv || !p1Div || !p2Div) return;

            let neutralHtml = '', p1Html = '', p2Html = '';

            const createTimerCircle = (type) => {
                const itemData = items[type];
                if (!itemData || !ITEM_CONFIG[type]) return ''; // Bỏ qua các item tạm thời như snare_trap
                const radius = 16;
                const circumference = 2 * Math.PI * radius;
                const endTime = itemData.cooldownEndTime;
                const baseTime = (itemData.initialCooldownUsed) ? itemData.currentRespawn : INITIAL_SPAWN_TIME;
                let textContent = '';
                let strokeDashoffset = circumference;
                
                const ownerColor = itemData.owner === players[0] ? '#3b82f6' : (itemData.owner === players[1] ? '#ef4444' : '#a0aec0');
                if (endTime && Date.now() < endTime) {
                    const remaining = endTime - Date.now();
                    const progress = Math.max(0, remaining / baseTime);
                    strokeDashoffset = circumference * progress;
                    textContent = Math.ceil(remaining / 1000);
                } else {
                    strokeDashoffset = 0;
                }
                return ` <div class="cooldown-circle"> <svg class="w-full h-full"> <circle cx="18" cy="18" r="${radius}" stroke="#4a5568" stroke-width="3" fill="none" /> <circle cx="18" cy="18" r="${radius}" stroke="${ownerColor}" stroke-width="3" fill="none" stroke-dasharray="${circumference}" stroke-dashoffset="${strokeDashoffset}" style="transition: stroke-dashoffset 0.25s linear;" /> </svg> <div class="icon">${!textContent ? ICONS[type].replace('h-8 w-8', 'h-5 w-5') : ''}</div> <div class="text">${textContent}</div> </div> `;
            };
            
            Object.keys(items).forEach(type => {
                const itemData = items[type];
                if (!itemData || !ITEM_CONFIG[type]) return;
                const circleHtml = createTimerCircle(type);

                if (itemData.owner === 'neutral') {
                    neutralHtml += circleHtml;
                } else if (players[0] && itemData.owner === players[0]) {
                    p1Html += circleHtml;
                } else if (players[1] && itemData.owner === players[1]) {
                    p2Html += circleHtml;
                }
            });

            neutralDiv.innerHTML = neutralHtml;
            p1Div.innerHTML = p1Html;
            p2Div.innerHTML = p2Html;
        }
        function calculateCurrentMultiplier(remainingTime) { const stage2Start = 45000; const stage3Start = 15000; const stage4Start = 5000; if (remainingTime > stage2Start) { const progress = (TOTAL_GAME_TIME - remainingTime) / (TOTAL_GAME_TIME - stage2Start); return 1 + progress; } else if (remainingTime > stage3Start) { const progress = (stage2Start - remainingTime) / (stage2Start - stage3Start); return 2 + progress; } else if (remainingTime > stage4Start) { const progress = (stage3Start - remainingTime) / (stage3Start - stage4Start); return 3 + progress; } else { return 4; } }
        
        function drawTimer() { const remaining = Math.max(0, gameEndTime - Date.now()); const remainingPercent = remaining / TOTAL_GAME_TIME; if (remaining > 0) { let color = 'rgba(255, 255, 255, 0.08)'; if(remaining <= 5000) color = 'rgba(239, 68, 68, 0.2)'; else if(remaining <= 15000) color = 'rgba(239, 68, 68, 0.15)'; else if(remaining <= 45000) color = 'rgba(239, 68, 68, 0.1)'; ctx.fillStyle = color; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#2d3748'; const wipeHeight = canvas.height * (1 - remainingPercent); ctx.fillRect(0, 0, canvas.width, wipeHeight); } const seconds = Math.ceil(remaining / 1000); ctx.font = `bold ${canvas.width / 4}px Arial`; ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(seconds, canvas.width / 2, canvas.height / 2); }
        function drawSpikeWall() { if (!activeSpikeWall) return; ctx.fillStyle = ITEM_COLORS.wallSpikes; const spikeSize = canvas.width / 40; const numSpikes = Math.floor(canvas.width / spikeSize); for (let i = 0; i < numSpikes; i++) { const pos = i * spikeSize + spikeSize / 2; ctx.beginPath(); if (activeSpikeWall.side === 'top') { ctx.moveTo(pos - spikeSize / 2, 0); ctx.lineTo(pos, spikeSize); ctx.lineTo(pos + spikeSize / 2, 0); } else if (activeSpikeWall.side === 'bottom') { ctx.moveTo(pos - spikeSize / 2, canvas.height); ctx.lineTo(pos, canvas.height - spikeSize); ctx.lineTo(pos + spikeSize / 2, canvas.height); } else if (activeSpikeWall.side === 'left') { ctx.moveTo(0, pos - spikeSize / 2); ctx.lineTo(spikeSize, pos); ctx.lineTo(0, pos + spikeSize / 2); } else if (activeSpikeWall.side === 'right') { ctx.moveTo(canvas.width, pos - spikeSize / 2); ctx.lineTo(canvas.width - spikeSize, pos); ctx.lineTo(canvas.width, pos + spikeSize / 2); } ctx.fill(); } }

        function gameLoop() {
            if (!animationFrameId) return; // Game đã dừng, không chạy nữa
            const remaining = Math.max(0, gameEndTime - Date.now());
            const currentMultiplier = calculateCurrentMultiplier(remaining);
            for (const type in items) { if(items[type] && items[type].baseRespawn) items[type].currentRespawn = items[type].baseRespawn / currentMultiplier; }
            getAllPlayerBalls().forEach(b => { b.speed = b.baseSpeed * currentMultiplier * b.controller.speedMultiplier; updatePlayerVelocity(b); });
            if (remaining <= 0) { endGame(true); return; }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawTimer();
            drawSpikeWall();
            if(activeDiagonalWall) activeDiagonalWall.draw();
            if(activeRainZone) { activeRainZone.draw(); activeRainZone.update(); }
            if(activeLaser) {
                activeLaser.draw();
                const opponent = players.find(p => p !== activeLaser.owner);
                if (opponent) { opponent.balls.forEach(ball => { if (activeLaser && activeLaser.checkCollision(ball)) { opponent.takeDamage(ball, activeLaser.owner); activeLaser = null; } }); }
                if (activeLaser && Date.now() > activeLaser.endTime) activeLaser = null;
            }
            if(activeMissile) { activeMissile.draw(); activeMissile.update(); }
            getAllPlayerBalls().forEach(ball => { ball.update(); });
            getAllPlayerBalls().forEach(handleWallCollisions);
            getAllPlayerBalls().forEach(handleDiagonalWallCollision);
            handleCollisions();
            getAllPlayerBalls().forEach(ball => ball.draw());
            for (const type in items) if(items[type] && items[type].item) items[type].item.draw();
            particles.forEach((p, index) => { p.update(); p.draw(); if (p.life <= 0) particles.splice(index, 1); });
            updateCooldownUI(); updatePlayerStatusUI();
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        let effectLoopId = null;
        function pauseGameForEffect({duration, shake = 0}) {
            if (!animationFrameId) return;
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;

            let startTime = Date.now();
            let shakeX = 0, shakeY = 0;

            function effectLoop() {
                const elapsed = Date.now() - startTime;
                if(elapsed > duration) {
                    canvas.style.transform = '';
                    animationFrameId = requestAnimationFrame(gameLoop); // Resume game
                    return;
                }
                if (shake > 0) {
                    shakeX = (Math.random() - 0.5) * shake * (1 - elapsed/duration);
                    shakeY = (Math.random() - 0.5) * shake * (1 - elapsed/duration);
                    canvas.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
                }
                 effectLoopId = requestAnimationFrame(effectLoop);
            }
            effectLoop();
        }

        function triggerDeath(deadPlayerController) { 
            const winner = players.find(p => p !== deadPlayerController);
            const lastBall = deadPlayerController.balls[0] || {x: canvas.width / 2, y: canvas.height/2}; 
            triggerEffect(lastBall.x, lastBall.y, deadPlayerController.color, { count: 50, speed: 8, friction: 0.98, life: 80 }); 
            endGame(false, winner);
        }
       
        function stopGame() {
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            if (effectLoopId) { cancelAnimationFrame(effectLoopId); effectLoopId = null; }
            itemSpawnTimeouts.forEach(clearTimeout);
            itemSpawnTimeouts = [];
            Object.values(itemDisappearTimeouts).forEach(clearTimeout);
        }

        // Hàm endGame đã được cập nhật
function endGame(isTimeUp = false, winnerPlayer = null) {
	requestWakeLock();
    stopGame();
    gameOverScreen.classList.remove('hidden'); 
    document.getElementById('top-ui').classList.add('invisible');
    document.getElementById('bottom-ui').classList.add('invisible');
    
    let winner = ''; 
    const p1 = players.find(p => p.name === 'Người chơi 1'); 
    const p2 = players.find(p => p.name === 'Người chơi 2'); 
    const p1Lives = p1 ? Math.max(0, p1.lives) : 0; 
    const p2Lives = p2 ? Math.max(0, p2.lives) : 0;
    const p1Score = p1 ? p1.score : 0;
    const p2Score = p2 ? p2.score : 0;

    // Ưu tiên 1: Người thắng được xác định trước (do đủ 5 điểm hoặc hạ hết mạng đối thủ)
    if (winnerPlayer) {
         winner = winnerPlayer.name === 'Người chơi 1' ? 'p1' : 'p2';
    } 
    // Ưu tiên 2: Hết giờ thì xét điểm trước, sau đó tới mạng
    else if (isTimeUp) { 
        if (p1Score > p2Score) {
            winner = 'p1';
        } else if (p2Score > p1Score) {
            winner = 'p2';
        } else { // Nếu điểm bằng nhau, xét mạng
            if (p1Lives > p2Lives) winner = 'p1'; 
            else if (p2Lives > p1Lives) winner = 'p2'; 
            else winner = 'draw'; // Bằng cả điểm và mạng thì hòa
        }
    }
   
    winnerText.className = 'text-4xl font-bold mb-4';
    if (winner === 'p1') { 
        winnerText.textContent = `Người chơi 1 chiến thắng!`; 
        winnerText.classList.add('text-blue-500'); 
    } else if (winner === 'p2') { 
        winnerText.textContent = `Người chơi 2 chiến thắng!`; 
        winnerText.classList.add('text-red-500'); 
    } else { 
        winnerText.textContent = `Hòa!`; 
    }
    
    // Cập nhật bảng kết quả để hiển thị cả điểm và mạng
    const resultsDiv = document.getElementById('results-details');
    resultsDiv.innerHTML = `
        <div class="flex justify-around items-center text-center">
            <div class="p-4 bg-gray-800 rounded-lg w-2/5">
                <p class="font-bold text-blue-500">Người chơi 1</p>
                <p>Điểm: <span class="font-bold text-2xl">${p1Score}</span></p>
                <p class="text-sm">Mạng còn lại: <span class="font-bold">${p1Lives}</span></p>
            </div>
            <div class="text-2xl font-bold px-2">VS</div>
            <div class="p-4 bg-gray-800 rounded-lg w-2/5">
                <p class="font-bold text-red-500">Người chơi 2</p>
                <p>Điểm: <span class="font-bold text-2xl">${p2Score}</span></p>
                <p class="text-sm">Mạng còn lại: <span class="font-bold">${p2Lives}</span></p>
            </div>
        </div>
    `;
}
        
        function init() {
			requestWakeLock();
            stopGame();
            setCanvasSize();
            players = [];
            items = {};
            startScreen.classList.remove('hidden');
            banPickScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            document.getElementById('top-ui').classList.add('invisible');
            document.getElementById('bottom-ui').classList.add('invisible');
            winnerText.textContent = ''; winnerText.className = 'text-4xl font-bold mb-4';
            particles = []; activeRainZone = null; activeSpikeWall = null; activeDiagonalWall = null; activeLaser = null; activeMissile = null;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = `bold ${canvas.width / 10}px Arial`; ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("Sẵn Sàng...", canvas.width / 2, canvas.height / 2);
        }

        function showBanPickPhase() {
            startScreen.classList.add('hidden');
            banPickScreen.classList.remove('hidden');
            banPickState = { currentIndex: 0, p1Bans: [], p2Bans: [], p1Picks: [], p2Picks: [], selectionCandidate: null };
            
            const bannableItems = Object.keys(ITEM_CONFIG).filter(type => ITEM_CONFIG[type].type !== 'neutral');

            const itemGroups = { buff: [], debuff: [], map_effect: [] };
            bannableItems.forEach(type => {
                const itemType = ITEM_CONFIG[type].type;
                if (itemGroups[itemType]) {
                    itemGroups[itemType].push(type);
                }
            });
            const sortedItems = [...itemGroups.buff.sort(), ...itemGroups.debuff.sort(), ...itemGroups.map_effect.sort()];

            const grid = document.getElementById('ban-pick-grid');
            grid.innerHTML = '';
            sortedItems.forEach(type => {
                const itemDiv = document.createElement('div');
                itemDiv.id = `bp-item-${type}`;
                itemDiv.className = 'ban-pick-item selectable';
                let typeIcon = '';
                if(ITEM_CONFIG[type].type === 'buff') typeIcon = `<div class="type-icon text-green-400">▲</div>`
                else if (ITEM_CONFIG[type].type === 'debuff') typeIcon = `<div class="type-icon text-red-400">▼</div>`
                else if (ITEM_CONFIG[type].type === 'map_effect') typeIcon = `<div class="type-icon text-yellow-400">♦</div>`
                
                itemDiv.innerHTML = `${ICONS[type]}${typeIcon}<div class="overlay">/</div>`;

                const isTouchDevice = 'ontouchstart' in window;
                if (isTouchDevice) {
                    itemDiv.addEventListener('click', () => handleBanPickSelection(type));
                } else {
                    itemDiv.onclick = () => handleBanPickSelection(type);
                    itemDiv.onmouseenter = (e) => showTooltip(e, type);
                    itemDiv.onmouseleave = hideTooltip;
                }
                grid.appendChild(itemDiv);
            });
            updateBanPickUI();
        }
        
        function showTooltip(event, type) {
            const item = ITEM_CONFIG[type];
            let statsHTML = `<p class="text-gray-400 text-sm mt-1">Hồi chiêu: ${item.baseRespawn / 1000}s</p>`;
            if (item.stats && Object.keys(item.stats).length > 0) {
                statsHTML += `<div class="mt-2 border-t border-gray-600 pt-2">`;
                for (const [key, value] of Object.entries(item.stats)) {
                    statsHTML += `<p class="text-sm"><span class="font-semibold text-gray-300">${key}:</span> ${value}</p>`;
                }
                statsHTML += `</div>`;
            }
            tooltip.innerHTML = `<h4 class="font-bold mb-1">${item.name}</h4><p class="text-gray-400">${item.desc}</p>${statsHTML}`;
            tooltip.style.opacity = '1';
            
            const tooltipRect = tooltip.getBoundingClientRect();
            const margin = 15;
            let left = event.clientX + margin;
            let top = event.clientY + margin;

            if (left + tooltipRect.width > window.innerWidth) {
                left = event.clientX - tooltipRect.width - margin;
            }
            if (top + tooltipRect.height > window.innerHeight) {
                top = event.clientY - tooltipRect.height - margin;
            }
            if (left < 0) left = margin;
            if (top < 0) top = margin;
            
            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }
        function hideTooltip() { tooltip.style.opacity = '0'; }
        
        function updateBanPickUI() {
            const title = document.getElementById('ban-pick-title');
            const mobileInfo = document.getElementById('ban-pick-info-mobile');
            const p1PicksDiv = document.getElementById('p1-picks');
            const p2PicksDiv = document.getElementById('p2-picks');
            const p1BansDiv = document.getElementById('p1-bans');
            const p2BansDiv = document.getElementById('p2-bans');
            
            document.querySelectorAll('.pulsing-slot').forEach(el => el.classList.remove('pulsing-slot'));
            document.querySelectorAll('.border-yellow-400').forEach(el => el.classList.remove('border-yellow-400'));

            const renderSlots = (container, items, maxSlots, isBan = false) => {
                container.innerHTML = '';
                for (let i = 0; i < maxSlots; i++) {
                    let content = '';
                    if (items[i]) {
                        content = ICONS[items[i]].replace('h-8 w-8', 'h-full w-full');
                        if (isBan) {
                            content += '<div class="absolute inset-0 bg-red-800 bg-opacity-70 flex items-center justify-center text-white text-3xl font-bold">/</div>';
                        }
                    }
                    const banClass = isBan ? 'p-1 aspect-square bg-gray-900 border-2 border-gray-700 rounded flex justify-center items-center relative' : 'p-1 aspect-square bg-gray-900 border-2 border-dashed border-gray-700 rounded flex justify-center items-center';
                    container.innerHTML += `<div class="${banClass}">${content}</div>`;
                }
            };

            renderSlots(p1BansDiv, banPickState.p1Bans, 2, true);
            renderSlots(p2BansDiv, banPickState.p2Bans, 2, true);
            renderSlots(p1PicksDiv, banPickState.p1Picks, 3);
            renderSlots(p2PicksDiv, banPickState.p2Picks, 3);

            const currentStep = banPickSequence[banPickState.currentIndex];
            if (currentStep) {
                const isP1 = currentStep.player === 1;
                const phaseText = currentStep.phase === 'ban' ? 'Cấm' : 'Chọn';
                title.className = 'text-2xl md:text-3xl font-bold';
                title.classList.add(isP1 ? 'text-blue-500' : 'text-red-500');
                title.textContent = `Người chơi ${currentStep.player} - ${phaseText}`;

                const container = currentStep.phase === 'ban' ? (isP1 ? p1BansDiv : p2BansDiv) : (isP1 ? p1PicksDiv : p2PicksDiv);
                const itemsList = currentStep.phase === 'ban' ? (isP1 ? banPickState.p1Bans : banPickState.p2Bans) : (isP1 ? banPickState.p1Picks : banPickState.p2Picks);
                const maxItems = currentStep.phase === 'ban' ? 2 : 3;

                if (itemsList.length < maxItems) {
                    const slot = container.children[itemsList.length];
                    if(slot) slot.classList.add('pulsing-slot');
                }
            }
            const isTouchDevice = 'ontouchstart' in window;
            if (isTouchDevice && banPickState.selectionCandidate) {
                const item = ITEM_CONFIG[banPickState.selectionCandidate];
                
                let statsParts = [];
                statsParts.push(`⏳ ${item.baseRespawn / 1000}s`);

                if (item.stats) {
                    for (const [key, value] of Object.entries(item.stats)) {
                        let icon = '🔹'; // Default icon
                        if (key.toLowerCase().includes('thời gian')) icon = '⏱️';
                        if (key.toLowerCase().includes('hiệu ứng')) icon = '✨';
                        if (key.toLowerCase().includes('sát thương')) icon = '💥';
                        if (key.toLowerCase().includes('hồi phục')) icon = '💚';
                        if (key.toLowerCase().includes('kích thước')) icon = '📏';
                        if (key.toLowerCase().includes('tốc độ')) icon = '⚡️';
                        if (key.toLowerCase().includes('độ bền')) icon = '🛠️';
                        
                        statsParts.push(`${icon} ${value}`);
                    }
                }
                
                const statsHTML = `<div class="mt-2 pt-2 border-t border-gray-700 text-sm text-gray-300">${statsParts.join(' • ')}</div>`;
                
                mobileInfo.innerHTML = `
                    <p class="font-bold text-lg">${item.name}</p>
                    <p class="text-xs text-gray-400 mb-1">${item.desc}</p>
                    ${statsHTML}
                `;

                mobileInfo.classList.remove('hidden');
                title.classList.add('hidden');
            } else {
                mobileInfo.classList.add('hidden');
                title.classList.remove('hidden');
            }

            const banned = [...banPickState.p1Bans, ...banPickState.p2Bans];
            document.querySelectorAll('.ban-pick-item').forEach(el => {
                const type = el.id.replace('bp-item-', '');
                el.classList.remove('banned', 'picked-p1', 'picked-p2', 'selectable', 'opacity-50');
                if(banPickState.selectionCandidate === type) el.classList.add('border-yellow-400');
                if (banned.includes(type)) el.classList.add('banned');
                else if (banPickState.p1Picks.includes(type)) el.classList.add('picked-p1');
                else if (banPickState.p2Picks.includes(type)) el.classList.add('picked-p2');
                else el.classList.add('selectable');
            });
        }
        
        function handleBanPickSelection(type) {
            const currentStep = banPickSequence[banPickState.currentIndex];
            if (!currentStep) return;

            const banned = [...banPickState.p1Bans, ...banPickState.p2Bans];
            const picked = [...banPickState.p1Picks, ...banPickState.p2Picks];
            if (banned.includes(type) || picked.includes(type)) return;

            if (banPickState.selectionCandidate === type) { // Confirm selection
                if (currentStep.phase === 'ban') {
                    if (currentStep.player === 1) banPickState.p1Bans.push(type);
                    else banPickState.p2Bans.push(type);
                } else { // Pick
                    if (currentStep.player === 1) banPickState.p1Picks.push(type);
                    else banPickState.p2Picks.push(type);
                }
                banPickState.currentIndex++;
                banPickState.selectionCandidate = null;

                if (banPickState.currentIndex >= banPickSequence.length) {
                    finalizeSelectionsAndStart();
                } else {
                    updateBanPickUI();
                }
            } else { // First selection
                banPickState.selectionCandidate = type;
                updateBanPickUI();
            }
        }
        
        function finalizeSelectionsAndStart() {
            banPickScreen.classList.add('hidden');
            const allItems = Object.keys(ITEM_CONFIG);
            const banned = [...banPickState.p1Bans, ...banPickState.p2Bans];
            const picked = [...banPickState.p1Picks, ...banPickState.p2Picks];
            let availableItems = allItems.filter(type => !banned.includes(type) && !picked.includes(type) && ITEM_CONFIG[type].type !== 'neutral');
            
            let commonItems = [];
            while(commonItems.length < 2 && availableItems.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableItems.length);
                commonItems.push(availableItems.splice(randomIndex, 1)[0]);
            }
            
            const activeItemTypes = {};
            ['health', 'weapon', 'shield'].forEach(type => activeItemTypes[type] = { owner: 'neutral' });
            banPickState.p1Picks.forEach(type => activeItemTypes[type] = { owner: 'p1' });
            banPickState.p2Picks.forEach(type => activeItemTypes[type] = { owner: 'p2' });
            commonItems.forEach(type => activeItemTypes[type] = { owner: 'neutral' });
            
            startCountdown(activeItemTypes);
        }

        function startCountdown(activeItemTypes) {
            const countdownScreen = document.getElementById('countdown-screen');
            const countdownText = document.getElementById('countdown-text');
            countdownScreen.classList.remove('hidden');
            setupGame(activeItemTypes);

            let count = 3;
            countdownText.textContent = count;

            const interval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownText.textContent = count;
                } else if (count === 0) {
                    countdownText.textContent = "Bắt Đầu!";
                    countdownText.classList.remove('text-9xl');
                    countdownText.classList.add('text-7xl');
                } else {
                    clearInterval(interval);
                    countdownScreen.classList.add('hidden');
                    countdownText.classList.add('text-9xl');
                    countdownText.classList.remove('text-7xl');
                    startGame(); 
                }
            }, 1000);
        }

        function setupGame(activeItemTypes) {
            document.getElementById('top-ui').classList.remove('invisible');
            document.getElementById('bottom-ui').classList.remove('invisible');
            
            players = [];
            const playerRadius = (canvas.width / 25) * 1.4 * 0.7;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const p1Spawn = { x: centerX + centerX / 2, y: centerY / 2 };
            const p2Spawn = { x: centerX / 2, y: centerY + centerY / 2 };
            
            const p1 = new PlayerController('Người chơi 1', '#3b82f6', new PlayerBall(p1Spawn.x, p1Spawn.y, playerRadius));
            p1.balls[0].controller = p1;
            const p2 = new PlayerController('Người chơi 2', '#ef4444', new PlayerBall(p2Spawn.x, p2Spawn.y, playerRadius));
            p2.balls[0].controller = p2;
            players.push(p1, p2);

            items = {};
            for (const type in activeItemTypes) {
                let owner = 'neutral';
                if(activeItemTypes[type].owner === 'p1') owner = p1;
                if(activeItemTypes[type].owner === 'p2') owner = p2;
                items[type] = { ...ITEM_CONFIG[type], owner: owner, item: null, cooldownEndTime: Date.now() + INITIAL_SPAWN_TIME, initialCooldownUsed: false };
            }
            
            updateLivesUI(); 
            updatePlayerStatusUI();
            updateCooldownUI();
			 updateScoreUI();

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            getAllPlayerBalls().forEach(ball => ball.draw());
        }

        function startGame() {
			requestWakeLock();
            gameEndTime = Date.now() + TOTAL_GAME_TIME;
            for (const type in items) {
                const timeoutId = setTimeout(() => {
                    spawnItem(type);
                    items[type].initialCooldownUsed = true;
                }, INITIAL_SPAWN_TIME);
                itemSpawnTimeouts.push(timeoutId);
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        window.addEventListener('resize', init);
        startButton.addEventListener('click', showBanPickPhase);
        restartButton.addEventListener('click', init);
        document.addEventListener('visibilitychange', async () => {
  // Nếu người dùng quay lại tab và game đang chạy (animationFrameId tồn tại)
  if (document.visibilityState === 'visible' && animationFrameId) {
    await requestWakeLock();
  }
});
        init();
    </script>

</body>
</html>

