<!DOCTYPE html>
<html lang="vi">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
      <title>Đấu Trường Sinh Tử</title>
      <script src="https://cdn.tailwindcss.com"></script>
      <style>
         @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
         html, body {
         margin: 0; padding: 0; overflow: hidden;
         height: 100dvh; width: 100dvw;
         background-color: #0a0a0a;
         font-family: 'Inter', sans-serif;
         }
         #game-container {
         display: flex; flex-direction: column; justify-content: center; align-items: center;
         height: 100%; width: 100%; padding: 1rem; box-sizing: border-box;
         position: relative;
         }
         canvas {
         background-color: #2d3748; border: 2px solid #a0aec0; border-radius: 0.5rem;
         box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
         max-width: 100%; max-height: 100%; aspect-ratio: 1 / 1;
         transition: transform 0.1s ease-out;
         }
         .screen-overlay {
         position: absolute;
         top: 0; left: 0; right: 0; bottom: 0;
         background-color: rgba(10, 10, 10, 0.85);
         display: flex;
         flex-direction: column;
         justify-content: center;
         align-items: center;
         text-align: center;
         z-index: 10;
         backdrop-filter: blur(8px);
         }
         .dialog-card {
         background-color: #1a1a1d;
         padding: 2.5rem;
         border-radius: 12px;
         border: 1px solid rgba(255, 255, 255, 0.1);
         box-shadow: 0 10px 25px -5px rgba(0,0,0,0.3), 0 10px 10px -5px rgba(0,0,0,0.2);
         width: clamp(300px, 90vw, 1000px);
         }
         .material-button {
         text-transform: uppercase;
         letter-spacing: 1.25px;
         font-weight: 500;
         box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14), 0 3px 1px -2px rgba(0,0,0,0.12), 0 1px 5px 0 rgba(0,0,0,0.2);
         transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease;
         }
         .material-button:active {
         box-shadow: 0 4px 5px 0 rgba(0,0,0,0.14), 0 1px 10px 0 rgba(0,0,0,0.12), 0 2px 4px -1px rgba(0,0,0,0.2);
         transform: translateY(1px);
         }
         .cooldown-circle {
         position: relative; width: 36px; height: 36px;
         }
         .cooldown-circle svg {
         transform: rotate(-90deg);
         }
         .cooldown-circle .icon {
         position: absolute; top: 50%; left: 50%;
         transform: translate(-50%, -50%) rotate(90deg);
         }
         .cooldown-circle .text {
         position: absolute; top: 50%; left: 50%;
         transform: translate(-50%, -50%);
         font-size: 13px; font-weight: bold;
         }
         .ban-pick-item {
         position: relative;
         padding: 8px;
         border-radius: 8px;
         cursor: pointer;
         transition: all 0.2s ease;
         background-color: rgba(255, 255, 255, 0.05);
         border: 2px solid transparent;
         }
         .ban-pick-item.selectable:hover {
         border-color: rgba(255, 255, 255, 0.5);
         transform: translateY(-2px);
         }
         .ban-pick-item .overlay {
         position: absolute; top: 0; left: 0; right: 0; bottom: 0;
         background-color: rgba(0,0,0,0.7);
         display: flex; justify-content: center; align-items: center;
         font-size: 2rem;
         color: #ef4444;
         border-radius: 8px;
         font-weight: bold;
         opacity: 0;
         transition: opacity 0.2s ease;
         }
         .ban-pick-item.banned .overlay { opacity: 1; }
         .ban-pick-item.picked-p1 { border-color: #3b82f6; }
         .ban-pick-item.picked-p2 { border-color: #ef4444; }
         .ban-pick-item .type-icon {
         position: absolute;
         bottom: 2px;
         right: 2px;
         width: 16px;
         height: 16px;
         background-color: rgba(0,0,0,0.7);
         border-radius: 50%;
         display: flex;
         justify-content: center;
         align-items: center;
         }
         #tooltip {
         position: fixed;
         background-color: #1a1a1d;
         border: 1px solid rgba(255,255,255,0.2);
         border-radius: 8px;
         padding: 1rem;
         max-width: 250px;
         z-index: 99;
         pointer-events: none;
         opacity: 0;
         transition: opacity 0.2s ease, transform 0.2s ease;
         transform-origin: top left;
         }
         .animate-pulse-fast { animation: pulse 0.5s cubic-bezier(0.4, 0.6, 1) infinite; }
         @keyframes pulse { 50% { opacity: .5; } }
         @keyframes pulse-border {
         50% { border-color: rgba(255, 255, 255, 0.6); }
         }
         .pulsing-slot {
         animation: pulse-border 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
         }
         @media (max-width: 768px) {
         #game-container {
         display: flex; flex-direction: column; justify-content: center; align-items: center;
         padding: 0.5rem;
         }
         #game-ui {
         flex-shrink: 0;
         }
         #ban-pick-screen .dialog-card {
         padding: 1rem;
         display: flex;
         flex-direction: column;
         max-height: 90vh;
         }
         #ban-pick-screen > div > div {
         flex-direction: column;
         }
         #ban-pick-screen .w-1\/4, #ban-pick-screen .w-1\/2 {
         width: 100%;
         padding: 0;
         margin-bottom: 1rem;
         }
         #ban-pick-screen .text-left, #ban-pick-screen .text-right {
         text-align: center;
         }
         #p1-bans, #p1-picks, #p2-bans, #p2-picks {
         justify-content: center;
         }
         #ban-pick-grid-container {
         /* Height of 3 items (approx 65px) + 2 gaps (16px) */
         max-height: 21vh; 
         overflow-y: auto;
         scrollbar-width: thin;
         scrollbar-color: #4a5568 #1a1a1d;
         }
         #ban-pick-grid-container::-webkit-scrollbar { width: 8px; }
         #ban-pick-grid-container::-webkit-scrollbar-track { background: #1a1a1d; }
         #ban-pick-grid-container::-webkit-scrollbar-thumb {
         background-color: #4a5568;
         border-radius: 4px;
         border: 2px solid #1a1a1d;
         }
         }
      </style>
   </head>
   <body class="text-white">
      <div id="game-container">
         <div id="top-ui" class="w-full flex flex-col items-center invisible px-2 py-2 md:py-0">
            <div id="player1-info" class="w-full max-w-lg mb-2">
               <div class="flex justify-between items-center">
                  <h2 class="font-bold text-lg text-blue-500 flex items-center">
                     <span>Người chơi 1</span>
                     <span id="player1-status-icons" class="flex items-center ml-2 space-x-1"></span>
                  </h2>
                  <span id="player1-score" class="font-bold text-2xl text-white bg-black/20 px-3 rounded-md">0</span>
               </div>
               <div id="player1-lives" class="flex items-center space-x-1 mt-1"></div>
            </div>
            <div id="player1-cooldown-timers" class="w-full max-w-lg flex justify-center flex-wrap gap-x-4 gap-y-1 mb-1 text-sm text-gray-300"></div>
            <div id="player1-cooldown-timers" class="w-full max-w-lg flex justify-center flex-wrap gap-x-4 gap-y-1 mb-1 text-sm text-gray-300"></div>
            <div id="neutral-cooldown-timers" class="w-full max-w-lg flex justify-center flex-wrap gap-x-4 gap-y-1 text-sm text-gray-300"></div>
         </div>
         <canvas id="gameCanvas" class="my-2"></canvas>
         <div id="countdown-screen" class="screen-overlay hidden">
            <h1 id="countdown-text" class="text-9xl font-bold text-white" style="text-shadow: 0 0 20px rgba(0,0,0,0.5);"></h1>
         </div>
         <div id="bottom-ui" class="w-full flex flex-col items-center invisible px-2 py-2 md:py-0">
            <div id="player2-info" class="w-full max-w-lg mt-2">
               <div class="flex justify-between items-center">
                  <h2 class="font-bold text-lg text-red-500 flex items-center">
                     <span>Người chơi 2</span>
                     <span id="player2-status-icons" class="flex items-center ml-2 space-x-1"></span>
                  </h2>
                  <span id="player2-score" class="font-bold text-2xl text-white bg-black/20 px-3 rounded-md">0</span>
               </div>
               <div id="player2-lives" class="flex items-center space-x-1 mt-1"></div>
            </div>
            <div id="player2-cooldown-timers" class="w-full max-w-lg flex justify-center flex-wrap gap-x-4 gap-y-1 mt-2 text-sm text-gray-300"></div>
         </div>
         <div id="start-screen" class="screen-overlay">
            <div class="dialog-card">
               <h1 class="text-5xl font-bold mb-8 text-gray-100">Đấu Trường Sinh Tử</h1>
               <button id="start-button" class="material-button bg-blue-600 hover:bg-blue-700 text-white py-4 px-8 rounded-lg text-2xl">Bắt đầu</button>
            </div>
         </div>
         <div id="ban-pick-screen" class="screen-overlay hidden">
            <div class="dialog-card">
               <div class="flex justify-between w-full">
                  <!-- Player 1 Side -->
                  <div class="w-1/4 text-left">
                     <h3 class="text-lg font-bold text-blue-500">CẤM</h3>
                     <div id="p1-bans" class="flex space-x-2 mt-2 h-12"></div>
                     <h3 class="text-lg font-bold text-blue-500 mt-4">CHỌN</h3>
                     <div id="p1-picks" class="flex space-x-2 mt-2 h-12"></div>
                  </div>
                  <!-- Center Grid -->
                  <div class="w-1/2 px-4 flex flex-col">
                     <div id="ban-pick-header-container" class="text-center mb-4 flex flex-col justify-center min-h-[112px] md:min-h-0">
                        <h2 id="ban-pick-title" class="text-2xl md:text-3xl font-bold text-gray-100"></h2>
                        <div id="ban-pick-info-mobile" class="hidden md:hidden p-2 bg-gray-900 rounded-lg text-left"></div>
                     </div>
                     <div id="ban-pick-grid-container" class="flex-grow">
                        <div id="ban-pick-grid" class="grid grid-cols-4 gap-4"></div>
                     </div>
                  </div>
                  <!-- Player 2 Side -->
                  <div class="w-1/4 text-right">
                     <h3 class="text-lg font-bold text-red-500">CẤM</h3>
                     <div id="p2-bans" class="flex space-x-2 mt-2 justify-end h-12"></div>
                     <h3 class="text-lg font-bold text-red-500 mt-4">CHỌN</h3>
                     <div id="p2-picks" class="flex space-x-2 mt-2 justify-end h-12"></div>
                  </div>
               </div>
            </div>
         </div>
         <div id="game-over-screen" class="screen-overlay hidden">
            <div class="dialog-card">
               <h2 id="winner-text" class="text-4xl font-bold mb-4"></h2>
               <div id="results-details" class="my-6 text-lg"></div>
               <button id="restart-button" class="material-button mt-4 bg-green-600 hover:bg-green-700 text-white py-3 px-6 rounded-lg text-xl">Chơi lại</button>
            </div>
         </div>
      </div>
      <div id="tooltip"></div>
      <script>
         const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
         const startScreen = document.getElementById('start-screen');
         const banPickScreen = document.getElementById('ban-pick-screen');
         const gameOverScreen = document.getElementById('game-over-screen');
         const winnerText = document.getElementById('winner-text');
         const startButton = document.getElementById('start-button');
         const restartButton = document.getElementById('restart-button');
         const gameUI = document.getElementById('game-ui');
         const tooltip = document.getElementById('tooltip');
         let wakeLockSentinel = null; 
         const ICONS = {
             weapon: `<svg class="h-8 w-8 text-yellow-400" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l2.5 6.5L21 9l-5 4.5L17 21l-5-3.5L7 21l1-7.5L3 9l6.5-.5L12 2z"/></svg>`,
             health: `<svg class="h-8 w-8 text-green-400" viewBox="0 0 24 24" fill="currentColor"><path d="M19 11h-6V5h-2v6H5v2h6v6h2v-6h6z"/></svg>`,
             bomb: `<svg class="h-8 w-8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="14" r="8" fill="#4a5568"/><rect x="10" y="3" width="4" height="4" rx="1" fill="#2d3748"/><circle cx="12" cy="2" r="1.5" fill="#ef4444"/></svg>`,
             shield: `<svg class="h-8 w-8 text-sky-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z"/></svg>`,
             grow: `<svg class="h-8 w-8 text-blue-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 8l-6 6h12l-6-6z"/></svg>`,
             shrink: `<svg class="h-8 w-8 text-orange-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 16l6-6H6l6 6z"/></svg>`,
             speedBoost: `<svg class="h-8 w-8 text-teal-400" viewBox="0 0 24 24" fill="currentColor"><path d="M13 2L3 14h9l-1 8 11-12h-9z"/></svg>`,
             rain: `<svg class="h-8 w-8 text-blue-300" viewBox="0 0 24 24" fill="currentColor"><path d="M19.35 10.04A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.04A5.994 5.994 0 0 0 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM9 19H7v-4h2v4zm4 0h-2v-4h2v4zm4 0h-2v-4h2v4z"/></svg>`,
             invisibility: `<svg class="h-8 w-8 text-gray-400" viewBox="0 0 24 24" fill="currentColor"><path d="M12,2A9,9 0 0,0 3,11V22L6,19L9,22L12,19L15,22L18,19L21,22V11A9,9 0 0,0 12,2M9,8A2,2 0 0,1 11,10A2,2 0 0,1 9,12A2,2 0 0,1 7,10A2,2 0 0,1 9,8M15,8A2,2 0 0,1 17,10A2,2 0 0,1 15,12A2,2 0 0,1 13,10A2,2 0 0,1 15,8Z" /></svg>`,
             wallSpikes: `<svg class="h-8 w-8 text-red-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 20h20v2H2v-2zM3.414 4L12 12.586 20.586 4 22 5.414 13.414 14 22 22.586 20.586 24 12 15.414 3.414 24 2 22.586 10.586 14 2 5.414 3.414 4z"/></svg>`,
             diagonalWall: `<svg class="h-8 w-8 text-indigo-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 21.0001L21 3.00006L19.5 1.50006L1.5 19.5L3 21.0001Z"/></svg>`,
             clone: `<svg class="h-8 w-8 text-purple-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3a9 9 0 0 0-9 9 9 9 0 0 0 9 9 9 9 0 0 0 9-9 9 9 0 0 0-9-9zm0 16a7 7 0 0 1-7-7 7 7 0 0 1 7-7 7 7 0 0 1 7 7 7 7 0 0 1-7 7zm-3-7a3 3 0 1 1 6 0 3 3 0 0 1-6 0z"/></svg>`,
             cannotEat: `<svg class="h-8 w-8 text-green-300" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8zm-2.8-10.2L11 11.6V8h2v5.1l-1.8 1.8-1.4-1.4 1.2-1.2-3.8-3.7z"/></svg>`,
             laserGun: `<svg class="h-8 w-8 text-pink-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M6 2L8 8H2V6H4.6L2.8 2.8L4.2 1.4L6 2M2 16H8L6 22L4.2 20.6L2.8 21.2L4.6 18H2V16M9 3H15V5H9V3M20.6 1.4L19.2 2.8L21.4 6H18V8H24L22 2L20.6 1.4M15 19H9V21H15V19M22 16H18V18H21.4L19.2 21.2L20.6 22.6L24 16Z"/></svg>`,
             slow: `<svg class="h-8 w-8 text-amber-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="m15 5-1.41 1.41L15 7.83V14.17l-1.41-1.41L12.17 14 17 18.83 21.83 14 20.41 12.59 19 14.17V7.83l1.41 1.41L21.83 8 17 3.17 12.17 8l1.41 1.41L15 7.83zM7 5l-1.41 1.41L7 7.83v6.34l-1.41-1.41L4.17 14 9 18.83 13.83 14 12.41 12.59 11 14.17V7.83l1.41 1.41L13.83 8 9 3.17 4.17 8l1.41 1.41L7 7.83z"/></svg>`,
             homingMissile: `<svg class="h-8 w-8 text-orange-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L9.91 5.95L6 6.18L8.73 9.09L8.09 13.05L12 11L15.91 13.05L15.27 9.09L18 6.18L14.09 5.95L12 2M22 13V15H17V13H22M2 13V15H15V13H2Z" /></svg>`,
             reflectiveCloak: `<svg class="h-8 w-8 text-fuchsia-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L1 9l4 1.5V21h14v-9.5L23 9l-11-7zm0 2.5l7 4.5-2 .75V19H7v-9.25L5 8l7-4.5zM9 13v2h6v-2H9z"/></svg>`,
         thieuThan: `<svg class="h-8 w-8 text-orange-500" viewBox="0 0 24 24" fill="currentColor"><path d="M9.1 5.2c1.3-2.1 3.1-3.7 5.2-4.5-1.2.9-2.1 2.2-2.7 3.7-1.1.2-2.1.6-2.9 1.2.4-.8.6-1.7.4-2.4zM16 3c.3.5.5 1.1.5 1.7 0 .5-.1 1-.3 1.5.8.5 1.5 1.2 1.9 2.1-.3-.1-.5-.2-.8-.3-.9-.2-1.8-.1-2.6.3.3-1 .5-2.1.2-3.1-.3-.8-.8-1.5-1.4-2 .8.3 1.5.8 2.5 1.8zM8.2 8.9c-.3.4-.6.8-.8 1.3-.2.9-.1 1.8.3 2.6.4.8 1 1.5 1.8 2 .3-.7.5-1.4.5-2.2 0-1.4-.5-2.8-1.4-3.9-.1 0-.2-.1-.4-.2zM15.1 11.8c-.8.7-1.3 1.6-1.5 2.6-.1.6 0 1.2.2 1.8.8.1 1.6-.2 2.2-.7.9-.7 1.4-1.7 1.5-2.8 0-.3 0-.6-.1-.9-.6-.2-1.2-.5-1.9-1.2-.2.1-.3.2-.4.2zM8.8 15.3c-.5.8-1.2 1.5-2.1 1.9.1-.3.2-.5.3-.8.2-1 .1-1.9-.3-2.7-.4-.8-1-1.5-1.8-2 .7-.3 1.5-.5 2.2-.5 1.4 0 2.8.5 3.9 1.4.1.2.2.3.2.4-.7.5-1.4 1-2.1 2.3zm8.3 1.9c.4.3.8.6 1.3.8.9.2 1.8.1 2.6-.3.8-.4 1.5-1 2-1.8-.7.3-1.4.5-2.2.5-1.4 0-2.8-.5-3.9-1.4-.2-.1-.3-.2-.4-.2.5.8 1.1 1.5 1.8 2.2.1.1.2.1.4.2z"/></svg>`,			
         snare: `<svg class="h-8 w-8 text-lime-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12H17A5,5 0 0,0 12,7V4M4,12A8,8 0 0,1 12,4V7A5,5 0 0,0 7,12H4M12,20A8,8 0 0,1 4,12H7A5,5 0 0,0 12,17V20M20,12A8,8 0 0,1 12,20V17A5,5 0 0,0 17,12H20Z" /></svg>`
          // --- THÊM 3 DÒNG SAU VÀO ĐÂY ---
         ,
          superSpike: `<svg class="h-8 w-8 text-orange-500" viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L9 9l-8 3 8 3 3 8 3-8 8-3-8-3-3-8z"/></svg>`,
         dart: `<svg class="h-8 w-8 text-cyan-400"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round">  <line x1="22" y1="2" x2="11" y2="13" />  <polygon points="22 2 15 22 11 13 2 9 22 2" /></svg>`,
         poison: `<svg class="h-8 w-8 text-lime-500" viewBox="0 0 24 24" fill="currentColor"><path d="M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" /></svg>`,
         // --- KẾT THÚC ---
         };
         const ITEM_COLORS = {
             weapon: '#f6e05e', health: '#48bb78', bomb: '#f56565', shield: '#38bdf8',
             grow: '#63b3ed', shrink: '#f6ad55', speedBoost: '#4fd1c5', rain: '#3b82f6', 
             invisibility: '#9ca3af', wallSpikes: '#ef4444', diagonalWall: '#818cf8', clone: '#c084fc', 
             cannotEat: '#86efac', laserGun: '#f472b6', slow: '#f59e0b', homingMissile: '#f97316',
             reflectiveCloak: '#e879f9', thieuThan: '#f97316', snare: '#a3e635', superSpike: '#ff4500',
         dart: '#22d3ee', 
         poison: '#84cc16'
         };
         
         let players = [], items = {}, animationFrameId, gameEndTime, activeLaser = null, activeMissile = null;
         let activeDart = null;
         let activeRainZone = null, activeSpikeWall = null, activeDiagonalWall = null;
         let itemSpawnTimeouts = [];
         let itemDisappearTimeouts = { health: null, bomb: null, snare: null };
         let particles = [];
         const TOTAL_GAME_TIME = 90 * 1000;
         const INITIAL_SPAWN_TIME = 5000;
         let banPickState = { currentIndex: 0, p1Bans: [], p2Bans: [], p1Picks: [], p2Picks: [], selectionCandidate: null };
         
         const ITEM_CONFIG = {
             weapon: { name: 'Vũ Khí Gai', baseRespawn: 10000, type: 'neutral', desc: 'Nhận một lớp gai tồn tại trong 5s. Va chạm với đối thủ sẽ gây sát thương và phá vỡ gai. Gai cũng sẽ vỡ khi chặn các sát thương khác.', stats: { 'Thời gian': '5s', 'Hiệu ứng': '1 lần tấn công/phòng thủ' } }, 
             //health: { name: 'Hồi Máu', baseRespawn: 10000, type: 'neutral', desc: 'Hồi lại 1 mạng nếu chưa đầy máu.', stats: { 'Hồi phục': '+1 Mạng' } }, 
             bomb: { name: 'Bom', baseRespawn: 5000, type: 'debuff', desc: 'Đặt một quả bom trên bản đồ. Đối thủ của người nhặt sẽ bị mất mạng nếu chạm phải.', stats: {} },
             shield: { name: 'Khiên', baseRespawn: 10000, type: 'neutral', desc: 'Nhận 1 lớp khiên chặn đòn tấn công hoặc hiệu ứng bất lợi tiếp theo.', stats: { 'Hiệu ứng': 'Chặn 1 đòn' } }, 
             reflectiveCloak: { name: 'Áo Choàng Phản', baseRespawn: 15000, type: 'buff', desc: 'Tồn tại 10s hoặc đến khi bị tấn công, sẽ phản lại sát thương cho đối thủ.', stats: { 'Thời gian': '10s', 'Hiệu ứng': '1 lần phản đòn'} },
             snare: { name: 'Trói Chân', baseRespawn: 15000, type: 'debuff', desc: 'Đặt một chiếc bẫy. Đối thủ của người nhặt sẽ bị trói chân trong 3 giây nếu dẫm phải.', stats: { 'Thời gian trói': '3s'} },
             grow: { name: 'Phóng To', baseRespawn: 12000, type: 'debuff', desc: 'Phóng to kích thước của đối thủ.', stats: { 'Thời gian': '10s', 'Kích thước': '+25%' } }, 
             shrink: { name: 'Thu Nhỏ', baseRespawn: 12000, type: 'buff', desc: 'Thu nhỏ kích thước bản thân.', stats: { 'Thời gian': '10s', 'Kích thước': '-25%' } }, 
             speedBoost: { name: 'Tăng Tốc', baseRespawn: 12000, type: 'buff', desc: 'Tăng mạnh tốc độ di chuyển.', stats: { 'Thời gian': '5s', 'Tốc độ': '+50%' } }, 
             slow: { name: 'Làm Chậm', baseRespawn: 12000, type: 'debuff', desc: 'Giảm tốc độ di chuyển của đối thủ.', stats: { 'Thời gian': '5s', 'Tốc độ': '-50%'}},
             rain: { name: 'Mưa bom', baseRespawn: 10000, type: 'debuff', desc: 'Tạo một vùng mưa gây sát thương lên đối thủ.', stats: { 'Thời gian': '5s', 'Sát thương': '3 lần' } }, 
             invisibility: { name: 'Tàng Hình', baseRespawn: 15000, type: 'buff', desc: 'Trở nên bất tử, miễn nhiễm sát thương.', stats: { 'Thời gian': '3s' } },
             wallSpikes: { name: 'Tường Gai', baseRespawn: 15000, type: 'map_effect', desc: 'Tạo gai trên một cạnh tường ngẫu nhiên. Người nhặt sẽ luôn miễn nhiễm.', stats: { 'Độ bền': '1 lần chạm' } }, 
             diagonalWall: { name: 'Tường Chéo', baseRespawn: 20000, type: 'map_effect', desc: 'Tạo một bức tường chéo ở góc.', stats: { 'Độ bền': '5 lần chạm' } }, 
             clone: { name: 'Phân Thân', baseRespawn: 15000, type: 'buff', desc: 'Tạo ra một bản sao của bản thân. Các bản thể chia sẻ chung trạng thái.', stats: { 'Tối đa': '3 bản thể' } },
             cannotEat: { name: 'Cấm Ăn', baseRespawn: 10000, type: 'debuff', desc: 'Khiến đối thủ không thể nhặt vật phẩm.', stats: { 'Thời gian': '5s' } },
             laserGun: { name: 'Súng Laze', baseRespawn: 20000, type: 'debuff', desc: 'Bắn một tia laze bật tường gây sát thương cho đối thủ.', stats: { 'Thời gian': '2s', 'Bật tường': '5 lần' }},
         thieuThan: { 
                 name: 'Thiêu Thân', 
                 baseRespawn: 10000, 
                 type: 'buff', 
                 desc: 'Chờ đến khi người chơi nhặt được Vũ Khí Gai. Khi có gai, tự động lao về phía đối thủ với tốc độ tăng dần. Hiệu ứng kết thúc khi va chạm hoặc khi gai hết tác dụng.', 
                 stats: { 'Tốc độ tối đa': 'x1.25', 'Điều kiện': 'Phải có Vũ Khí Gai' } 
             },
             homingMissile: { name: 'Tên Lửa', baseRespawn: 15000, type: 'debuff', desc: 'Bắn một tên lửa bám đuổi đối thủ. Nổ khi va chạm tường.', stats: {'Tồn tại': '10s'}}
         ,
         superSpike: { name: 'Gai Siêu Cấp', baseRespawn: 20000, type: 'buff', desc: 'Nhận 1 gai siêu cấp tồn tại 5s. Gây 2 sát thương khi va chạm. Phá vỡ giáp và vẫn gây 1 sát thương. Phản đòn sẽ nhận lại 2 sát thương.', stats: { 'Thời gian': '5s', 'Sát thương': '2' } },
         dart: { name: 'Phi Tiêu', baseRespawn: 20000, type: 'debuff', desc: 'Ném ra một phi tiêu bật tường 4 lần. Gây 1 sát thương, xuyên giáp và không thể bị phản đòn.', stats: { 'Số lần bật tường': '4', 'Sát thương': '1 (Xuyên giáp)' } },
         poison: { name: 'Thuốc Độc', baseRespawn: 20000, type: 'buff', desc: 'Trong 15s, chạm vào đối thủ 2 lần sẽ khiến họ bị trúng độc. Sau 10s, người bị trúng độc sẽ mất 1 mạng (có thể bị chặn bởi khiên).', stats: { 'Thời gian hiệu lực': '15s', 'Số lần chạm': '2', 'Thời gian độc': '10s' } }
         // --- KẾT THÚC ---
         };
         // ... sau hằng số ITEM_CONFIG
         
         // THÊM CẢ KHỐI CODE NÀY VÀO
         const requestWakeLock = async () => {
         // Kiểm tra xem trình duyệt có hỗ trợ Wake Lock API không
         if ('wakeLock' in navigator) {
         try {
             // Yêu cầu khóa màn hình
             wakeLockSentinel = await navigator.wakeLock.request('screen');
             console.log('Screen Wake Lock đã được kích hoạt.');
         
             // Lắng nghe sự kiện khi khóa bị hủy bởi hệ thống (ví dụ: pin yếu)
             wakeLockSentinel.addEventListener('release', () => {
                 console.log('Screen Wake Lock đã bị hủy.');
                 wakeLockSentinel = null;
             });
         } catch (err) {
             console.error(`Không thể kích hoạt Wake Lock: ${err.name}, ${err.message}`);
         }
         } else {
         console.warn('Trình duyệt này không hỗ trợ Screen Wake Lock API.');
         }
         };
         
         const releaseWakeLock = async () => {
         if (wakeLockSentinel) {
         await wakeLockSentinel.release();
         wakeLockSentinel = null;
         }
         };
         // KẾT THÚC KHỐI CODE CẦN THÊM
         
         const banPickSequence = [
             { phase: 'ban', player: 1 }, { phase: 'ban', player: 2 }, 
             { phase: 'pick', player: 1 }, { phase: 'pick', player: 2 }, { phase: 'pick', player: 1 }, 
             { phase: 'ban', player: 2 }, { phase: 'ban', player: 1 }, 
             { phase: 'pick', player: 2 }, { phase: 'pick', player: 2 }, 
             { phase: 'pick', player: 1 },
         ];
         
         function setCanvasSize() {
             const container = document.getElementById('game-container');
             const multiplier = window.innerWidth <= 768 ? 0.8 : 0.7;
             const size = Math.min(container.clientWidth, container.clientHeight) * multiplier;
             canvas.width = size; canvas.height = size;
         }
         
         class Particle {
             constructor(x, y, dx, dy, radius, color, life, friction = 1) { this.x = x; this.y = y; this.dx = dx; this.dy = dy; this.radius = radius; this.color = color; this.life = life; this.initialLife = life; this.friction = friction; }
             draw() { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.globalAlpha = Math.max(0, this.life / this.initialLife); ctx.fillStyle = this.color; ctx.fill(); ctx.globalAlpha = 1; }
             update() { this.dx *= this.friction; this.dy *= this.friction; this.x += this.dx; this.y += this.dy; this.life--; }
         }
         
         class Laser {
             constructor(startPos, initialDir, owner) {
                 this.owner = owner;
                 this.startTime = Date.now();
                 this.endTime = this.startTime + 2000;
                 this.segments = [];
                 this.maxBounces = 5;
                 this.calculatePath(startPos, initialDir);
             }
             calculatePath(currentPos, currentDir) {
                 if (this.segments.length > this.maxBounces) return;
                 let endPoint = null;
                 let reflectionDir = { ...currentDir };
                 let minT = Infinity;
                 if (currentDir.y < 0) { let t = -currentPos.y / currentDir.y; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: currentPos.x + t * currentDir.x, y: 0}; reflectionDir = {x: currentDir.x, y: -currentDir.y}; } }
                 if (currentDir.y > 0) { let t = (canvas.height - currentPos.y) / currentDir.y; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: currentPos.x + t * currentDir.x, y: canvas.height}; reflectionDir = {x: currentDir.x, y: -currentDir.y}; } }
                 if (currentDir.x < 0) { let t = -currentPos.x / currentDir.x; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: 0, y: currentPos.y + t * currentDir.y}; reflectionDir = {x: -currentDir.x, y: currentDir.y}; } }
                 if (currentDir.x > 0) { let t = (canvas.width - currentPos.x) / currentDir.x; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: canvas.width, y: currentPos.y + t * currentDir.y}; reflectionDir = {x: -currentDir.x, y: currentDir.y}; } }
                 if (endPoint) { this.segments.push({ p1: currentPos, p2: endPoint }); this.calculatePath(endPoint, reflectionDir); }
             }
             draw() { const lifeLeft = (this.endTime - Date.now()) / 2000; if (lifeLeft < 0) return; ctx.strokeStyle = this.owner.color; ctx.lineWidth = 4; ctx.shadowBlur = 10; ctx.shadowColor = this.owner.color; ctx.globalAlpha = lifeLeft; this.segments.forEach(seg => { ctx.beginPath(); ctx.moveTo(seg.p1.x, seg.p1.y); ctx.lineTo(seg.p2.x, seg.p2.y); ctx.stroke(); }); ctx.globalAlpha = 1; ctx.shadowBlur = 0; }
             checkCollision(ball) { for (const seg of this.segments) { const A = seg.p1, B = seg.p2, C = { x: ball.x, y: ball.y }, R = ball.radius; let AC = { x: C.x - A.x, y: C.y - A.y }; let AB = { x: B.x - A.x, y: B.y - A.y }; let magAB2 = AB.x * AB.x + AB.y * AB.y; let dot = AC.x * AB.x + AC.y * AB.y; let t = dot / magAB2; let closestX, closestY; if (t < 0) { closestX = A.x; closestY = A.y; } else if (t > 1) { closestX = B.x; closestY = B.y; } else { closestX = A.x + t * AB.x; closestY = A.y + t * AB.y; } let distSq = (C.x - closestX)**2 + (C.y - closestY)**2; if (distSq < R**2) { return true; } } return false; }
         }
         
         class RainZone {
             constructor(x, y, radius, owner) { this.x = x; this.y = y; this.radius = radius; this.owner = owner; this.startTime = Date.now(); this.endTime = this.startTime + 5000; this.drops = [ { time: 1000, triggered: false }, { time: 2500, triggered: false }, { time: 4000, triggered: false }]; }
             draw() { const progress = (Date.now() - this.startTime) / 5000; const alpha = 0.5 * (1 - progress); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = `rgba(56, 189, 248, ${alpha * 0.5})`; ctx.fill(); ctx.strokeStyle = `rgba(56, 189, 248, ${alpha})`; ctx.lineWidth = 2; ctx.stroke(); this.drops.forEach(drop => { const dropTime = this.startTime + drop.time; if (Date.now() > dropTime && Date.now() < dropTime + 200) { for(let i=0; i<15; i++) { const rainX = this.x + (Math.random() - 0.5) * this.radius * 2; const rainY = this.y + (Math.random() - 0.5) * this.radius * 2; if(Math.hypot(rainX - this.x, rainY - this.y) < this.radius) { ctx.beginPath(); ctx.moveTo(rainX, rainY - 5); ctx.lineTo(rainX, rainY + 5); ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)'; ctx.lineWidth = 1; ctx.stroke(); } } } }); }
             update() { const now = Date.now(); this.drops.forEach(drop => { if (!drop.triggered && now > this.startTime + drop.time) { getAllPlayerBalls().forEach(ball => { if (ball.controller !== this.owner && Math.hypot(ball.x - this.x, ball.y - this.y) < ball.radius + this.radius) { ball.controller.takeDamage(ball); } }); drop.triggered = true; } }); if (now > this.endTime) activeRainZone = null; }
         }
         
         class DiagonalWall {
             constructor() { this.hits = 5; this.corner = Math.floor(Math.random() * 4); const w = canvas.width; const h = canvas.height; const midW = w / 2; const midH = h / 2; const corners = [ { p1: { x: 0, y: midH }, p2: { x: midW, y: 0 } }, { p1: { x: midW, y: 0 }, p2: { x: w, y: midH } }, { p1: { x: w, y: midH }, p2: { x: midW, y: h } }, { p1: { x: midW, y: h }, p2: { x: 0, y: midH } } ]; this.p1 = corners[this.corner].p1; this.p2 = corners[this.corner].p2; let dx = this.p2.x - this.p1.x; let dy = this.p2.y - this.p1.y; this.normal = { x: -dy, y: dx }; const mag = Math.hypot(this.normal.x, this.normal.y); this.normal.x /= mag; this.normal.y /= mag; }
             draw() { ctx.beginPath(); ctx.moveTo(this.p1.x, this.p1.y); ctx.lineTo(this.p2.x, this.p2.y); ctx.strokeStyle = `rgba(129, 140, 248, ${0.4 + (this.hits / 5) * 0.6})`; ctx.lineWidth = 5; ctx.stroke(); }
         }
         
         class HomingMissile {
             constructor(owner, targetController) {
                 this.owner = owner;
                 this.targetController = targetController;
                 const startBall = owner.balls[0];
                 this.x = startBall.x; this.y = startBall.y;
                 this.baseSpeed = startBall.baseSpeed;
                 this.currentSpeed = this.baseSpeed;
                 this.angle = Math.random() * 2 * Math.PI;
                 this.turnSpeed = 0.04;
                 this.endTime = Date.now() + 10000;
                 this.radius = 5;
             }
             update() {
                 if (Date.now() > this.endTime || !this.targetController.balls.length) { activeMissile = null; return; }
                 const target = this.targetController.balls[0];
                 const targetAngle = Math.atan2(target.y - this.y, target.x - this.x);
                 let angleDiff = targetAngle - this.angle;
                 while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                 while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
         
                 const distToTarget = Math.hypot(this.x - target.x, this.y - target.y);
                 if (Math.abs(angleDiff) > Math.PI / 2) {
                     this.currentSpeed = this.baseSpeed * 0.75;
                 } else if (distToTarget < canvas.width / 4) {
                     this.currentSpeed = this.baseSpeed * 1.25;
                 } else {
                     this.currentSpeed = this.baseSpeed;
                 }
                 
                 this.angle += angleDiff * this.turnSpeed;
                 const dx = Math.cos(this.angle) * this.currentSpeed;
                 const dy = Math.sin(this.angle) * this.currentSpeed;
                 this.x += dx; this.y += dy;
         
                 if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                     triggerEffect(this.x, this.y, ITEM_COLORS.homingMissile, { count: 20 });
                     activeMissile = null;
                     return;
                 }
         
                 if(distToTarget < this.radius + target.radius) {
                     this.targetController.takeDamage(target, this.owner);
                     triggerEffect(this.x, this.y, ITEM_COLORS.homingMissile, { count: 30, speed: 4 });
                     activeMissile = null;
                 }
             }
             draw() {
                 ctx.save();
                 ctx.translate(this.x, this.y);
                 ctx.rotate(this.angle);
                 ctx.fillStyle = this.owner.color;
                 ctx.shadowBlur = 10;
                 ctx.shadowColor = this.owner.color;
                 ctx.beginPath();
                 ctx.moveTo(this.radius, 0);
                 ctx.lineTo(-this.radius, -this.radius / 1.5);
                 ctx.lineTo(-this.radius, this.radius / 1.5);
                 ctx.closePath();
                 ctx.fill();
                 ctx.restore();
                 ctx.shadowBlur = 0;
             }
         }
         class Dart {
         constructor(owner, targetController) {
         this.owner = owner;
         const startBall = owner.balls[0];
         const targetBall = targetController.balls[0];
         this.x = startBall.x;
         this.y = startBall.y;
         this.radius = 7;
         this.bounces = 0;
         this.maxBounces = 4;
         
         const speed = startBall.baseSpeed * 1.5;
         const angle = Math.atan2(targetBall.y - this.y, targetBall.x - this.x);
         this.dx = Math.cos(angle) * speed;
         this.dy = Math.sin(angle) * speed;
         }
         
         update() {
         this.x += this.dx;
         this.y += this.dy;
         let bounced = false;
         if (this.x + this.radius > canvas.width || this.x - this.radius < 0) {
             this.dx = -this.dx;
             this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
             bounced = true;
         }
         if (this.y + this.radius > canvas.height || this.y - this.radius < 0) {
             this.dy = -this.dy;
             this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y));
             bounced = true;
         }
         if (bounced) {
             this.bounces++;
         }
         return this.bounces > this.maxBounces; // Trả về true nếu hết hạn
         }
         
         draw() {
         ctx.save();
         ctx.translate(this.x, this.y);
         ctx.rotate(Math.atan2(this.dy, this.dx));
         ctx.fillStyle = this.owner.color;
         ctx.shadowBlur = 10;
         ctx.shadowColor = this.owner.color;
         ctx.beginPath();
         ctx.moveTo(this.radius, 0);
         ctx.lineTo(-this.radius, -this.radius / 2);
         ctx.lineTo(-this.radius / 2, 0);
         ctx.lineTo(-this.radius, this.radius / 2);
         ctx.closePath();
         ctx.fill();
         ctx.restore();
         ctx.shadowBlur = 0;
         }
         }
         class PlayerBall {
             constructor(x, y, baseRadius, controller) {
                 this.controller = controller; this.x = x; this.y = y; this.baseRadius = baseRadius;
                 this.baseSpeed = (canvas.width / 200) * 4.5 * 0.75 * 0.9; this.speed = this.baseSpeed;
                 let angle = Math.random() * Math.PI * 2; this.dx = Math.cos(angle) * this.speed; this.dy = Math.sin(angle) * this.speed;
             }
             get radius() { return this.controller.sizeEffect === 'shrink' ? this.baseRadius * 0.75 : (this.controller.sizeEffect === 'grow' ? this.baseRadius * 1.25 : this.baseRadius); }
             get invincibleUntil() { return this.controller.invincibleUntil; }
             get sizeEffect() { return this.controller.sizeEffect; }
             get cannotEatUntil() { return this.controller.cannotEatUntil; }
             get isSnared() { return this.controller.snaredUntil && Date.now() < this.controller.snaredUntil; }
             
             draw() {
                 ctx.globalAlpha = 1;
                 if (this.invincibleUntil && Date.now() < this.invincibleUntil) { if (Math.floor(Date.now() / 150) % 2 === 0) { ctx.globalAlpha = 0.5; } }
                 
                 // Draw armor layers underneath the ball
                 this.controller.armor.forEach((armorType, index) => {
                     const armorRadius = this.radius + 5 + (index * 4);
                     const armorColor = ITEM_COLORS[armorType] || '#ffffff';
                     ctx.beginPath();
                     ctx.arc(this.x, this.y, armorRadius, 0, Math.PI * 2);
                     ctx.strokeStyle = armorColor;
                     ctx.lineWidth = 2;
                     ctx.stroke();
                     ctx.closePath();
                 });
         
                 ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.controller.color; ctx.fill();
                 if (this.sizeEffect) { ctx.strokeStyle = this.sizeEffect === 'grow' ? '#f6ad55' : '#63b3ed'; ctx.lineWidth = 4; ctx.stroke(); }
                 if (this.cannotEatUntil && Date.now() < this.cannotEatUntil) { ctx.strokeStyle = ITEM_COLORS.cannotEat; ctx.lineWidth = 4; ctx.stroke(); }
                 if (this.isSnared) { 
                     ctx.strokeStyle = ITEM_COLORS.snare; ctx.lineWidth = 4; ctx.stroke(); 
                     ctx.beginPath();
                     ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);
                     ctx.setLineDash([5, 5]);
                     ctx.stroke();
                     ctx.setLineDash([]);
                 }
                 ctx.closePath();
                 ctx.globalAlpha = 1;
             }
             update() { 
                 if (this.isSnared) {
                     // Không cập nhật vị trí, giữ nguyên vận tốc để khi hết hiệu lực có thể di chuyển lại
                     return; 
                 }
                 this.x += this.dx; 
                 this.y += this.dy; 
             }
         }
         
         class PlayerController {
             constructor(name, color, initialBall) { 
        this.name = name; 
        this.color = color; 
        // this.lives = 5; // FIX: Bỏ dòng này hoặc để nó không dùng đến nữa
        this.balls = [initialBall]; 
        this.hasSpikeWallImmunity = false; 
        this.armor = []; 
        this.invincibleUntil = null; 
        this.sizeEffect = null; 
        this.speedMultiplier = 1.0; 
        this.effectTimeouts = { size: null, speed: null, shield: null, invincible: null, cannotEat: null, reflectiveCloak: null, weapon: null, snare: null, superSpike: null }; // Thêm superSpike vào đây cho chắc
        this.cannotEatUntil = null; 
        this.snaredUntil = null; 
        this.score = 0;
        this.hasThieuThanBuff = false;
        this.isThieuThanActive = false;     
        this.hasPoisonBuffUntil = null; 
        this.poisonHits = 0;           
        this.isPoisonedUntil = null;   
    }
             
            takeDamage(ball, attacker = null, isReflectedDamage = false) {
        const now = Date.now();
        if (this.invincibleUntil && now < this.invincibleUntil) return false;

        // Ưu tiên trừ giáp trước
        const realArmorIndex = this.armor.findIndex(type => type !== 'weapon' && type !== 'superSpike'); // Giữ lại vũ khí, chỉ trừ các loại giáp phòng thủ

        if (realArmorIndex > -1) {
            // Gỡ bỏ loại giáp đã tìm thấy (Cơ chế: Giáp chặn ghi điểm)
            const armorType = this.armor.splice(realArmorIndex, 1)[0]; 
            if (armorType === 'shield') {
                const shieldData = items['shield'];
                if (shieldData) {
                    shieldData.cooldownEndTime = Date.now() + shieldData.currentRespawn;
                    itemSpawnTimeouts.push(setTimeout(() => spawnItem('shield'), shieldData.currentRespawn));
                }
            }
            if (armorType === 'reflectiveCloak') {
                clearTimeout(this.effectTimeouts.reflectiveCloak);
                // Hồi chiêu cho áo choàng
                const itemData = items['reflectiveCloak'];
                if (itemData) {
                     itemData.cooldownEndTime = Date.now() + itemData.currentRespawn;
                     itemSpawnTimeouts.push(setTimeout(() => spawnItem('reflectiveCloak'), itemData.currentRespawn));
                }
            }
            triggerEffect(ball.x, ball.y, ITEM_COLORS[armorType] || this.color, { count: 25, speed: 5 });

            if (!isReflectedDamage && (armorType === 'reflectiveCloak') && attacker && attacker.balls.length > 0) {
                attacker.takeDamage(attacker.balls[0], this, true);
            }
            updateLivesUI();
            return false; // Có giáp -> Không bị ghi điểm
        }

        // Nếu không có giáp: Bị dính đòn
        this.invincibleUntil = now + 2000; 
        
        // FIX: Xử lý ghi điểm
        if (attacker) {
            // Kiểm tra thời gian để nhân đôi điểm (30s cuối)
            const remainingTime = Math.max(0, gameEndTime - Date.now());
            const pointsToAdd = remainingTime <= 30000 ? 2 : 1; // FIX: x2 điểm ở 30s cuối
            
            attacker.score += pointsToAdd;
            updateScoreUI();
            
            // FIX: Bỏ check thắng sớm (attacker.score >= 10)
        }

        // Hiệu ứng khi bị đánh trúng (nhưng không chết)
        triggerEffect(ball.x, ball.y, this.color, { count: 30, speed: 6 });
        pauseGameForEffect({ duration: 500, shake: 5 }); 
        
        // FIX: Bỏ triggerDeath vì không còn mạng để hết
        return true;
    } 
             
             addBall() {
                 if (this.balls.length >= 3) return;
                 const parentBall = this.balls[0];
                 const newBall = new PlayerBall(parentBall.x + (Math.random() - 0.5) * 20, parentBall.y + (Math.random() - 0.5) * 20, this.balls[0].baseRadius, this);
                 let angle = Math.random() * Math.PI * 2; newBall.dx = Math.cos(angle) * newBall.speed; newBall.dy = Math.sin(angle) * newBall.speed;
                 updatePlayerVelocity(newBall); this.balls.push(newBall);
                 triggerEffect(newBall.x, newBall.y, this.color, { count: 30, speed: 4 });
             }
             removeBall(ball) { const index = this.balls.indexOf(ball); if (index > -1) { triggerEffect(ball.x, ball.y, this.color, { count: 15, speed: 3, life: 30 }); this.balls.splice(index, 1); } }
             
             applyEffect(effectType, duration, value) {
                 clearTimeout(this.effectTimeouts[effectType]);
                 switch(effectType) {
                     case 'size': this.sizeEffect = value; break;
                     case 'speed': this.speedMultiplier = value; break;
                     case 'cannotEat': this.cannotEatUntil = Date.now() + duration; break;
                     case 'snare': this.snaredUntil = Date.now() + duration; break;
                         case 'reflectiveCloak':
                         if (!this.armor.includes('reflectiveCloak')) {
                             this.armor.push('reflectiveCloak');
                         }
                         this.effectTimeouts.reflectiveCloak = setTimeout(() => {
                            const index = this.armor.indexOf('reflectiveCloak');
                            if(index > -1) this.armor.splice(index, 1);
                            // --- BẮT ĐẦU SỬA ---
                            // Thêm logic bắt đầu hồi chiêu khi áo choàng hết hạn
                            const itemData = items['reflectiveCloak'];
                            if (itemData) {
                                const respawnTime = itemData.currentRespawn;
                                itemData.cooldownEndTime = Date.now() + respawnTime;
                                itemSpawnTimeouts.push(setTimeout(() => spawnItem('reflectiveCloak'), respawnTime));
                            }
                            // --- KẾT THÚC SỬA ---
                            updateLivesUI();
                         }, duration);
                         updateLivesUI();
                         return; // Exit early to avoid standard timeout logic
                 }
                  this.effectTimeouts[effectType] = setTimeout(() => {
                     switch(effectType) {
                         case 'size': this.sizeEffect = null; break;
                         case 'speed': this.speedMultiplier = 1.0; break;
                         case 'cannotEat': this.cannotEatUntil = null; break;
                         case 'snare': this.snaredUntil = null; break;
                     }
                     updatePlayerStatusUI();
                 }, duration);
             }
         }
         
         class Item {
             constructor(x, y, radius, type, owner, duration = null) { this.x = x; this.y = y; this.radius = radius; this.type = type; this.owner = owner; this.disappearTime = duration ? Date.now() + duration : null; }
             draw() {
                 if (this.owner && this.owner !== 'neutral') { ctx.shadowBlur = 15; ctx.shadowColor = this.owner.color; }
                 const drawFunc = ITEM_DRAW_LOGIC[this.type]; if (drawFunc) drawFunc(this);
                 ctx.shadowBlur = 0;
             }
         }
         
         const ITEM_DRAW_LOGIC = {
             weapon: (item) => { ctx.fillStyle = '#f6e05e'; ctx.strokeStyle = '#b7791f'; for (let i = 0; i < 8; i++) { let angle = (i / 8) * (Math.PI * 2); let outerRadius = item.radius * 1.4; ctx.beginPath(); ctx.moveTo(item.x, item.y); ctx.lineTo(item.x + Math.cos(angle) * outerRadius, item.y + Math.sin(angle) * outerRadius); ctx.stroke(); } ctx.beginPath(); ctx.arc(item.x, item.y, item.radius * 0.8, 0, Math.PI * 2); ctx.fill(); },
             health: (item) => { ctx.fillStyle = '#48bb78'; ctx.strokeStyle = '#2f855a'; const barWidth = item.radius * 1.5; const barHeight = item.radius * 0.5; ctx.fillRect(item.x - barWidth / 2, item.y - barHeight / 2, barWidth, barHeight); ctx.strokeRect(item.x - barWidth / 2, item.y - barHeight / 2, barWidth, barHeight); ctx.fillRect(item.x - barHeight / 2, item.y - barWidth / 2, barHeight, barWidth); ctx.strokeRect(item.x - barHeight / 2, item.y - barWidth / 2, barHeight, barWidth); },
             bomb: (item) => {
                 ctx.fillStyle = '#4a5568';
                 ctx.strokeStyle = '#1a202c';
                 ctx.lineWidth = 2;
                 ctx.beginPath();
                 ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2);
                 ctx.fill();
                 ctx.stroke();
                 ctx.fillStyle = '#2d3748';
                 ctx.fillRect(item.x - item.radius * 0.2, item.y - item.radius * 1.2, item.radius * 0.4, item.radius * 0.4);
                 const pulse = Math.abs(Math.sin(Date.now() / 150));
                 ctx.fillStyle = `rgba(255, ${150 + pulse * 105}, 0, ${0.8 + pulse * 0.2})`;
                 ctx.beginPath();
                 ctx.arc(item.x, item.y - item.radius * 1.2, 3, 0, Math.PI * 2);
                 ctx.fill();
             },
         thieuThan: (item) => { 
                 ctx.fillStyle = ITEM_COLORS.thieuThan; 
                 ctx.strokeStyle = '#dd6b20'; 
                 ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); 
                 ctx.fill(); 
                 ctx.stroke(); 
                 ctx.fillStyle = 'white'; 
                 ctx.beginPath(); 
                 ctx.moveTo(item.x + item.radius * 0.3, item.y - item.radius * 0.6); 
                 ctx.lineTo(item.x - item.radius * 0.4, item.y); 
                 ctx.lineTo(item.x, item.y); 
                 ctx.lineTo(item.x - item.radius * 0.3, item.y + item.radius * 0.6); 
                 ctx.lineTo(item.x + item.radius * 0.4, item.y); 
                 ctx.lineTo(item.x, item.y); 
                 ctx.closePath(); 
                 ctx.fill(); 
             },
             shield: (item) => { ctx.fillStyle = '#38bdf8'; ctx.strokeStyle = '#0284c7'; ctx.beginPath(); ctx.moveTo(item.x, item.y - item.radius); ctx.lineTo(item.x - item.radius, item.y - item.radius * 0.3); ctx.lineTo(item.x - item.radius, item.y + item.radius * 0.5); ctx.arc(item.x, item.y + item.radius * 0.5, item.radius, Math.PI, 0, false); ctx.lineTo(item.x + item.radius, item.y - item.radius * 0.3); ctx.closePath(); ctx.fill(); ctx.stroke(); },
             grow: (item) => { const isGrow = true; ctx.fillStyle = isGrow ? '#63b3ed' : '#f6ad55'; ctx.strokeStyle = isGrow ? '#3182ce' : '#dd6b20'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; const arrowHeight = item.radius * 0.5; const arrowWidth = item.radius * 0.6; const direction = isGrow ? -1 : 1; ctx.beginPath(); ctx.moveTo(item.x - arrowWidth, item.y + direction * arrowHeight); ctx.lineTo(item.x, item.y - direction * arrowHeight); ctx.lineTo(item.x + arrowWidth, item.y + direction * arrowHeight); ctx.closePath(); ctx.fill(); },
             shrink: (item) => { const isGrow = false; ctx.fillStyle = isGrow ? '#63b3ed' : '#f6ad55'; ctx.strokeStyle = isGrow ? '#3182ce' : '#dd6b20'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; const arrowHeight = item.radius * 0.5; const arrowWidth = item.radius * 0.6; const direction = isGrow ? -1 : 1; ctx.beginPath(); ctx.moveTo(item.x - arrowWidth, item.y + direction * arrowHeight); ctx.lineTo(item.x, item.y - direction * arrowHeight); ctx.lineTo(item.x + arrowWidth, item.y + direction * arrowHeight); ctx.closePath(); ctx.fill(); },
             speedBoost: (item) => { ctx.fillStyle = '#4fd1c5'; ctx.strokeStyle = '#319795'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; ctx.beginPath(); ctx.moveTo(item.x + item.radius * 0.3, item.y - item.radius * 0.6); ctx.lineTo(item.x - item.radius * 0.4, item.y); ctx.lineTo(item.x, item.y); ctx.lineTo(item.x - item.radius * 0.3, item.y + item.radius * 0.6); ctx.lineTo(item.x + item.radius * 0.4, item.y); ctx.lineTo(item.x, item.y); ctx.closePath(); ctx.fill(); },
             rain: (item) => { ctx.fillStyle = ITEM_COLORS.rain; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; ctx.fillRect(item.x - item.radius * 0.5, item.y, 2, 5); ctx.fillRect(item.x, item.y + item.radius * 0.2, 2, 5); ctx.fillRect(item.x + item.radius * 0.5, item.y, 2, 5); },
             invisibility: (item) => { ctx.fillStyle = ITEM_COLORS.invisibility; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'black'; ctx.beginPath(); ctx.arc(item.x - item.radius * 0.3, item.y - item.radius * 0.2, item.radius * 0.15, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(item.x + item.radius * 0.3, item.y - item.radius * 0.2, item.radius * 0.15, 0, Math.PI * 2); ctx.fill(); },
             wallSpikes: (item) => { ctx.fillStyle = ITEM_COLORS.wallSpikes; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.rect(item.x - item.radius, item.y + item.radius * 0.5, item.radius * 2, item.radius * 0.5); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; for (let i = 0; i < 3; i++) { const xPos = item.x - item.radius * 0.6 + i * item.radius * 0.6; ctx.beginPath(); ctx.moveTo(xPos - item.radius * 0.2, item.y + item.radius * 0.5); ctx.lineTo(xPos, item.y - item.radius * 0.5); ctx.lineTo(xPos + item.radius * 0.2, item.y + item.radius * 0.5); ctx.closePath(); ctx.fill(); } },
             diagonalWall: (item) => { ctx.fillStyle = ITEM_COLORS.diagonalWall; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(item.x - item.radius * 0.7, item.y + item.radius * 0.7); ctx.lineTo(item.x + item.radius * 0.7, item.y - item.radius * 0.7); ctx.stroke(); },
             clone: (item) => { ctx.fillStyle = ITEM_COLORS.clone; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x - item.radius * 0.3, item.y, item.radius * 0.8, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.arc(item.x + item.radius * 0.3, item.y, item.radius * 0.8, 0, Math.PI * 2); ctx.globalAlpha = 0.7; ctx.fill(); ctx.stroke(); ctx.globalAlpha = 1; },
             cannotEat: (item) => { ctx.fillStyle = ITEM_COLORS.cannotEat; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius * 0.6, Math.PI * 0.2, Math.PI * 1.8); ctx.stroke(); },
             laserGun: (item) => { ctx.fillStyle = ITEM_COLORS.laserGun; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(item.x - item.radius * 0.5, item.y); ctx.lineTo(item.x + item.radius * 0.5, item.y); ctx.stroke(); ctx.beginPath(); ctx.moveTo(item.x, item.y - item.radius * 0.5); ctx.lineTo(item.x, item.y + item.radius * 0.5); ctx.stroke(); },
             slow: (item) => { ctx.fillStyle = ITEM_COLORS.slow; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = 'white'; ctx.beginPath(); ctx.moveTo(item.x - 5, item.y + 5); ctx.lineTo(item.x, item.y); ctx.lineTo(item.x + 5, item.y + 5); ctx.moveTo(item.x - 5, item.y); ctx.lineTo(item.x, item.y - 5); ctx.lineTo(item.x + 5, item.y); ctx.lineWidth = 2; ctx.stroke(); },
             homingMissile: (item) => { ctx.fillStyle = ITEM_COLORS.homingMissile; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.moveTo(item.x, item.y - item.radius); ctx.lineTo(item.x - item.radius, item.y + item.radius * 0.5); ctx.lineTo(item.x + item.radius, item.y + item.radius * 0.5); ctx.closePath(); ctx.fill(); ctx.stroke(); },
             reflectiveCloak: (item) => { ctx.fillStyle = ITEM_COLORS.reflectiveCloak; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); },
             snare: (item) => { ctx.fillStyle = ITEM_COLORS.snare; ctx.strokeStyle = '#1a202c'; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); },
             snare_trap: (item) => { ctx.strokeStyle = ITEM_COLORS.snare; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2); ctx.stroke(); ctx.beginPath(); ctx.arc(item.x, item.y, item.radius * 0.5, 0, Math.PI * 2); ctx.stroke(); },
             bomb_trap: (item) => {
                 ctx.fillStyle = '#4a5568';
                 ctx.strokeStyle = '#1a202c';
                 ctx.lineWidth = 2;
                 ctx.beginPath();
                 ctx.arc(item.x, item.y, item.radius, 0, Math.PI * 2);
                 ctx.fill();
                 ctx.stroke();
                 
                 ctx.fillStyle = '#2d3748';
                 ctx.fillRect(item.x - item.radius * 0.2, item.y - item.radius * 1.2, item.radius * 0.4, item.radius * 0.4);
         
                 const pulse = Math.abs(Math.sin(Date.now() / 150));
                 ctx.fillStyle = `rgba(255, ${150 + pulse * 105}, 0, ${0.8 + pulse * 0.2})`;
                 ctx.beginPath();
                 ctx.arc(item.x, item.y - item.radius * 1.2, 3, 0, Math.PI * 2);
                 ctx.fill();
             }
         };
         
         function updateLivesUI() {
    if (!players[0] || !players[1]) return;
    const p1LivesDiv = document.getElementById('player1-lives');
    const p2LivesDiv = document.getElementById('player2-lives');
    
    const renderLives = (container, player, colorClass) => {
        container.innerHTML = '';
        // FIX: Bỏ vòng lặp vẽ trái tim (lives)
        
        // Chỉ vẽ icon Giáp
        const armorContainer = document.createElement('div');
        armorContainer.className = 'flex items-center space-x-1 ml-0'; // Sửa ml-2 thành ml-0
        player.armor.forEach(armorType => {
             // Chỉ hiện các icon không phải vũ khí tấn công (để coi như lớp phòng thủ)
             if(armorType !== 'weapon' && armorType !== 'superSpike') {
                 armorContainer.innerHTML += `<div class="w-5 h-5 bg-gray-800 rounded-full p-0.5 border border-gray-600">${ICONS[armorType].replace('h-8 w-8', 'h-full w-full')}</div>`;
             }
        });
        container.appendChild(armorContainer);
    };

    renderLives(p1LivesDiv, players[0], 'bg-blue-500');
    renderLives(p2LivesDiv, players[1], 'bg-red-500');
}
         function updateScoreUI() {
         if (!players[0] || !players[1]) return;
         const p1ScoreDiv = document.getElementById('player1-score');
         const p2ScoreDiv = document.getElementById('player2-score');
         p1ScoreDiv.textContent = players[0].score;
         p2ScoreDiv.textContent = players[1].score;
         }
         function updatePlayerStatusUI() {
             const p1_icons = document.getElementById('player1-status-icons');
             const p2_icons = document.getElementById('player2-status-icons');
             p1_icons.innerHTML = ''; p2_icons.innerHTML = '';
             const smallIcon = (svg) => svg.replace('h-8 w-8', 'h-4 w-4');
             const addIcons = (player, container) => {
                 if (!player) return;
                 if (player.invincibleUntil && Date.now() < player.invincibleUntil) container.innerHTML += smallIcon(ICONS.invisibility);
                 if (player.sizeEffect) container.innerHTML += smallIcon(ICONS[player.sizeEffect]);
                 if (player.speedMultiplier !== 1.0) container.innerHTML += smallIcon(player.speedMultiplier > 1 ? ICONS.speedBoost : ICONS.slow);
                 if (player.cannotEatUntil && Date.now() < player.cannotEatUntil) container.innerHTML += smallIcon(ICONS.cannotEat);
                 if (player.snaredUntil && Date.now() < player.snaredUntil) container.innerHTML += smallIcon(ICONS.snare);
         if (player.isThieuThanActive) {
                     container.innerHTML += `<div class="w-4 h-4 text-orange-500 animate-pulse-fast">${ICONS.thieuThan.replace('h-8 w-8', 'h-4 w-4')}</div>`;
                 } else if (player.hasThieuThanBuff) {
                     container.innerHTML += `<div class="w-4 h-4 text-gray-600">${ICONS.thieuThan.replace('h-8 w-8', 'h-4 w-4')}</div>`;
                 }
                 if (player.hasSpikeWallImmunity) container.innerHTML += smallIcon(ICONS.wallSpikes);
                 if (player.balls.length > 1) container.innerHTML += `<span class="text-sm font-bold text-purple-400">x${player.balls.length}</span>`;
             };
             addIcons(players[0], p1_icons);
             addIcons(players[1], p2_icons);
         }
         
         function getRandomPosition(radius) { return { x: Math.random() * (canvas.width - radius * 2) + radius, y: Math.random() * (canvas.height - radius * 2) + radius } }
         function triggerEffect(x, y, color, { count = 20, speed = 3, life = 40, friction = 0.95 } = {}) { for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const currentSpeed = Math.random() * speed + 1; particles.push(new Particle( x, y, Math.cos(angle) * currentSpeed, Math.sin(angle) * currentSpeed, Math.random() * 2 + 1, color, life, friction )); } }
         function spawnItem(type) { if (type === 'shield' || type === 'weapon') {
         const isHeld = players.some(p => p.armor.includes(type));
         if (isHeld) return; // Nếu có người chơi đang giữ thì không tạo ra
         };
         if (items[type] && items[type].item) return; const radius = canvas.width / 40; const pos = getRandomPosition(radius); let duration = null; if (type === 'health') duration = 7000; if (type === 'bomb' || type === 'snare_trap') duration = 5000; items[type].item = new Item(pos.x, pos.y, radius, type, items[type].owner, duration); items[type].cooldownEndTime = null; if (duration) { clearTimeout(itemDisappearTimeouts[type]); itemDisappearTimeouts[type] = setTimeout(() => { if (items[type] && items[type].item) { items[type].item = null; const respawnTime = items[type].currentRespawn; items[type].cooldownEndTime = Date.now() + respawnTime; itemSpawnTimeouts.push(setTimeout(() => spawnItem(type), respawnTime)); } }, duration); } }
         function updatePlayerVelocity(playerBall) { const mag = Math.hypot(playerBall.dx, playerBall.dy); if (mag > 0) { playerBall.dx = (playerBall.dx / mag) * playerBall.speed; playerBall.dy = (playerBall.dy / mag) * playerBall.speed; } }
         const getAllPlayerBalls = () => players.flatMap(p => p.balls);
         
         function handleDiagonalWallCollision(ball) { if (!activeDiagonalWall) return; const p1 = activeDiagonalWall.p1; const p2 = activeDiagonalWall.p2; const p1_to_player = { x: ball.x - p1.x, y: ball.y - p1.y }; const p1_to_p2 = { x: p2.x - p1.x, y: p2.y - p1.y }; const len_p1_p2_sq = p1_to_p2.x * p1_to_p2.x + p1_to_p2.y * p1_to_p2.y; const dot = p1_to_player.x * p1_to_p2.x + p1_to_player.y * p1_to_p2.y; const t = Math.max(0, Math.min(1, dot / len_p1_p2_sq)); const closestPoint = { x: p1.x + t * p1_to_p2.x, y: p1.y + t * p1_to_p2.y }; const distSq = (ball.x - closestPoint.x)**2 + (ball.y - closestPoint.y)**2; if (distSq < ball.radius**2) { const dist = Math.sqrt(distSq); const overlap = ball.radius - dist; if (dist > 0) { ball.x += overlap * (ball.x - closestPoint.x) / dist; ball.y += overlap * (ball.y - closestPoint.y) / dist; } const v = { x: ball.dx, y: ball.dy }; const n = { ...activeDiagonalWall.normal }; const side_check = (ball.x - p1.x) * n.y - (ball.y - p1.y) * n.x; if (side_check > 0) { n.x *= -1; n.y *= -1; } const dot_v_n = v.x * n.x + v.y * n.y; ball.dx = v.x - 2 * dot_v_n * n.x; ball.dy = v.y - 2 * dot_v_n * n.y; activeDiagonalWall.hits--; triggerEffect(closestPoint.x, closestPoint.y, ITEM_COLORS.diagonalWall, { count: 10, speed: 2 }); if (activeDiagonalWall.hits <= 0) { triggerEffect(closestPoint.x, closestPoint.y, ITEM_COLORS.diagonalWall, { count: 30, speed: 5 }); activeDiagonalWall = null; } } }
         function handleWallCollisions(ball) { const now = Date.now(); let bounced = false; if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) { ball.dx = -ball.dx; bounced = true; } if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) { ball.dy = -ball.dy; bounced = true; } ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x)); ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y)); if (activeSpikeWall && bounced) { const sideHit = (ball.x - ball.radius <= 1 && activeSpikeWall.side === 'left') || (ball.x + ball.radius >= canvas.width - 1 && activeSpikeWall.side === 'right') || (ball.y - ball.radius <= 1 && activeSpikeWall.side === 'top') || (ball.y + ball.radius >= canvas.height - 1 && activeSpikeWall.side === 'bottom'); if (sideHit) { if (ball.controller !== activeSpikeWall.owner) { ball.controller.takeDamage(ball, activeSpikeWall.owner);triggerEffect(ball.x, ball.y, ITEM_COLORS.wallSpikes, { count: 20, speed: 5 }); activeSpikeWall = null; updatePlayerStatusUI(); } } } }
          function deactivateThieuThan(player) {
             if (!player.hasThieuThanBuff) return; // Thoát nếu chưa nhặt buff
         
             player.isThieuThanActive = false;
             player.hasThieuThanBuff = false;
             
             const itemData = items['thieuThan'];
             if (itemData) {
                 const respawnTime = itemData.currentRespawn;
                 itemData.cooldownEndTime = Date.now() + respawnTime;
                 itemSpawnTimeouts.push(setTimeout(() => spawnItem('thieuThan'), respawnTime));
             }
             updatePlayerStatusUI();
         }
         function handleCollisions() {
             const allBalls = getAllPlayerBalls();
             for (let i = 0; i < allBalls.length; i++) {
                 for (let j = i + 1; j < allBalls.length; j++) {
                     const b1 = allBalls[i]; const b2 = allBalls[j];
                     if (b1.controller === b2.controller) continue;
                     const dist = Math.hypot(b1.x - b2.x, b1.y - b2.y);
                     if (dist < b1.radius + b2.radius) {
                         const overlap = b1.radius + b2.radius - dist;
                         const nx = (b2.x - b1.x) / dist; const ny = (b2.y - b1.y) / dist;
         
                         // Position correction based on snare state
                         if (!b1.isSnared && !b2.isSnared) {
                             b1.x -= overlap / 2 * nx; b1.y -= overlap / 2 * ny;
                             b2.x += overlap / 2 * nx; b2.y += overlap / 2 * ny;
                         } else if (b1.isSnared && !b2.isSnared) {
                             b2.x += overlap * nx; b2.y += overlap * ny;
                         } else if (!b1.isSnared && b2.isSnared) {
                             b1.x -= overlap * nx; b1.y -= overlap * ny;
                         }
         
                         const tx = -ny; const ty = nx;
                         const dpTan1 = b1.dx * tx + b1.dy * ty;
                         const dpTan2 = b2.dx * tx + b2.dy * ty;
                         const dpNorm1 = b1.dx * nx + b1.dy * ny;
                         const dpNorm2 = b2.dx * nx + b2.dy * ny;
                         
                         // Velocity change, snared balls are like immovable objects
                         if (!b1.isSnared) {
                             b1.dx = tx * dpTan1 + nx * dpNorm2;
                             b1.dy = ty * dpTan1 + ny * dpNorm2;
                         }
                         if (!b2.isSnared) {
                             b2.dx = tx * dpTan2 + nx * dpNorm1;
                             b2.dy = ty * dpTan2 + ny * dpNorm1;
                         }
                         
                         updatePlayerVelocity(b1); 
         updatePlayerVelocity(b2);
         
         // Xử lý hiệu ứng độc (Poison)
         const checkPoison = (attackerBall, defenderBall) => {
         const attacker = attackerBall.controller;
         const defender = defenderBall.controller;
         if (attacker.hasPoisonBuffUntil && Date.now() < attacker.hasPoisonBuffUntil && !defender.isPoisonedUntil) {
         attacker.poisonHits++;
         triggerEffect(defenderBall.x, defenderBall.y, ITEM_COLORS.poison, { count: 10, speed: 2 });
         if (attacker.poisonHits >= 2) {
             defender.isPoisonedUntil = Date.now() + 10000; // Độc có hiệu lực trong 10s
             attacker.hasPoisonBuffUntil = null; // Hủy buff của người tấn công
             attacker.poisonHits = 0;
         }
         }
         };
         checkPoison(b1, b2);
         checkPoison(b2, b1);
         
         // Xử lý các loại vũ khí
         const handleWeaponHit = (attackerBall, defenderBall) => {
         const attacker = attackerBall.controller;
         const defender = defenderBall.controller;
         const weaponType = attacker.armor.find(a => a === 'weapon' || a === 'superSpike');
         
         if (!weaponType) return;
         
         const damageDealt = defender.takeDamage(defenderBall, attacker);
         
         // Nếu là Super Spike và đối thủ có giáp, gây thêm 1 sát thương
         if (weaponType === 'superSpike' && !damageDealt) {
          defender.takeDamage(defenderBall, attacker);
         }
         
         const weaponIndex = attacker.armor.lastIndexOf(weaponType);
         if (weaponIndex > -1) {
         attacker.armor.splice(weaponIndex, 1);
         clearTimeout(attacker.effectTimeouts[weaponType]);
         
         // Bắt đầu hồi chiêu cho vũ khí đã dùng
         const weaponData = items[weaponType];
         if (weaponData) {
             weaponData.cooldownEndTime = Date.now() + weaponData.currentRespawn;
             itemSpawnTimeouts.push(setTimeout(() => spawnItem(weaponType), weaponData.currentRespawn));
         }
         }
         deactivateThieuThan(attacker);
         };
         
         handleWeaponHit(b1, b2);
         handleWeaponHit(b2, b1);
         
         updateLivesUI();
                     }
                 }
                  const ball = allBalls[i];
                  for (const type in items) {
                     const itemData = items[type];
                     if (itemData.item && Math.hypot(ball.x - itemData.item.x, ball.y - itemData.item.y) < ball.radius + itemData.item.radius) {
                         handleItemPickup(ball, type);
                     }
                 }
             }
         }
         
         const ITEM_PICKUP_LOGIC = {
             weapon: (ball) => { 
                 const player = ball.controller;
                 clearTimeout(player.effectTimeouts.weapon); // Luôn làm mới thời gian
         
                 if (!player.armor.includes('weapon')) {
                     player.armor.push('weapon'); // Chỉ thêm nếu chưa có
                 }
                 
                 player.effectTimeouts.weapon = setTimeout(() => {
                     const index = player.armor.indexOf('weapon');
                     if (index > -1) {
                         player.armor.splice(index, 1);
                         updateLivesUI();
                         deactivateThieuThan(player); // Hủy Thiêu Thân khi gai hết hạn
                     }
                 }, 5000); // 5 seconds
                 updateLivesUI(); 
                 return true; 
             },
             health: (ball) => { if (ball.controller.lives < 5) { ball.controller.lives++; updateLivesUI(); return true; } return false; },
             bomb: (ball) => { 
                 const radius = canvas.width / 40; 
                 const pos = getRandomPosition(radius); 
                 // Tạo một bẫy bom tạm thời trên bản đồ
                 items['bomb_trap'] = { 
                     item: new Item(pos.x, pos.y, radius, 'bomb_trap', ball.controller, 7000) // 7 giây tồn tại
                 };
                 return true; 
             },
             bomb_trap: (ball, itemData) => {
                 const trapOwner = itemData.item.owner;
                 const steppingPlayer = ball.controller;
         
                 let trigger = false;
                 if (trapOwner === 'neutral') { // Bom chung
                     trigger = true;
                 } else if (steppingPlayer !== trapOwner) { // Bom của đối thủ
                     trigger = true;
                 }
         
                 if (trigger) {
                     const bombPos = { x: itemData.item.x, y: itemData.item.y };
                     triggerEffect(bombPos.x, bombPos.y, ITEM_COLORS.bomb, { count: 40, speed: 7, life: 60 });
                     steppingPlayer.takeDamage(ball, trapOwner === 'neutral' ? null : trapOwner);
                     return true; // Kích hoạt và xóa bom
                 }
                 return false; // Người đặt dẫm phải, không có gì xảy ra
             },
             shield: (ball) => { 
                 if (ball.controller.armor.includes('shield')) {
                     return false; // Đã có khiên, không nhặt thêm
                 }
                 ball.controller.armor.push('shield'); 
                 updateLivesUI(); 
                 return true; 
             },
             reflectiveCloak: (ball) => { ball.controller.applyEffect('reflectiveCloak', 10000); return true; },
             snare: (ball) => { 
                 const opponent = players.find(p => p !== ball.controller);
                 if (opponent) {
                      const radius = canvas.width / 40; 
                      const pos = getRandomPosition(radius); 
                      items['snare_trap'] = { item: new Item(pos.x, pos.y, radius, 'snare_trap', ball.controller, 5000) };
                 }
                 return true; 
             },
             snare_trap: (ball, itemData) => {
                 const trapOwner = itemData.item.owner;
                 const steppingPlayer = ball.controller;
         
                 let trigger = false;
                 if (trapOwner === 'neutral') {
                     // Bẫy chung tác dụng lên mọi người chơi
                     trigger = true;
                 } else if (steppingPlayer !== trapOwner) {
                     // Bẫy riêng chỉ tác dụng lên đối thủ
                     trigger = true;
                 }
         
                 if (trigger) {
                     steppingPlayer.applyEffect('snare', 3000); // 3 giây
                     return true; 
                 }
                 
                 return false;
             },
             grow: (ball) => { const opponent = players.find(p => p !== ball.controller); if (opponent) opponent.applyEffect('size', 10000, 'grow'); return true; },
             shrink: (ball) => { 
                 ball.controller.applyEffect('size', 10000, 'shrink'); 
                 // Thêm setTimeout riêng cho việc hồi chiêu
                 setTimeout(() => {
                     const itemData = items['shrink'];
                     if (itemData) {
                         const respawnTime = itemData.currentRespawn;
                         itemData.cooldownEndTime = Date.now() + respawnTime;
                         itemSpawnTimeouts.push(setTimeout(() => spawnItem('shrink'), respawnTime));
                     }
                 }, 10000);
                 return true; 
             },
             speedBoost: (ball) => { 
                 ball.controller.applyEffect('speed', 5000, 1.5);
                 // Thêm setTimeout riêng cho việc hồi chiêu
                 setTimeout(() => {
                     const itemData = items['speedBoost'];
                     if (itemData) {
                         const respawnTime = itemData.currentRespawn;
                         itemData.cooldownEndTime = Date.now() + respawnTime;
                         itemSpawnTimeouts.push(setTimeout(() => spawnItem('speedBoost'), respawnTime));
                     }
                 }, 5000);
                 return true; 
             },
             
             slow: (ball) => { const opponent = players.find(p => p !== ball.controller); if (opponent) opponent.applyEffect('speed', 5000, 0.5); return true; },
             rain: (ball) => { const rainRadius = (ball.baseRadius) * 5; const pos = getRandomPosition(rainRadius); activeRainZone = new RainZone(pos.x, pos.y, rainRadius, ball.controller); return true; },
             invisibility: (ball) => { 
                 ball.controller.invincibleUntil = Date.now() + 3000; 
                 // Thêm setTimeout để bắt đầu hồi chiêu sau khi hết 3 giây tàng hình
                 setTimeout(() => {
                     const itemData = items['invisibility'];
                     if (itemData) {
                         const respawnTime = itemData.currentRespawn;
                         itemData.cooldownEndTime = Date.now() + respawnTime;
                         itemSpawnTimeouts.push(setTimeout(() => spawnItem('invisibility'), respawnTime));
                     }
                 }, 3000);
                 return true; 
             },
             wallSpikes: (ball) => { const sides = ['top', 'right', 'bottom', 'left']; activeSpikeWall = { side: sides[Math.floor(Math.random() * 4)], owner: ball.controller }; return true; },
             diagonalWall: (ball) => { if (activeDiagonalWall) return false; activeDiagonalWall = new DiagonalWall(); return true; },
             clone: (ball) => { ball.controller.addBall(); return true; },
             cannotEat: (ball) => { const opponent = players.find(p => p !== ball.controller); if (opponent) opponent.applyEffect('cannotEat', 5000); return true; },
             laserGun: (ball) => { if(activeLaser) return false; const owner = ball.controller; const opponent = players.find(p => p !== owner); if (!opponent || opponent.balls.length === 0) return false; const targetBall = opponent.balls[0]; const dir = { x: targetBall.x - ball.x, y: targetBall.y - ball.y }; const mag = Math.hypot(dir.x, dir.y); if (mag > 0) { dir.x /= mag; dir.y /= mag; } else { dir.x = Math.random() - 0.5; dir.y = Math.random() - 0.5; } activeLaser = new Laser({ x: ball.x, y: ball.y }, dir, owner); return true; },
              thieuThan: (ball) => {
                 const player = ball.controller;
                 if (player.hasThieuThanBuff) return false; // Không nhặt nếu đã có
                 player.hasThieuThanBuff = true;
                 updatePlayerStatusUI();
                 return true;
             },
         homingMissile: (ball) => { if(activeMissile) return false; const owner = ball.controller; const opponent = players.find(p => p !== owner); if (opponent) { activeMissile = new HomingMissile(owner, opponent); } return true;}
         ,
         superSpike: (ball) => {
         const player = ball.controller;
         // Làm mới thời gian nếu nhặt lại
         clearTimeout(player.effectTimeouts.superSpike);
         if (!player.armor.includes('superSpike')) {
         player.armor.push('superSpike');
         }
         player.effectTimeouts.superSpike = setTimeout(() => {
         const index = player.armor.indexOf('superSpike');
         if (index > -1) player.armor.splice(index, 1);
         updateLivesUI();
         deactivateThieuThan(player);
         }, 5000); // 5 giây
         updateLivesUI();
         return true;
         },
         dart: (ball) => {
         if(activeDart) return false;
         const opponent = players.find(p => p !== ball.controller);
         if (opponent && opponent.balls.length > 0) {
         activeDart = new Dart(ball.controller, opponent);
         return true;
         }
         return false;
         },
         poison: (ball) => {
         const player = ball.controller;
         if (player.hasPoisonBuffUntil && Date.now() < player.hasPoisonBuffUntil) return false;
         
         player.hasPoisonBuffUntil = Date.now() + 15000; // Buff tồn tại trong 15s
         player.poisonHits = 0; // Reset số lần chạm
         
         // Bắt đầu hồi chiêu sau khi buff hết hạn
         setTimeout(() => {
         const itemData = items['poison'];
         if (itemData) {
             const respawnTime = itemData.currentRespawn;
             itemData.cooldownEndTime = Date.now() + respawnTime;
             itemSpawnTimeouts.push(setTimeout(() => spawnItem('poison'), respawnTime));
         }
         }, 15000);
         return true;
         }
         };
         
         function handleItemPickup(ball, type) { 
             const itemData = items[type]; 
             if (!itemData || !itemData.item || (ball.controller.cannotEatUntil && Date.now() < ball.controller.cannotEatUntil)) return; 
             
             // Lấy chủ sở hữu từ item object, vì itemData.owner có thể là người chơi controller
             const itemOwner = itemData.item.owner; 
         
             const configType = ITEM_CONFIG[type] ? ITEM_CONFIG[type].type : 'trap';
             if (configType === 'buff' && itemOwner !== 'neutral' && itemOwner !== ball.controller) return; 
             if ((configType === 'debuff' || configType === 'map_effect') && itemOwner !== 'neutral' && itemOwner !== ball.controller) return; 
             const logic = ITEM_PICKUP_LOGIC[type]; 
             if (!logic) return; 
             const pickupSuccessful = logic(ball, itemData); 
             if (pickupSuccessful) { 
                 triggerEffect(ball.x, ball.y, ITEM_COLORS[type], { count: 15, speed: 2, life: 25 }); 
                 const respawnTime = itemData.currentRespawn; 
                 if (itemData.item.disappearTime) clearTimeout(itemDisappearTimeouts[type]); 
                 itemData.item = null; 
         
         const cooldownOnExpireItems = ['shield', 'weapon', 'reflectiveCloak', 'shrink', 'speedBoost', 'invisibility', 'thieuThan'];
                 // Chỉ bắt đầu hồi chiêu ngay lập tức cho các vật phẩm KHÔNG có trong danh sách trên
                 if (respawnTime && !cooldownOnExpireItems.includes(type)) {
                     itemData.cooldownEndTime = Date.now() + respawnTime; 
                     itemSpawnTimeouts.push(setTimeout(() => spawnItem(type), respawnTime)); 
                 }
                 if ((type === 'bomb_trap' || type === 'snare_trap') && ball.controller.lives <= 0) {
                     triggerDeath(ball.controller);
                 }
             } 
             updatePlayerStatusUI(); 
         }
         
         function updateCooldownUI() {
             const neutralDiv = document.getElementById('neutral-cooldown-timers');
             const p1Div = document.getElementById('player1-cooldown-timers');
             const p2Div = document.getElementById('player2-cooldown-timers');
             
             if (!neutralDiv || !p1Div || !p2Div) return;
         
             let neutralHtml = '', p1Html = '', p2Html = '';
         
             const createTimerCircle = (type) => {
                 const itemData = items[type];
                 if (!itemData || !ITEM_CONFIG[type]) return ''; // Bỏ qua các item tạm thời như snare_trap
                 const radius = 16;
                 const circumference = 2 * Math.PI * radius;
                 const endTime = itemData.cooldownEndTime;
                 const baseTime = (itemData.initialCooldownUsed) ? itemData.currentRespawn : INITIAL_SPAWN_TIME;
                 let textContent = '';
                 let strokeDashoffset = circumference;
                 
                 const ownerColor = itemData.owner === players[0] ? '#3b82f6' : (itemData.owner === players[1] ? '#ef4444' : '#a0aec0');
                 if (endTime && Date.now() < endTime) {
                     const remaining = endTime - Date.now();
                     const progress = Math.max(0, remaining / baseTime);
                     strokeDashoffset = circumference * progress;
                     textContent = Math.ceil(remaining / 1000);
                 } else {
                     strokeDashoffset = 0;
                 }
                 return ` <div class="cooldown-circle"> <svg class="w-full h-full"> <circle cx="18" cy="18" r="${radius}" stroke="#4a5568" stroke-width="3" fill="none" /> <circle cx="18" cy="18" r="${radius}" stroke="${ownerColor}" stroke-width="3" fill="none" stroke-dasharray="${circumference}" stroke-dashoffset="${strokeDashoffset}" style="transition: stroke-dashoffset 0.25s linear;" /> </svg> <div class="icon">${!textContent ? ICONS[type].replace('h-8 w-8', 'h-5 w-5') : ''}</div> <div class="text">${textContent}</div> </div> `;
             };
             
             Object.keys(items).forEach(type => {
                 const itemData = items[type];
                 if (!itemData || !ITEM_CONFIG[type]) return;
                 const circleHtml = createTimerCircle(type);
         
                 if (itemData.owner === 'neutral') {
                     neutralHtml += circleHtml;
                 } else if (players[0] && itemData.owner === players[0]) {
                     p1Html += circleHtml;
                 } else if (players[1] && itemData.owner === players[1]) {
                     p2Html += circleHtml;
                 }
             });
         
             neutralDiv.innerHTML = neutralHtml;
             p1Div.innerHTML = p1Html;
             p2Div.innerHTML = p2Html;
         }
function calculateCurrentMultiplier(remainingTime) { 
    return 1; // FIX: Tốc độ luôn cố định là 1.5, không tăng dần
}         
         function drawTimer() { const remaining = Math.max(0, gameEndTime - Date.now()); const remainingPercent = remaining / TOTAL_GAME_TIME; if (remaining > 0) { let color = 'rgba(255, 255, 255, 0.08)'; if(remaining <= 5000) color = 'rgba(239, 68, 68, 0.2)'; else if(remaining <= 15000) color = 'rgba(239, 68, 68, 0.15)'; else if(remaining <= 45000) color = 'rgba(239, 68, 68, 0.1)'; ctx.fillStyle = color; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = '#2d3748'; const wipeHeight = canvas.height * (1 - remainingPercent); ctx.fillRect(0, 0, canvas.width, wipeHeight); } const seconds = Math.ceil(remaining / 1000); ctx.font = `bold ${canvas.width / 4}px Arial`; ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(seconds, canvas.width / 2, canvas.height / 2); }
         function drawSpikeWall() { if (!activeSpikeWall) return; ctx.fillStyle = ITEM_COLORS.wallSpikes; const spikeSize = canvas.width / 40; const numSpikes = Math.floor(canvas.width / spikeSize); for (let i = 0; i < numSpikes; i++) { const pos = i * spikeSize + spikeSize / 2; ctx.beginPath(); if (activeSpikeWall.side === 'top') { ctx.moveTo(pos - spikeSize / 2, 0); ctx.lineTo(pos, spikeSize); ctx.lineTo(pos + spikeSize / 2, 0); } else if (activeSpikeWall.side === 'bottom') { ctx.moveTo(pos - spikeSize / 2, canvas.height); ctx.lineTo(pos, canvas.height - spikeSize); ctx.lineTo(pos + spikeSize / 2, canvas.height); } else if (activeSpikeWall.side === 'left') { ctx.moveTo(0, pos - spikeSize / 2); ctx.lineTo(spikeSize, pos); ctx.lineTo(0, pos + spikeSize / 2); } else if (activeSpikeWall.side === 'right') { ctx.moveTo(canvas.width, pos - spikeSize / 2); ctx.lineTo(canvas.width - spikeSize, pos); ctx.lineTo(canvas.width, pos + spikeSize / 2); } ctx.fill(); } }
         
         function gameLoop() {
             if (!animationFrameId) return; // Game đã dừng, không chạy nữa
             const remaining = Math.max(0, gameEndTime - Date.now());
             const currentMultiplier = calculateCurrentMultiplier(remaining);
             for (const type in items) { if(items[type] && items[type].baseRespawn) items[type].currentRespawn = items[type].baseRespawn / currentMultiplier; }
             getAllPlayerBalls().forEach(b => { b.speed = b.baseSpeed * currentMultiplier * b.controller.speedMultiplier; updatePlayerVelocity(b); });
             if (remaining <= 0) { endGame(true); return; }
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             drawTimer();
             drawSpikeWall();
             if(activeDiagonalWall) activeDiagonalWall.draw();
             if(activeRainZone) { activeRainZone.draw(); activeRainZone.update(); }
             if(activeLaser) {
                 activeLaser.draw();
                 const opponent = players.find(p => p !== activeLaser.owner);
                 if (opponent) { opponent.balls.forEach(ball => { if (activeLaser && activeLaser.checkCollision(ball)) { opponent.takeDamage(ball, activeLaser.owner); activeLaser = null; } }); }
                 if (activeLaser && Date.now() > activeLaser.endTime) activeLaser = null;
             }
             if(activeMissile) { activeMissile.draw(); activeMissile.update(); }
         // TÌM ĐOẠN LOGIC DART TRONG gameLoop VÀ SỬA:
if(activeDart) {
    activeDart.draw();
    if (activeDart.update()) { 
        activeDart = null;
    } else {
        const opponent = players.find(p => p !== activeDart.owner);
        if (opponent) {
            for (const ball of opponent.balls) {
                if (Math.hypot(activeDart.x - ball.x, activeDart.y - ball.y) < activeDart.radius + ball.radius) {
                    // FIX: Phi tiêu xuyên giáp -> Ghi điểm trực tiếp
                    // opponent.lives--; // BỎ
                    
                    // Logic ghi điểm
                    const remainingTime = Math.max(0, gameEndTime - Date.now());
                    const points = remainingTime <= 30000 ? 2 : 1;
                    if (activeDart.owner) activeDart.owner.score += points;
                    
                    opponent.invincibleUntil = Date.now() + 2000;
                    
                    updateScoreUI(); // Cập nhật điểm
                    
                    triggerEffect(activeDart.x, activeDart.y, ITEM_COLORS.dart, { count: 20, speed: 4 });
                    // if (opponent.lives <= 0) endGame(false, activeDart.owner); // BỎ
                    activeDart = null; 
                    break;
                }
            }
        }
    }
}
         
         // TÌM ĐOẠN XỬ LÝ POISON TRONG gameLoop:
// Xử lý hiệu ứng độc (Poison) hết hạn
players.forEach(player => {
    if (player.isPoisonedUntil && Date.now() >= player.isPoisonedUntil) {
        // player.takeDamage(player.balls[0]); // BỎ DÒNG CŨ NÀY ĐI VÌ NÓ SẼ TÍNH DAMAGE THƯỜNG
        
        // FIX: Xử lý riêng cho độc nổ: Đối thủ (người đầu độc) được điểm
        const opponent = players.find(p => p !== player);
        if (opponent) {
             const remainingTime = Math.max(0, gameEndTime - Date.now());
             const points = remainingTime <= 30000 ? 2 : 1;
             opponent.score += points;
             updateScoreUI();
        }

        player.isPoisonedUntil = null;
        triggerEffect(player.balls[0].x, player.balls[0].y, ITEM_COLORS.poison, { count: 30, speed: 3 });
        pauseGameForEffect({ duration: 300, shake: 3 });
    }
});
             // LOGIC KÍCH HOẠT VÀ DI CHUYỂN CỦA THIÊU THÂN
             players.forEach(player => {
                 const hasWeapon = player.armor.includes('weapon');
                 if (player.hasThieuThanBuff && hasWeapon && !player.isThieuThanActive) {
                     player.isThieuThanActive = true;
                     updatePlayerStatusUI();
                 }
                 if (player.isThieuThanActive && !hasWeapon) {
                     deactivateThieuThan(player);
                 }
             });
         
             // VÒNG LẶP CẬP NHẬT VỊ TRÍ BÓNG (ĐÃ SỬA)
             getAllPlayerBalls().forEach(ball => {
                 const player = ball.controller;
                 if (player.isThieuThanActive) {
                     const opponent = players.find(p => p !== player);
                     if (opponent && opponent.balls.length > 0) {
                         const target = opponent.balls[0];
                         const dist = Math.hypot(target.x - ball.x, target.y - ball.y);
                         
                         const maxDistForScaling = canvas.width * 0.75;
                         const proximity = Math.max(0, 1 - (dist / maxDistForScaling));
                         const speedMultiplier = 1 + (proximity * 0.25);
         
                         const angle = Math.atan2(target.y - ball.y, target.x - ball.x);
                         ball.dx = Math.cos(angle) * ball.speed;
                         ball.dy = Math.sin(angle) * ball.speed;
                         
                         ball.dx *= speedMultiplier;
                         ball.dy *= speedMultiplier;
                     }
                 }
                 ball.update(); // Cập nhật vị trí bóng chỉ được gọi 1 lần ở đây
             });
             
             // Dòng "getAllPlayerBalls().forEach(ball => { ball.update(); });" đã được xóa khỏi đây
         
             getAllPlayerBalls().forEach(handleWallCollisions);
             getAllPlayerBalls().forEach(handleDiagonalWallCollision);
             handleCollisions();
             getAllPlayerBalls().forEach(ball => ball.draw());
             for (const type in items) if(items[type] && items[type].item) items[type].item.draw();
             particles.forEach((p, index) => { p.update(); p.draw(); if (p.life <= 0) particles.splice(index, 1); });
             updateCooldownUI(); updatePlayerStatusUI();
             animationFrameId = requestAnimationFrame(gameLoop);
         }
         let effectLoopId = null;
         function pauseGameForEffect({duration, shake = 0}) {
             if (!animationFrameId) return;
             cancelAnimationFrame(animationFrameId);
             animationFrameId = null;
         
             let startTime = Date.now();
             let shakeX = 0, shakeY = 0;
         
             function effectLoop() {
                 const elapsed = Date.now() - startTime;
                 if(elapsed > duration) {
                     canvas.style.transform = '';
                     animationFrameId = requestAnimationFrame(gameLoop); // Resume game
                     return;
                 }
                 if (shake > 0) {
                     shakeX = (Math.random() - 0.5) * shake * (1 - elapsed/duration);
                     shakeY = (Math.random() - 0.5) * shake * (1 - elapsed/duration);
                     canvas.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
                 }
                  effectLoopId = requestAnimationFrame(effectLoop);
             }
             effectLoop();
         }
         
         function triggerDeath(deadPlayerController) { 
             const winner = players.find(p => p !== deadPlayerController);
             const lastBall = deadPlayerController.balls[0] || {x: canvas.width / 2, y: canvas.height/2}; 
             triggerEffect(lastBall.x, lastBall.y, deadPlayerController.color, { count: 50, speed: 8, friction: 0.98, life: 80 }); 
             endGame(false, winner);
         }
         
         function stopGame() {
             if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
             if (effectLoopId) { cancelAnimationFrame(effectLoopId); effectLoopId = null; }
             itemSpawnTimeouts.forEach(clearTimeout);
             itemSpawnTimeouts = [];
             Object.values(itemDisappearTimeouts).forEach(clearTimeout);
         }
         
        // TÌM HÀM NÀY VÀ THAY THẾ TOÀN BỘ BẰNG:
function endGame(isTimeUp = false, winnerPlayer = null) {
    requestWakeLock();
    stopGame();
    gameOverScreen.classList.remove('hidden'); 
    document.getElementById('top-ui').classList.add('invisible');
    document.getElementById('bottom-ui').classList.add('invisible');
    
    let winner = ''; 
    const p1 = players.find(p => p.name === 'Người chơi 1'); 
    const p2 = players.find(p => p.name === 'Người chơi 2'); 
    
    const p1Score = p1 ? p1.score : 0;
    const p2Score = p2 ? p2.score : 0;
    
    // FIX: Logic xác định thắng thua chỉ dựa vào điểm số khi hết giờ
    if (p1Score > p2Score) {
        winner = 'p1';
    } else if (p2Score > p1Score) {
        winner = 'p2';
    } else { 
        winner = 'draw'; 
    }
    
    winnerText.className = 'text-4xl font-bold mb-4';
    if (winner === 'p1') { 
        winnerText.textContent = `Người chơi 1 chiến thắng!`; 
        winnerText.classList.add('text-blue-500'); 
    } else if (winner === 'p2') { 
        winnerText.textContent = `Người chơi 2 chiến thắng!`; 
        winnerText.classList.add('text-red-500'); 
    } else { 
        winnerText.textContent = `Hòa!`; 
    }
    
    // FIX: Cập nhật bảng kết quả bỏ phần hiển thị mạng
    const resultsDiv = document.getElementById('results-details');
    resultsDiv.innerHTML = `
    <div class="flex justify-around items-center text-center">
        <div class="p-4 bg-gray-800 rounded-lg w-2/5">
            <p class="font-bold text-blue-500">Người chơi 1</p>
            <p>Điểm: <span class="font-bold text-4xl">${p1Score}</span></p>
        </div>
        <div class="text-2xl font-bold px-2">VS</div>
        <div class="p-4 bg-gray-800 rounded-lg w-2/5">
            <p class="font-bold text-red-500">Người chơi 2</p>
            <p>Điểm: <span class="font-bold text-4xl">${p2Score}</span></p>
        </div>
    </div>
    
    `;
}
         
         function init() {
         requestWakeLock();
             stopGame();
             setCanvasSize();
             players = [];
             items = {};
             startScreen.classList.remove('hidden');
             banPickScreen.classList.add('hidden');
             gameOverScreen.classList.add('hidden');
             document.getElementById('top-ui').classList.add('invisible');
             document.getElementById('bottom-ui').classList.add('invisible');
             winnerText.textContent = ''; winnerText.className = 'text-4xl font-bold mb-4';
             particles = []; activeRainZone = null; activeSpikeWall = null; activeDiagonalWall = null; activeLaser = null; activeMissile = null;
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             ctx.font = `bold ${canvas.width / 10}px Arial`; ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("Sẵn Sàng...", canvas.width / 2, canvas.height / 2);
         }
         
         function showBanPickPhase() {
             startScreen.classList.add('hidden');
             banPickScreen.classList.remove('hidden');
             banPickState = { currentIndex: 0, p1Bans: [], p2Bans: [], p1Picks: [], p2Picks: [], selectionCandidate: null };
             
             const bannableItems = Object.keys(ITEM_CONFIG).filter(type => ITEM_CONFIG[type].type !== 'neutral');
         
             const itemGroups = { buff: [], debuff: [], map_effect: [] };
             bannableItems.forEach(type => {
                 const itemType = ITEM_CONFIG[type].type;
                 if (itemGroups[itemType]) {
                     itemGroups[itemType].push(type);
                 }
             });
             const sortedItems = [...itemGroups.buff.sort(), ...itemGroups.debuff.sort(), ...itemGroups.map_effect.sort()];
         
             const grid = document.getElementById('ban-pick-grid');
             grid.innerHTML = '';
             sortedItems.forEach(type => {
                 const itemDiv = document.createElement('div');
                 itemDiv.id = `bp-item-${type}`;
                 itemDiv.className = 'ban-pick-item selectable';
                 let typeIcon = '';
                 if(ITEM_CONFIG[type].type === 'buff') typeIcon = `<div class="type-icon text-green-400">▲</div>`
                 else if (ITEM_CONFIG[type].type === 'debuff') typeIcon = `<div class="type-icon text-red-400">▼</div>`
                 else if (ITEM_CONFIG[type].type === 'map_effect') typeIcon = `<div class="type-icon text-yellow-400">♦</div>`
                 
                 itemDiv.innerHTML = `${ICONS[type]}${typeIcon}<div class="overlay">/</div>`;
         
                 const isTouchDevice = 'ontouchstart' in window;
                 if (isTouchDevice) {
                     itemDiv.addEventListener('click', () => handleBanPickSelection(type));
                 } else {
                     itemDiv.onclick = () => handleBanPickSelection(type);
                     itemDiv.onmouseenter = (e) => showTooltip(e, type);
                     itemDiv.onmouseleave = hideTooltip;
                 }
                 grid.appendChild(itemDiv);
             });
             updateBanPickUI();
         }
         
         function showTooltip(event, type) {
             const item = ITEM_CONFIG[type];
             let statsHTML = `<p class="text-gray-400 text-sm mt-1">Hồi chiêu: ${item.baseRespawn / 1000}s</p>`;
             if (item.stats && Object.keys(item.stats).length > 0) {
                 statsHTML += `<div class="mt-2 border-t border-gray-600 pt-2">`;
                 for (const [key, value] of Object.entries(item.stats)) {
                     statsHTML += `<p class="text-sm"><span class="font-semibold text-gray-300">${key}:</span> ${value}</p>`;
                 }
                 statsHTML += `</div>`;
             }
             tooltip.innerHTML = `<h4 class="font-bold mb-1">${item.name}</h4><p class="text-gray-400">${item.desc}</p>${statsHTML}`;
             tooltip.style.opacity = '1';
             
             const tooltipRect = tooltip.getBoundingClientRect();
             const margin = 15;
             let left = event.clientX + margin;
             let top = event.clientY + margin;
         
             if (left + tooltipRect.width > window.innerWidth) {
                 left = event.clientX - tooltipRect.width - margin;
             }
             if (top + tooltipRect.height > window.innerHeight) {
                 top = event.clientY - tooltipRect.height - margin;
             }
             if (left < 0) left = margin;
             if (top < 0) top = margin;
             
             tooltip.style.left = `${left}px`;
             tooltip.style.top = `${top}px`;
         }
         function hideTooltip() { tooltip.style.opacity = '0'; }
         
         function updateBanPickUI() {
             const title = document.getElementById('ban-pick-title');
             const mobileInfo = document.getElementById('ban-pick-info-mobile');
             const p1PicksDiv = document.getElementById('p1-picks');
             const p2PicksDiv = document.getElementById('p2-picks');
             const p1BansDiv = document.getElementById('p1-bans');
             const p2BansDiv = document.getElementById('p2-bans');
             
             document.querySelectorAll('.pulsing-slot').forEach(el => el.classList.remove('pulsing-slot'));
             document.querySelectorAll('.border-yellow-400').forEach(el => el.classList.remove('border-yellow-400'));
         
             const renderSlots = (container, items, maxSlots, isBan = false) => {
                 container.innerHTML = '';
                 for (let i = 0; i < maxSlots; i++) {
                     let content = '';
                     if (items[i]) {
                         content = ICONS[items[i]].replace('h-8 w-8', 'h-full w-full');
                         if (isBan) {
                             content += '<div class="absolute inset-0 bg-red-800 bg-opacity-70 flex items-center justify-center text-white text-3xl font-bold">/</div>';
                         }
                     }
                     const banClass = isBan ? 'p-1 aspect-square bg-gray-900 border-2 border-gray-700 rounded flex justify-center items-center relative' : 'p-1 aspect-square bg-gray-900 border-2 border-dashed border-gray-700 rounded flex justify-center items-center';
                     container.innerHTML += `<div class="${banClass}">${content}</div>`;
                 }
             };
         
             renderSlots(p1BansDiv, banPickState.p1Bans, 2, true);
             renderSlots(p2BansDiv, banPickState.p2Bans, 2, true);
             renderSlots(p1PicksDiv, banPickState.p1Picks, 3);
             renderSlots(p2PicksDiv, banPickState.p2Picks, 3);
         
             const currentStep = banPickSequence[banPickState.currentIndex];
             if (currentStep) {
                 const isP1 = currentStep.player === 1;
                 const phaseText = currentStep.phase === 'ban' ? 'Cấm' : 'Chọn';
                 title.className = 'text-2xl md:text-3xl font-bold';
                 title.classList.add(isP1 ? 'text-blue-500' : 'text-red-500');
                 title.textContent = `Người chơi ${currentStep.player} - ${phaseText}`;
         
                 const container = currentStep.phase === 'ban' ? (isP1 ? p1BansDiv : p2BansDiv) : (isP1 ? p1PicksDiv : p2PicksDiv);
                 const itemsList = currentStep.phase === 'ban' ? (isP1 ? banPickState.p1Bans : banPickState.p2Bans) : (isP1 ? banPickState.p1Picks : banPickState.p2Picks);
                 const maxItems = currentStep.phase === 'ban' ? 2 : 3;
         
                 if (itemsList.length < maxItems) {
                     const slot = container.children[itemsList.length];
                     if(slot) slot.classList.add('pulsing-slot');
                 }
             }
             const isTouchDevice = 'ontouchstart' in window;
             if (isTouchDevice && banPickState.selectionCandidate) {
                 const item = ITEM_CONFIG[banPickState.selectionCandidate];
                 
                 let statsParts = [];
                 statsParts.push(`⏳ ${item.baseRespawn / 1000}s`);
         
                 if (item.stats) {
                     for (const [key, value] of Object.entries(item.stats)) {
                         let icon = '🔹'; // Default icon
                         if (key.toLowerCase().includes('thời gian')) icon = '⏱️';
                         if (key.toLowerCase().includes('hiệu ứng')) icon = '✨';
                         if (key.toLowerCase().includes('sát thương')) icon = '💥';
                         if (key.toLowerCase().includes('hồi phục')) icon = '💚';
                         if (key.toLowerCase().includes('kích thước')) icon = '📏';
                         if (key.toLowerCase().includes('tốc độ')) icon = '⚡️';
                         if (key.toLowerCase().includes('độ bền')) icon = '🛠️';
                         
                         statsParts.push(`${icon} ${value}`);
                     }
                 }
                 
                 const statsHTML = `<div class="mt-2 pt-2 border-t border-gray-700 text-sm text-gray-300">${statsParts.join(' • ')}</div>`;
                 
                 mobileInfo.innerHTML = `
                     <p class="font-bold text-lg">${item.name}</p>
                     <p class="text-xs text-gray-400 mb-1">${item.desc}</p>
                     ${statsHTML}
                 `;
         
                 mobileInfo.classList.remove('hidden');
                 title.classList.add('hidden');
             } else {
                 mobileInfo.classList.add('hidden');
                 title.classList.remove('hidden');
             }
         
             const banned = [...banPickState.p1Bans, ...banPickState.p2Bans];
             document.querySelectorAll('.ban-pick-item').forEach(el => {
                 const type = el.id.replace('bp-item-', '');
                 el.classList.remove('banned', 'picked-p1', 'picked-p2', 'selectable', 'opacity-50');
                 if(banPickState.selectionCandidate === type) el.classList.add('border-yellow-400');
                 if (banned.includes(type)) el.classList.add('banned');
                 else if (banPickState.p1Picks.includes(type)) el.classList.add('picked-p1');
                 else if (banPickState.p2Picks.includes(type)) el.classList.add('picked-p2');
                 else el.classList.add('selectable');
             });
         }
         
         function handleBanPickSelection(type) {
             const currentStep = banPickSequence[banPickState.currentIndex];
             if (!currentStep) return;
         
             const banned = [...banPickState.p1Bans, ...banPickState.p2Bans];
             const picked = [...banPickState.p1Picks, ...banPickState.p2Picks];
             if (banned.includes(type) || picked.includes(type)) return;
         
             if (banPickState.selectionCandidate === type) { // Confirm selection
                 if (currentStep.phase === 'ban') {
                     if (currentStep.player === 1) banPickState.p1Bans.push(type);
                     else banPickState.p2Bans.push(type);
                 } else { // Pick
                     if (currentStep.player === 1) banPickState.p1Picks.push(type);
                     else banPickState.p2Picks.push(type);
                 }
                 banPickState.currentIndex++;
                 banPickState.selectionCandidate = null;
         
                 if (banPickState.currentIndex >= banPickSequence.length) {
                     finalizeSelectionsAndStart();
                 } else {
                     updateBanPickUI();
                 }
             } else { // First selection
                 banPickState.selectionCandidate = type;
                 updateBanPickUI();
             }
         }
         
         function finalizeSelectionsAndStart() {
    banPickScreen.classList.add('hidden');
    // FIX: Bỏ logic chọn random commonItems
    
    const activeItemTypes = {};
    // FIX: Chỉ giữ lại weapon và shield làm mặc định, BỎ 'health'
    ['weapon', 'shield'].forEach(type => activeItemTypes[type] = { owner: 'neutral' });
    
    banPickState.p1Picks.forEach(type => activeItemTypes[type] = { owner: 'p1' });
    banPickState.p2Picks.forEach(type => activeItemTypes[type] = { owner: 'p2' });
    
    startCountdown(activeItemTypes);
}
         
         function startCountdown(activeItemTypes) {
             const countdownScreen = document.getElementById('countdown-screen');
             const countdownText = document.getElementById('countdown-text');
             countdownScreen.classList.remove('hidden');
             setupGame(activeItemTypes);
         
             let count = 3;
             countdownText.textContent = count;
         
             const interval = setInterval(() => {
                 count--;
                 if (count > 0) {
                     countdownText.textContent = count;
                 } else if (count === 0) {
                     countdownText.textContent = "Bắt Đầu!";
                     countdownText.classList.remove('text-9xl');
                     countdownText.classList.add('text-7xl');
                 } else {
                     clearInterval(interval);
                     countdownScreen.classList.add('hidden');
                     countdownText.classList.add('text-9xl');
                     countdownText.classList.remove('text-7xl');
                     startGame(); 
                 }
             }, 1000);
         }
         
         function setupGame(activeItemTypes) {
             document.getElementById('top-ui').classList.remove('invisible');
             document.getElementById('bottom-ui').classList.remove('invisible');
             
             players = [];
             const playerRadius = (canvas.width / 25) * 1.4 * 0.7;
             const centerX = canvas.width / 2;
             const centerY = canvas.height / 2;
             const p1Spawn = { x: centerX + centerX / 2, y: centerY / 2 };
             const p2Spawn = { x: centerX / 2, y: centerY + centerY / 2 };
             
             const p1 = new PlayerController('Người chơi 1', '#3b82f6', new PlayerBall(p1Spawn.x, p1Spawn.y, playerRadius));
             p1.balls[0].controller = p1;
             const p2 = new PlayerController('Người chơi 2', '#ef4444', new PlayerBall(p2Spawn.x, p2Spawn.y, playerRadius));
             p2.balls[0].controller = p2;
             players.push(p1, p2);
         
             items = {};
             for (const type in activeItemTypes) {
                 let owner = 'neutral';
                 if(activeItemTypes[type].owner === 'p1') owner = p1;
                 if(activeItemTypes[type].owner === 'p2') owner = p2;
                 items[type] = { ...ITEM_CONFIG[type], owner: owner, item: null, cooldownEndTime: Date.now() + INITIAL_SPAWN_TIME, initialCooldownUsed: false };
             }
             
             updateLivesUI(); 
             updatePlayerStatusUI();
             updateCooldownUI();
         updateScoreUI();
         
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             getAllPlayerBalls().forEach(ball => ball.draw());
         }
         
         function startGame() {
         requestWakeLock();
             gameEndTime = Date.now() + TOTAL_GAME_TIME;
             for (const type in items) {
                 const timeoutId = setTimeout(() => {
                     spawnItem(type);
                     items[type].initialCooldownUsed = true;
                 }, INITIAL_SPAWN_TIME);
                 itemSpawnTimeouts.push(timeoutId);
             }
             animationFrameId = requestAnimationFrame(gameLoop);
         }
         
         window.addEventListener('resize', init);
         startButton.addEventListener('click', showBanPickPhase);
         restartButton.addEventListener('click', init);
         document.addEventListener('visibilitychange', async () => {
         // Nếu người dùng quay lại tab và game đang chạy (animationFrameId tồn tại)
         if (document.visibilityState === 'visible' && animationFrameId) {
         await requestWakeLock();
         }
         });
         init();
      </script>
   </body>
</html>
