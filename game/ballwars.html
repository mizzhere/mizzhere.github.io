<!DOCTYPE html>
<html lang="vi">
   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
      <title>Đấu Trường Sinh Tử</title>
      <script src="https://cdn.tailwindcss.com"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
      <style>
         @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
         html, body {
         margin: 0; padding: 0; overflow: hidden;
         height: 100dvh; width: 100dvw;
         background-color: #0a0a0a;
         font-family: 'Inter', sans-serif;
         font-size: 16px; /* Set base font size for rem calculation */
         }
         #game-container {
         display: flex; flex-direction: column; justify-content: center; align-items: center;
         height: 100%; width: 100%; padding: 1rem; box-sizing: border-box;
         position: relative;
         }
         canvas {
         background-color: #2d3748; border: 2px solid #a0aec0; border-radius: 0.5rem;
         box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
         max-width: 100%; max-height: 100%; aspect-ratio: 1 / 1;
         transition: transform 0.1s ease-out;
         }
         .screen-overlay {
         position: absolute;
         top: 0; left: 0; right: 0; bottom: 0;
         background-color: rgba(10, 10, 10, 0.85);
         display: flex;
         flex-direction: column;
         justify-content: center;
         align-items: center;
         text-align: center;
         z-index: 10;
         backdrop-filter: blur(8px);
         opacity: 0;
         pointer-events: none;
         transition: opacity 0.4s ease-in-out;
         }
         .screen-overlay.visible {
         opacity: 1;
         pointer-events: auto;
         }
         .dialog-card {
         background-color: #1a1a1d;
         padding: 2.5rem;
         border-radius: 0.75rem;
         border: 1px solid rgba(255, 255, 255, 0.1);
         box-shadow: 0 10px 25px -5px rgba(0,0,0,0.3), 0 10px 10px -5px rgba(0,0,0,0.2);
         width: clamp(18.75rem, 90vw, 62.5rem);
         animation: fadeInScale 0.5s cubic-bezier(0.165, 0.84, 0.44, 1) forwards;
         }
         @keyframes fadeInScale {
         from { opacity: 0; transform: scale(0.95); }
         to { opacity: 1; transform: scale(1); }
         }
         .material-button {
         text-transform: uppercase;
         letter-spacing: 1.25px;
         font-weight: 500;
         box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14), 0 3px 1px -2px rgba(0,0,0,0.12), 0 1px 5px 0 rgba(0,0,0,0.2);
         transition: all 0.2s ease;
         }
         .material-button:active {
         box-shadow: 0 4px 5px 0 rgba(0,0,0,0.14), 0 1px 10px 0 rgba(0,0,0,0.12), 0 2px 4px -1px rgba(0,0,0,0.2);
         transform: translateY(1px);
         }
         .material-button:disabled {
         background-color: #4a5568;
         cursor: not-allowed;
         box-shadow: none;
         transform: none;
         }
         .cooldown-circle {
         position: relative; width: 2.25rem; height: 2.25rem;
         }
         .cooldown-circle svg { transform: rotate(-90deg); }
         .cooldown-circle .icon { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(90deg); }
         .cooldown-circle .text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.8125rem; font-weight: bold; }
         .ban-pick-item { position: relative; padding: 0.5rem; border-radius: 0.5rem; cursor: pointer; transition: all 0.2s ease; background-color: rgba(255, 255, 255, 0.05); border: 2px solid transparent; }
         .ban-pick-item.selectable:hover { border-color: rgba(255, 255, 255, 0.5); transform: translateY(-2px) scale(1.05); }
         .ban-pick-item .overlay { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; font-size: 2rem; color: #ef4444; border-radius: 0.5rem; font-weight: bold; opacity: 0; transition: opacity 0.2s ease; }
         .ban-pick-item.banned .overlay { opacity: 1; }
         .ban-pick-item.picked-p1 { border-color: #3b82f6; transform: scale(1.05); }
         .ban-pick-item.picked-p2 { border-color: #ef4444; transform: scale(1.05); }
         .ban-pick-item .type-icon { position: absolute; bottom: 2px; right: 2px; width: 1rem; height: 1rem; background-color: rgba(0,0,0,0.7); border-radius: 50%; display: flex; justify-content: center; align-items: center; }
         #tooltip { position: fixed; background-color: #1a1a1d; border: 1px solid rgba(255,255,255,0.2); border-radius: 0.5rem; padding: 1rem; max-width: 15.625rem; z-index: 99; pointer-events: none; opacity: 0; transition: opacity 0.2s ease, transform 0.2s ease; transform-origin: top left; }
         .animate-pulse-fast { animation: pulse 0.5s cubic-bezier(0.4, 0.6, 1) infinite; }
         @keyframes pulse { 50% { opacity: .5; } }
         @keyframes pulse-border { 50% { border-color: rgba(255, 255, 255, 0.6); } }
         .pulsing-slot { animation: pulse-border 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
         /* Intro Screen Animations */
         @keyframes slideInFromLeft { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
         @keyframes slideInFromRight { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
         @keyframes slideInFromTop { from { transform: translateY(-100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
         @keyframes slideInFromBottom { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
         @keyframes fadeInVS { from { transform: scale(2); opacity: 0; } to { transform: scale(1); opacity: 1; } }
         .intro-p1 { animation: slideInFromLeft 0.8s 0.2s cubic-bezier(0.25, 1, 0.5, 1) forwards; }
         .intro-p2 { animation: slideInFromRight 0.8s 0.2s cubic-bezier(0.25, 1, 0.5, 1) forwards; }
         .intro-vs { animation: fadeInVS 0.5s 0.8s ease-out forwards; }
         .intro-item { transition: all 0.3s ease; }
         /* Segmented Control for Options */
         .segmented-control button {
         background-color: #2d3748;
         border: 1px solid #4a5568;
         padding: 0.5rem 1rem;
         color: #a0aec0;
         transition: all 0.2s ease-in-out;
         }
         .segmented-control button.active {
         background-color: #4c51bf;
         color: white;
         border-color: #4c51bf;
         font-weight: bold;
         }
         .segmented-control button:first-child { border-radius: 0.375rem 0 0 0.375rem; }
         .segmented-control button:last-child { border-radius: 0 0.375rem 0.375rem 0; }
         @media (max-width: 768px) {
         #game-container { padding: 0.5rem; }
         #ban-pick-screen .dialog-card { padding: 1rem; display: flex; flex-direction: column; max-height: 90dvh; }
         #ban-pick-screen > div > div { flex-direction: column; }
         #ban-pick-screen .w-1\/4, #ban-pick-screen .w-1\/2 { width: 100%; padding: 0; margin-bottom: 1rem; }
         #ban-pick-screen .text-left, #ban-pick-screen .text-right { text-align: center; }
         #p1-bans, #p1-picks, #p2-bans, #p2-picks { justify-content: center; }
         #ban-pick-header-container { min-height: 0; }
         #ban-pick-grid-container { max-height: 25vh; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #4a5568 #1a1a1d; }
         #ban-pick-grid-container::-webkit-scrollbar { width: 0.5rem; }
         #ban-pick-grid-container::-webkit-scrollbar-track { background: #1a1a1d; }
         #ban-pick-grid-container::-webkit-scrollbar-thumb { background-color: #4a5568; border-radius: 0.25rem; border: 2px solid #1a1a1d; }
         /* Intro Screen Vertical Layout for Mobile */
         #intro-content {
         flex-direction: column;
         gap: 1.5rem;
         justify-content: center;
         align-items: center;
         }
         #intro-p1-panel, #intro-p2-panel {
         width: 90%;
         animation: none; /* Reset desktop animation */
         }
         #intro-content .intro-p1 {
         animation: slideInFromTop 0.8s 0.2s cubic-bezier(0.25, 1, 0.5, 1) forwards;
         order: 1;
         }
         #intro-content .intro-vs {
         order: 2;
         /* Optional: Rotate the VS text for vertical layout */
         transform: rotate(90deg);
         }
         #intro-content .intro-p2 {
         animation: slideInFromBottom 0.8s 0.2s cubic-bezier(0.25, 1, 0.5, 1) forwards;
         order: 3;
         }
         }
      </style>
   </head>
   <body class="text-white">
      <div id="game-container">
         <!-- Series Score UI -->
         <div id="series-score-ui" class="absolute top-0 left-1/2 -translate-x-1/2 z-20 bg-black/30 backdrop-blur-sm p-2 rounded-b-lg hidden">
            <div class="flex items-center space-x-4">
               <span id="series-p1-score" class="text-2xl font-bold text-blue-500">0</span>
               <span id="series-info" class="text-sm text-gray-300 font-semibold">BO3</span>
               <span id="series-p2-score" class="text-2xl font-bold text-red-500">0</span>
            </div>
         </div>
         <div id="top-ui" class="w-full flex flex-col items-center invisible px-2 py-2 md:py-0">
            <div id="player1-info" class="w-full max-w-lg mb-2">
               <div class="flex justify-between items-center">
                  <h2 class="font-bold text-lg text-blue-500 flex items-center"><span>Người chơi 1</span><span id="player1-status-icons" class="flex items-center ml-2 space-x-1"></span></h2>
                  <span id="player1-score" class="font-bold text-2xl text-white bg-black/20 px-3 rounded-md">0</span>
               </div>
               <div id="player1-active-effects" class="flex items-center space-x-2 mt-1 h-6"></div>
               <div id="player1-lives" class="flex items-center space-x-1 mt-1"></div>
            </div>
            <div id="player1-cooldown-timers" class="w-full max-w-lg flex justify-center flex-wrap gap-x-4 gap-y-1 mb-1 text-sm text-gray-300"></div>
            <div id="neutral-cooldown-timers" class="w-full max-w-lg flex justify-center flex-wrap gap-x-4 gap-y-1 text-sm text-gray-300"></div>
         </div>
         <canvas id="gameCanvas" class="my-2"></canvas>
         <div id="bottom-ui" class="w-full flex flex-col items-center invisible px-2 py-2 md:py-0">
            <div id="player2-info" class="w-full max-w-lg mt-2">
               <div class="flex justify-between items-center">
                  <h2 class="font-bold text-lg text-red-500 flex items-center"><span>Người chơi 2</span><span id="player2-status-icons" class="flex items-center ml-2 space-x-1"></span></h2>
                  <span id="player2-score" class="font-bold text-2xl text-white bg-black/20 px-3 rounded-md">0</span>
               </div>
               <div id="player2-active-effects" class="flex items-center space-x-2 mt-1 h-6"></div>
               <div id="player2-lives" class="flex items-center space-x-1 mt-1"></div>
            </div>
            <div id="player2-cooldown-timers" class="w-full max-w-lg flex justify-center flex-wrap gap-x-4 gap-y-1 mt-2 text-sm text-gray-300"></div>
         </div>
         <!-- Overlays -->
         <div id="start-screen" class="screen-overlay visible">
            <div class="dialog-card">
               <h1 class="text-4xl md:text-5xl font-bold mb-8 text-gray-100">Đấu Trường Sinh Tử</h1>
               <div class="space-y-6">
                  <div>
                     <h2 class="text-lg font-semibold mb-2 text-gray-300">Chế độ chơi</h2>
                     <div id="game-mode-selector" class="segmented-control flex justify-center">
                        <button data-mode="ban-pick" class="active">Cấm & Chọn</button>
                        <button data-mode="random">Ngẫu Nhiên</button>
                     </div>
                  </div>
                  <div>
                     <h2 class="text-lg font-semibold mb-2 text-gray-300">Thể thức</h2>
                     <div id="series-selector" class="segmented-control flex justify-center">
                        <button data-series="1" class="active">1 Trận (Bo1)</button>
                        <button data-series="3">3 Trận (Bo3)</button>
                        <button data-series="5">5 Trận (Bo5)</button>
                     </div>
                  </div>
               </div>
               <div class="mt-10 flex flex-col md:flex-row gap-4 justify-center">
                  <button id="start-button" class="material-button bg-blue-600 hover:bg-blue-700 text-white py-3 px-6 rounded-lg text-xl w-full md:w-auto">Bắt đầu</button>
                  <button id="load-last-game-button" class="material-button bg-gray-600 hover:bg-gray-700 text-white py-3 px-6 rounded-lg text-xl w-full md:w-auto">Tải Lần Chơi Trước</button>
               </div>
            </div>
         </div>
         <div id="ban-pick-screen" class="screen-overlay">
            <div class="dialog-card">
               <div class="flex justify-between w-full">
                  <div class="w-1/4 text-left">
                     <h3 class="text-lg font-bold text-blue-500">CẤM</h3>
                     <div id="p1-bans" class="flex space-x-2 mt-2 h-12"></div>
                     <h3 class="text-lg font-bold text-blue-500 mt-4">CHỌN</h3>
                     <div id="p1-picks" class="flex space-x-2 mt-2 h-12"></div>
                  </div>
                  <div class="w-1/2 px-4 flex flex-col">
                     <div id="ban-pick-header-container" class="text-center mb-4 flex flex-col justify-center min-h-[112px] md:min-h-0">
                        <h2 id="ban-pick-title" class="text-2xl md:text-3xl font-bold text-gray-100"></h2>
                        <div id="ban-pick-info-mobile" class="hidden md:hidden p-2 bg-gray-900 rounded-lg text-left"></div>
                     </div>
                     <div id="ban-pick-grid-container" class="flex-grow">
                        <div id="ban-pick-grid" class="grid grid-cols-4 gap-4 p-2""></div>
                     </div>
                  </div>
                  <div class="w-1/4 text-right">
                     <h3 class="text-lg font-bold text-red-500">CẤM</h3>
                     <div id="p2-bans" class="flex space-x-2 mt-2 justify-end h-12"></div>
                     <h3 class="text-lg font-bold text-red-500 mt-4">CHỌN</h3>
                     <div id="p2-picks" class="flex space-x-2 mt-2 justify-end h-12"></div>
                  </div>
               </div>
            </div>
         </div>
         <div id="intro-screen" class="screen-overlay bg-black/90">
            <div id="intro-content" class="w-full max-w-4xl mx-auto flex justify-between items-center relative">
               <div id="intro-p1-panel" class="intro-p1 w-2/5 flex flex-col items-center"></div>
               <div class="intro-vs text-7xl font-bold text-gray-400 opacity-0">VS</div>
               <div id="intro-p2-panel" class="intro-p2 w-2/5 flex flex-col items-center"></div>
            </div>
            <div id="intro-countdown" class="absolute text-9xl font-bold text-white opacity-0" style="text-shadow: 0 0 20px rgba(0,0,0,0.5);"></div>
         </div>
         <div id="game-over-screen" class="screen-overlay">
            <div class="dialog-card">
               <h2 id="winner-text" class="text-4xl font-bold mb-4"></h2>
               <div id="results-details" class="my-6 text-lg"></div>
               <div id="series-results-details" class="my-6 text-lg"></div>
               <button id="next-match-button" class="material-button mt-4 bg-blue-600 hover:bg-blue-700 text-white py-3 px-6 rounded-lg text-xl hidden">Trận Tiếp Theo</button>
               <button id="restart-button" class="material-button mt-4 bg-green-600 hover:bg-green-700 text-white py-3 px-6 rounded-lg text-xl">Chơi Lại</button>
            </div>
         </div>
      </div>
      <div id="tooltip"></div>
      <script>
         // --- CONSTANTS AND CONFIGURATIONS ---
         const ICONS = { weapon: `<svg class="h-8 w-8 text-yellow-400" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l2.5 6.5L21 9l-5 4.5L17 21l-5-3.5L7 21l1-7.5L3 9l6.5-.5L12 2z"/></svg>`, superSpike: `<svg class="h-8 w-8 text-orange-500" viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L9 9l-8 3 8 3 3 8 3-8 8-3-8-3-3-8z"/></svg>`, health: `<svg class="h-8 w-8 text-green-400" viewBox="0 0 24 24" fill="currentColor"><path d="M19 11h-6V5h-2v6H5v2h6v6h2v-6h6z"/></svg>`, bomb: `<svg class="h-8 w-8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="14" r="8" fill="#4a5568"/><rect x="10" y="3" width="4" height="4" rx="1" fill="#2d3748"/><circle cx="12" cy="2" r="1.5" fill="#ef4444"/></svg>`, shield: `<svg class="h-8 w-8 text-sky-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z"/></svg>`, grow: `<svg class="h-8 w-8 text-blue-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 8l-6 6h12l-6-6z"/></svg>`, shrink: `<svg class="h-8 w-8 text-orange-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 16l6-6H6l6 6z"/></svg>`, speedBoost: `<svg class="h-8 w-8 text-teal-400" viewBox="0 0 24 24" fill="currentColor"><path d="M13 2L3 14h9l-1 8 11-12h-9z"/></svg>`, rain: `<svg class="h-8 w-8 text-blue-300" viewBox="0 0 24 24" fill="currentColor"><path d="M19.35 10.04A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.04A5.994 5.994 0 0 0 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM9 19H7v-4h2v4zm4 0h-2v-4h2v4zm4 0h-2v-4h2v4z"/></svg>`, invisibility: `<svg class="h-8 w-8 text-gray-400" viewBox="0 0 24 24" fill="currentColor"><path d="M12,2A9,9 0 0,0 3,11V22L6,19L9,22L12,19L15,22L18,19L21,22V11A9,9 0 0,0 12,2M9,8A2,2 0 0,1 11,10A2,2 0 0,1 9,12A2,2 0 0,1 7,10A2,2 0 0,1 9,8M15,8A2,2 0 0,1 17,10A2,2 0 0,1 15,12A2,2 0 0,1 13,10A2,2 0 0,1 15,8Z" /></svg>`, wallSpikes: `<svg class="h-8 w-8 text-red-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 20h20v2H2v-2zM3.414 4L12 12.586 20.586 4 22 5.414 13.414 14 22 22.586 20.586 24 12 15.414 3.414 24 2 22.586 10.586 14 2 5.414 3.414 4z"/></svg>`, diagonalWall: `<svg class="h-8 w-8 text-indigo-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 21.0001L21 3.00006L19.5 1.50006L1.5 19.5L3 21.0001Z"/></svg>`, clone: `<svg class="h-8 w-8 text-purple-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 3a9 9 0 0 0-9 9 9 9 0 0 0 9 9 9 9 0 0 0 9-9 9 9 0 0 0-9-9zm0 16a7 7 0 0 1-7-7 7 7 0 0 1 7-7 7 7 0 0 1 7 7 7 7 0 0 1-7 7zm-3-7a3 3 0 1 1 6 0 3 3 0 0 1-6 0z"/></svg>`, cannotEat: `<svg class="h-8 w-8 text-green-300" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8zm-2.8-10.2L11 11.6V8h2v5.1l-1.8 1.8-1.4-1.4 1.2-1.2-3.8-3.7z"/></svg>`, laserGun: `<svg class="h-8 w-8 text-pink-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M6 2L8 8H2V6H4.6L2.8 2.8L4.2 1.4L6 2M2 16H8L6 22L4.2 20.6L2.8 21.2L4.6 18H2V16M9 3H15V5H9V3M20.6 1.4L19.2 2.8L21.4 6H18V8H24L22 2L20.6 1.4M15 19H9V21H15V19M22 16H18V18H21.4L19.2 21.2L20.6 22.6L24 16Z"/></svg>`, slow: `<svg class="h-8 w-8 text-amber-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="m15 5-1.41 1.41L15 7.83V14.17l-1.41-1.41L12.17 14 17 18.83 21.83 14 20.41 12.59 19 14.17V7.83l1.41 1.41L21.83 8 17 3.17 12.17 8l1.41 1.41L15 7.83zM7 5l-1.41 1.41L7 7.83v6.34l-1.41-1.41L4.17 14 9 18.83 13.83 14 12.41 12.59 11 14.17V7.83l1.41 1.41L13.83 8 9 3.17 4.17 8l1.41 1.41L7 7.83z"/></svg>`, homingMissile: `<svg class="h-8 w-8 text-orange-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L9.91 5.95L6 6.18L8.73 9.09L8.09 13.05L12 11L15.91 13.05L15.27 9.09L18 6.18L14.09 5.95L12 2M22 13V15H17V13H22M2 13V15H15V13H2Z" /></svg>`, reflectiveCloak: `<svg class="h-8 w-8 text-fuchsia-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L1 9l4 1.5V21h14v-9.5L23 9l-11-7zm0 2.5l7 4.5-2 .75V19H7v-9.25L5 8l7-4.5zM9 13v2h6v-2H9z"/></svg>`, thieuThan: `<svg class="h-8 w-8 text-orange-500" viewBox="0 0 24 24" fill="currentColor"><path d="M9.1 5.2c1.3-2.1 3.1-3.7 5.2-4.5-1.2.9-2.1 2.2-2.7 3.7-1.1.2-2.1.6-2.9 1.2.4-.8.6-1.7.4-2.4zM16 3c.3.5.5 1.1.5 1.7 0 .5-.1 1-.3 1.5.8.5 1.5 1.2 1.9 2.1-.3-.1-.5-.2-.8-.3-.9-.2-1.8-.1-2.6.3.3-1 .5-2.1.2-3.1-.3-.8-.8-1.5-1.4-2 .8.3 1.5.8 2.5 1.8zM8.2 8.9c-.3.4-.6.8-.8 1.3-.2.9-.1 1.8.3 2.6.4.8 1 1.5 1.8 2 .3-.7.5-1.4.5-2.2 0-1.4-.5-2.8-1.4-3.9-.1 0-.2-.1-.4-.2zM15.1 11.8c-.8.7-1.3 1.6-1.5 2.6-.1.6 0 1.2.2 1.8.8.1 1.6-.2 2.2-.7.9-.7 1.4-1.7 1.5-2.8 0-.3 0-.6-.1-.9-.6-.2-1.2-.5-1.9-1.2-.2.1-.3.2-.4.2zM8.8 15.3c-.5.8-1.2 1.5-2.1 1.9.1-.3.2-.5.3-.8.2-1 .1-1.9-.3-2.7-.4-.8-1-1.5-1.8-2 .7-.3 1.5-.5 2.2-.5 1.4 0 2.8.5 3.9 1.4.1.2.2.3.2.4-.7.5-1.4 1-2.1 2.3zm8.3 1.9c.4.3.8.6 1.3.8.9.2 1.8.1 2.6-.3.8-.4 1.5-1 2-1.8-.7.3-1.4.5-2.2.5-1.4 0-2.8-.5-3.9-1.4-.2-.1-.3-.2-.4-.2.5.8 1.1 1.5 1.8 2.2.1.1.2.1.4.2z"/></svg>`, snare: `<svg class="h-8 w-8 text-lime-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,4A8,8 0 0,1 20,12H17A5,5 0 0,0 12,7V4M4,12A8,8 0 0,1 12,4V7A5,5 0 0,0 7,12H4M12,20A8,8 0 0,1 4,12H7A5,5 0 0,0 12,17V20M20,12A8,8 0 0,1 12,20V17A5,5 0 0,0 17,12H20Z" /></svg>`,dart: `<svg class="h-8 w-8 text-cyan-400"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round">  <line x1="22" y1="2" x2="11" y2="13" />  <polygon points="22 2 15 22 11 13 2 9 22 2" /></svg>`,
         poison: `<svg class="h-8 w-8 text-lime-500" viewBox="0 0 24 24" fill="currentColor"><path d="M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" /></svg>`,};
         const ITEM_COLORS = { weapon: '#f6e05e', superSpike: '#ff4500', health: '#48bb78', bomb: '#f56565', shield: '#38bdf8', grow: '#63b3ed', shrink: '#f6ad55', speedBoost: '#4fd1c5', rain: '#3b82f6', invisibility: '#9ca3af', wallSpikes: '#ef4444', diagonalWall: '#818cf8', clone: '#c084fc', cannotEat: '#86efac', laserGun: '#f472b6', slow: '#f59e0b', homingMissile: '#f97316', reflectiveCloak: '#e879f9', thieuThan: '#f97316', snare: '#a3e635',dart: '#22d3ee',
         poison: '#84cc16', };
         const ITEM_CONFIG = {
         weapon: { name: 'Vũ Khí Gai', baseRespawn: 10000, type: 'neutral', desc: 'Nhận một lớp gai tồn tại trong 5s. Va chạm với đối thủ sẽ gây 1 sát thương.', stats: { 'Thời gian': '5s', 'Sát thương': '1' } }, 
         superSpike: { name: 'Gai Siêu Cấp', baseRespawn: 20000, type: 'buff', desc: 'Nhận 1 gai siêu cấp tồn tại 5s. Gây 2 sát thương khi va chạm. Phá vỡ giáp và vẫn gây 1 sát thương. Phản đòn sẽ nhận lại 2 sát thương.', stats: { 'Thời gian': '5s', 'Sát thương': '2' } },
         health: { name: 'Hồi Máu', baseRespawn: 10000, type: 'neutral', desc: 'Hồi lại 1 mạng nếu chưa đầy máu. Không tự biến mất.', stats: { 'Hồi phục': '+1 Mạng' } }, 
         shield: { name: 'Khiên', baseRespawn: 10000, type: 'neutral', desc: 'Nhận 1 lớp khiên chặn đòn tấn công hoặc hiệu ứng bất lợi tiếp theo.', stats: { 'Hiệu ứng': 'Chặn 1 đòn' } }, 
         bomb: { name: 'Bom', baseRespawn: 5000, type: 'debuff', desc: 'Đặt một quả bom trên bản đồ. Đối thủ của người nhặt sẽ bị mất mạng nếu chạm phải.', stats: {} },
         reflectiveCloak: { name: 'Áo Choàng Phản', baseRespawn: 15000, type: 'buff', desc: 'Tồn tại 10s hoặc đến khi bị tấn công, sẽ phản lại sát thương cho đối thủ.', stats: { 'Thời gian': '10s', 'Hiệu ứng': '1 lần phản đòn'} },
         snare: { name: 'Trói Chân', baseRespawn: 15000, type: 'debuff', desc: 'Đặt một chiếc bẫy. Đối thủ của người nhặt sẽ bị trói chân trong 3 giây nếu dẫm phải.', stats: { 'Thời gian trói': '3s'} },
         grow: { name: 'Phóng To', baseRespawn: 12000, type: 'debuff', desc: 'Phóng to kích thước của đối thủ.', stats: { 'Thời gian': '10s', 'Kích thước': '+25%' } }, 
         shrink: { name: 'Thu Nhỏ', baseRespawn: 12000, type: 'buff', desc: 'Thu nhỏ kích thước bản thân.', stats: { 'Thời gian': '10s', 'Kích thước': '-25%' } }, 
         speedBoost: { name: 'Tăng Tốc', baseRespawn: 12000, type: 'buff', desc: 'Tăng mạnh tốc độ di chuyển.', stats: { 'Thời gian': '5s', 'Tốc độ': '+50%' } }, 
         slow: { name: 'Làm Chậm', baseRespawn: 12000, type: 'debuff', desc: 'Giảm tốc độ di chuyển của đối thủ.', stats: { 'Thời gian': '5s', 'Tốc độ': '-50%'}},
         rain: { name: 'Mưa bom', baseRespawn: 10000, type: 'debuff', desc: 'Tạo một vùng mưa gây sát thương lên đối thủ.', stats: { 'Thời gian': '5s', 'Sát thương': '3 lần' } }, 
         invisibility: { name: 'Tàng Hình', baseRespawn: 15000, type: 'buff', desc: 'Trở nên bất tử, miễn nhiễm sát thương.', stats: { 'Thời gian': '3s' } },
         wallSpikes: { name: 'Tường Gai', baseRespawn: 15000, type: 'map_effect', desc: 'Tạo gai trên một cạnh tường ngẫu nhiên. Người nhặt sẽ luôn miễn nhiễm.', stats: { 'Độ bền': '1 lần chạm' } }, 
         diagonalWall: { name: 'Tường Chéo', baseRespawn: 20000, type: 'map_effect', desc: 'Tạo một bức tường chéo ở góc.', stats: { 'Độ bền': '5 lần chạm' } }, 
         clone: { name: 'Phân Thân', baseRespawn: 15000, type: 'buff', desc: 'Tạo ra một bản sao của bản thân. Các bản thể chia sẻ chung trạng thái.', stats: { 'Tối đa': '3 bản thể' } },
         cannotEat: { name: 'Cấm Ăn', baseRespawn: 10000, type: 'debuff', desc: 'Khiến đối thủ không thể nhặt vật phẩm.', stats: { 'Thời gian': '5s' } },
         laserGun: { name: 'Súng Laze', baseRespawn: 20000, type: 'debuff', desc: 'Bắn một tia laze bật tường gây sát thương cho đối thủ.', stats: { 'Thời gian': '2s', 'Bật tường': '5 lần' }},
         // Dán 2 khối này vào trong ITEM_CONFIG
         
         dart: { name: 'Phi Tiêu', baseRespawn: 20000, type: 'debuff', desc: 'Ném ra một phi tiêu bật tường 4 lần. Gây 1 sát thương, xuyên giáp và không thể bị phản đòn.', stats: { 'Số lần bật tường': '4', 'Sát thương': '1 (Xuyên giáp)' } },
         poison: { name: 'Thuốc Độc', baseRespawn: 20000, type: 'buff', desc: 'Trong 15s, chạm vào đối thủ 2 lần sẽ khiến họ bị trúng độc. Sau 10s, người bị trúng độc sẽ mất 1 mạng (có thể bị chặn bởi khiên).', stats: { 'Thời gian hiệu lực': '15s', 'Số lần chạm': '2', 'Thời gian độc': '10s' } },
         thieuThan: { name: 'Thiêu Thân', baseRespawn: 10000, type: 'buff', desc: 'Tự động lao về phía đối thủ với tốc độ tăng dần khi đang có Vũ Khí Gai. Hiệu ứng kết thúc khi va chạm thành công.', stats: { 'Tốc độ tối đa': 'x1.25', 'Điều kiện': 'Phải có Vũ Khí Gai' } },
         homingMissile: { name: 'Tên Lửa', baseRespawn: 15000, type: 'debuff', desc: 'Bắn một tên lửa bám đuổi đối thủ. Nổ khi va chạm tường.', stats: {'Tồn tại': '10s'}}
         };
         const banPickSequence = [ { phase: 'ban', player: 1 }, { phase: 'ban', player: 2 }, { phase: 'pick', player: 1 }, { phase: 'pick', player: 2 }, { phase: 'pick', player: 1 }, { phase: 'ban', player: 2 }, { phase: 'ban', player: 1 }, { phase: 'pick', player: 2 }, { phase: 'pick', player: 2 }, { phase: 'pick', player: 1 } ];
         const TOTAL_GAME_TIME = 90 * 1000;
         const INITIAL_SPAWN_TIME = 5000;
         
         // --- CLASSES ---
         
         class SoundManager {
         constructor() { this.synth = null; this.polySynth = null; this.noise = null; this.isInitialized = false; }
         async init() { if (typeof Tone === 'undefined') { console.warn("Tone.js not loaded."); return; } if (this.isInitialized) return; try { await Tone.start(); this.synth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.2 } }).toDestination(); this.polySynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 0.4 } }).toDestination(); this.noise = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.1 } }).toDestination(); this.isInitialized = true; console.log("Audio context started."); } catch (e) { console.error("Could not start audio context:", e); } }
         _canPlay() { return this.isInitialized && typeof Tone !== 'undefined' && Tone.context.state === 'running'; }
         playClick() { if (!this._canPlay()) return; this.synth.triggerAttackRelease('C5', '8n'); }
         playSelect() { if (!this._canPlay()) return; this.synth.triggerAttackRelease('E5', '8n'); }
         playStart() { if (!this._canPlay()) return; this.polySynth.triggerAttackRelease(['C4', 'E4', 'G4'], '4n'); }
         playPickup(type) { if (!this._canPlay()) return; this.polySynth.triggerAttackRelease(ITEM_CONFIG[type].type === 'buff' ? ['C5', 'G5'] : ['A4', 'E5'], '16n'); }
         playDamage() { if (!this._canPlay()) return; this.noise.triggerAttackRelease('2n'); this.synth.triggerAttackRelease('A2', '8n', Tone.now() + 0.01); }
         playGameOver(win) { if (!this._canPlay()) return; win ? this.polySynth.triggerAttackRelease(['C5', 'E5', 'G5', 'C6'], '2n') : this.polySynth.triggerAttackRelease(['C3', 'D#3', 'G3'], '2n'); }
         }
         
         class UIManager {
         constructor() { this.dom = {
           canvas: document.getElementById('gameCanvas'), startScreen: document.getElementById('start-screen'), banPickScreen: document.getElementById('ban-pick-screen'), gameOverScreen: document.getElementById('game-over-screen'), introScreen: document.getElementById('intro-screen'),
           winner: { text: document.getElementById('winner-text'), results: document.getElementById('results-details'), seriesResults: document.getElementById('series-results-details') },
           buttons: { start: document.getElementById('start-button'), restart: document.getElementById('restart-button'), nextMatch: document.getElementById('next-match-button'), loadLast: document.getElementById('load-last-game-button') },
           tooltip: document.getElementById('tooltip'), topUI: document.getElementById('top-ui'), bottomUI: document.getElementById('bottom-ui'),
           p1: { lives: document.getElementById('player1-lives'), score: document.getElementById('player1-score'), status: document.getElementById('player1-status-icons'), effects: document.getElementById('player1-active-effects'), cooldowns: document.getElementById('player1-cooldown-timers') },
           p2: { lives: document.getElementById('player2-lives'), score: document.getElementById('player2-score'), status: document.getElementById('player2-status-icons'), effects: document.getElementById('player2-active-effects'), cooldowns: document.getElementById('player2-cooldown-timers') },
           neutralCooldowns: document.getElementById('neutral-cooldown-timers'),
           banPick: { title: document.getElementById('ban-pick-title'), mobileInfo: document.getElementById('ban-pick-info-mobile'), grid: document.getElementById('ban-pick-grid'), p1Bans: document.getElementById('p1-bans'), p2Bans: document.getElementById('p2-bans'), p1Picks: document.getElementById('p1-picks'), p2Picks: document.getElementById('p2-picks') },
           intro: { p1Panel: document.getElementById('intro-p1-panel'), p2Panel: document.getElementById('intro-p2-panel'), countdown: document.getElementById('intro-countdown') },
           series: { ui: document.getElementById('series-score-ui'), p1Score: document.getElementById('series-p1-score'), p2Score: document.getElementById('series-p2-score'), info: document.getElementById('series-info') },
           selectors: { mode: document.getElementById('game-mode-selector'), series: document.getElementById('series-selector') }
         }; this.ctx = this.dom.canvas.getContext('2d'); }
         showScreen(screenName) { ['start', 'banPick', 'gameOver', 'intro'].forEach(s => this.dom[`${s}Screen`].classList.remove('visible')); if (this.dom[`${screenName}Screen`]) this.dom[`${screenName}Screen`].classList.add('visible'); }
         updateLives(players) { const render = (container, player, color) => { container.innerHTML = ''; for (let i = 0; i < 5; i++) container.innerHTML += `<div class="w-4 h-4 ${i < player.lives ? color : 'bg-gray-700'} rounded-full"></div>`; const armorContainer = document.createElement('div'); armorContainer.className = 'flex items-center space-x-1 ml-2'; player.armor.forEach(type => armorContainer.innerHTML += `<div class="w-4 h-4">${ICONS[type].replace('h-8 w-8', 'h-4 w-4')}</div>`); container.appendChild(armorContainer); }; render(this.dom.p1.lives, players[0], 'bg-blue-500'); render(this.dom.p2.lives, players[1], 'bg-red-500'); }
         updateScores(players) { this.dom.p1.score.textContent = players[0].score; this.dom.p2.score.textContent = players[1].score; }
         updatePlayerStatus(players) { const smallIcon = svg => svg ? svg.replace('h-8 w-8', 'h-4 w-4') : ''; 
         
         const update = (player, icons, effects) => { icons.innerHTML = ''; effects.innerHTML = ''; if (player.hasPoisonBuffUntil && Date.now() < player.hasPoisonBuffUntil) {
         icons.innerHTML += `<div class="w-4 h-4 text-lime-500 animate-pulse-fast" title="Đang có buff Thuốc Độc (${player.poisonHits}/2)">${smallIcon(ICONS.poison)}</div>`;
         }
         if (player.isPoisonedUntil && Date.now() < player.isPoisonedUntil) {
         const poisonTimeLeft = Math.ceil((player.isPoisonedUntil - Date.now()) / 1000);
         icons.innerHTML += `<div class="w-4 h-4 text-red-500 animate-pulse-fast" title="Bị trúng độc! Mất mạng sau ${poisonTimeLeft}s">${smallIcon(ICONS.poison)}</div>`;
         } if (player.isThieuThanActive) icons.innerHTML += `<div class="w-4 h-4 text-orange-500 animate-pulse-fast">${smallIcon(ICONS.thieuThan)}</div>`; else if (player.hasThieuThanBuff) icons.innerHTML += `<div class="w-4 h-4 text-gray-600">${smallIcon(ICONS.thieuThan)}</div>`; if (player.hasSpikeWallImmunity) icons.innerHTML += smallIcon(ICONS.wallSpikes); if (player.balls.length > 1) icons.innerHTML += `<span class="text-sm font-bold text-purple-400">x${player.balls.length}</span>`; const now = Date.now(); for (const type in player.timedEffects) { const effect = player.timedEffects[type]; const remaining = effect.endTime - now; if (remaining > 0) { let iconType = type; if (type === 'size') iconType = player.sizeEffect; else if (type === 'speed') iconType = player.speedMultiplier > 1 ? 'speedBoost' : 'slow'; if (ICONS[iconType]) { const progress = (remaining / effect.duration) * 100; effects.innerHTML += `<div class="flex items-center space-x-1 bg-black/30 rounded-full px-2 py-0.5 h-full">${smallIcon(ICONS[iconType])}<div class="w-8 h-1 bg-gray-600 rounded-full overflow-hidden"><div class="h-full bg-white rounded-full" style="width: ${progress}%"></div></div></div>`; } } } }; update(players[0], this.dom.p1.status, this.dom.p1.effects); update(players[1], this.dom.p2.status, this.dom.p2.effects); }
         
         updateCooldowns(items, players) { let nHtml = '', p1Html = '', p2Html = ''; const createCircle = type => { const itemData = items[type]; if (!itemData || !ITEM_CONFIG[type]) return ''; const r = 16, c = 2 * Math.PI * r, endTime = itemData.cooldownEndTime, baseTime = (itemData.initialCooldownUsed) ? itemData.currentRespawn : INITIAL_SPAWN_TIME; let text = '', offset = c; const ownerColor = itemData.owner === players[0] ? '#3b82f6' : (itemData.owner === players[1] ? '#ef4444' : '#a0aec0'); if (endTime && Date.now() < endTime) { const rem = endTime - Date.now(); offset = c * Math.max(0, rem / baseTime); text = Math.ceil(rem / 1000); } else { offset = 0; } return ` <div class="cooldown-circle"><svg class="w-full h-full"><circle cx="18" cy="18" r="${r}" stroke="#4a5568" stroke-width="3" fill="none" /><circle cx="18" cy="18" r="${r}" stroke="${ownerColor}" stroke-width="3" fill="none" stroke-dasharray="${c}" stroke-dashoffset="${offset}" style="transition: stroke-dashoffset 0.25s linear;" /></svg><div class="icon">${!text ? ICONS[type].replace('h-8 w-8', 'h-5 w-5') : ''}</div><div class="text">${text}</div></div> `; }; Object.keys(items).forEach(type => { const i = items[type]; if (!i || !ITEM_CONFIG[type]) return; const h = createCircle(type); if (i.owner === 'neutral') nHtml += h; else if (players[0] && i.owner === players[0]) p1Html += h; else if (players[1] && i.owner === players[1]) p2Html += h; }); this.dom.neutralCooldowns.innerHTML = nHtml; this.dom.p1.cooldowns.innerHTML = p1Html; this.dom.p2.cooldowns.innerHTML = p2Html; }
         setCanvasSize() { const container = document.getElementById('game-container'); const multiplier = window.innerWidth <= 768 ? 0.8 : 0.7; const size = Math.min(container.clientWidth, container.clientHeight) * multiplier; this.dom.canvas.width = size; this.dom.canvas.height = size; }
         toggleGameUI(visible) { const action = visible ? 'remove' : 'add'; this.dom.topUI.classList[action]('invisible'); this.dom.bottomUI.classList[action]('invisible'); }
         showTooltip(event, type) { const item = ITEM_CONFIG[type]; let statsHTML = `<p class="text-gray-400 text-sm mt-1">Hồi chiêu: ${item.baseRespawn / 1000}s</p>`; if (item.stats && Object.keys(item.stats).length > 0) { statsHTML += `<div class="mt-2 border-t border-gray-600 pt-2">`; for (const [key, value] of Object.entries(item.stats)) { statsHTML += `<p class="text-sm"><span class="font-semibold text-gray-300">${key}:</span> ${value}</p>`; } statsHTML += `</div>`; } this.dom.tooltip.innerHTML = `<h4 class="font-bold mb-1">${item.name}</h4><p class="text-gray-400">${item.desc}</p>${statsHTML}`; this.dom.tooltip.style.opacity = '1'; const r = this.dom.tooltip.getBoundingClientRect(), m = 15; let l = event.clientX + m, t = event.clientY + m; if (l + r.width > window.innerWidth) l = event.clientX - r.width - m; if (t + r.height > window.innerHeight) t = event.clientY - r.height - m; this.dom.tooltip.style.left = `${Math.max(m, l)}px`; this.dom.tooltip.style.top = `${Math.max(m, t)}px`; }
         hideTooltip() { this.dom.tooltip.style.opacity = '0'; }
         }
         
         class Particle { constructor(x, y, dx, dy, r, c, life, fr = 1) { this.x = x; this.y = y; this.dx = dx; this.dy = dy; this.radius = r; this.color = c; this.life = life; this.initialLife = life; this.friction = fr; } draw(ctx) { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.globalAlpha = Math.max(0, this.life / this.initialLife); ctx.fillStyle = this.color; ctx.fill(); ctx.globalAlpha = 1; } update() { this.dx *= this.friction; this.dy *= this.friction; this.x += this.dx; this.y += this.dy; this.life--; } }
         class Laser { constructor(startPos, initialDir, owner, canvas) { this.owner = owner; this.startTime = Date.now(); this.endTime = this.startTime + 2000; this.segments = []; this.maxBounces = 5; this.canvas = canvas; this.calculatePath(startPos, initialDir); } calculatePath(currentPos, currentDir) { if (this.segments.length > this.maxBounces) return; let endPoint = null, reflectionDir = { ...currentDir }, minT = Infinity; if (currentDir.y < 0) { let t = -currentPos.y / currentDir.y; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: currentPos.x + t * currentDir.x, y: 0}; reflectionDir = {x: currentDir.x, y: -currentDir.y}; } } if (currentDir.y > 0) { let t = (this.canvas.height - currentPos.y) / currentDir.y; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: currentPos.x + t * currentDir.x, y: this.canvas.height}; reflectionDir = {x: currentDir.x, y: -currentDir.y}; } } if (currentDir.x < 0) { let t = -currentPos.x / currentDir.x; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: 0, y: currentPos.y + t * currentDir.y}; reflectionDir = {x: -currentDir.x, y: currentDir.y}; } } if (currentDir.x > 0) { let t = (this.canvas.width - currentPos.x) / currentDir.x; if (t > 1e-5 && t < minT) { minT = t; endPoint = {x: this.canvas.width, y: currentPos.y + t * currentDir.y}; reflectionDir = {x: -currentDir.x, y: currentDir.y}; } } if (endPoint) { this.segments.push({ p1: currentPos, p2: endPoint }); this.calculatePath(endPoint, reflectionDir); } } draw(ctx) { const lifeLeft = (this.endTime - Date.now()) / 2000; if (lifeLeft < 0) return; ctx.strokeStyle = this.owner.color; ctx.lineWidth = 4; ctx.shadowBlur = 10; ctx.shadowColor = this.owner.color; ctx.globalAlpha = lifeLeft; this.segments.forEach(seg => { ctx.beginPath(); ctx.moveTo(seg.p1.x, seg.p1.y); ctx.lineTo(seg.p2.x, seg.p2.y); ctx.stroke(); }); ctx.globalAlpha = 1; ctx.shadowBlur = 0; } checkCollision(ball) { for (const seg of this.segments) { const A = seg.p1, B = seg.p2, C = { x: ball.x, y: ball.y }, R = ball.radius; let AC = { x: C.x - A.x, y: C.y - A.y }, AB = { x: B.x - A.x, y: B.y - A.y }, magAB2 = AB.x**2 + AB.y**2, dot = AC.x * AB.x + AC.y * AB.y, t = dot / magAB2; let closestX, closestY; if (t < 0) { closestX = A.x; closestY = A.y; } else if (t > 1) { closestX = B.x; closestY = B.y; } else { closestX = A.x + t * AB.x; closestY = A.y + t * AB.y; } if ((C.x - closestX)**2 + (C.y - closestY)**2 < R**2) return true; } return false; } }
         class RainZone { constructor(x, y, r, owner) { this.x = x; this.y = y; this.radius = r; this.owner = owner; this.startTime = Date.now(); this.endTime = this.startTime + 5000; this.drops = [{ t: 1000, tr: false }, { t: 2500, tr: false }, { t: 4000, tr: false }]; } draw(ctx) { const p = (Date.now() - this.startTime) / 5000, a = 0.5 * (1 - p); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = `rgba(56, 189, 248, ${a * 0.5})`; ctx.fill(); ctx.strokeStyle = `rgba(56, 189, 248, ${a})`; ctx.lineWidth = 2; ctx.stroke(); this.drops.forEach(d => { const dT = this.startTime + d.t; if (Date.now() > dT && Date.now() < dT + 200) for(let i=0; i<15; i++) { const rX = this.x + (Math.random() - 0.5) * this.radius * 2, rY = this.y + (Math.random() - 0.5) * this.radius * 2; if(Math.hypot(rX - this.x, rY - this.y) < this.radius) { ctx.beginPath(); ctx.moveTo(rX, rY - 5); ctx.lineTo(rX, rY + 5); ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)'; ctx.lineWidth = 1; ctx.stroke(); } } }); } }
         class DiagonalWall { constructor(canvas) { this.hits = 5; this.corner = Math.floor(Math.random() * 4); const w = canvas.width, h = canvas.height, midW = w/2, midH = h/2; const corners = [ { p1: { x: 0, y: midH }, p2: { x: midW, y: 0 } }, { p1: { x: midW, y: 0 }, p2: { x: w, y: midH } }, { p1: { x: w, y: midH }, p2: { x: midW, y: h } }, { p1: { x: midW, y: h }, p2: { x: 0, y: midH } } ]; this.p1 = corners[this.corner].p1; this.p2 = corners[this.corner].p2; let dx = this.p2.x - this.p1.x, dy = this.p2.y - this.p1.y; this.normal = { x: -dy, y: dx }; const mag = Math.hypot(this.normal.x, this.normal.y); this.normal.x /= mag; this.normal.y /= mag; } draw(ctx) { ctx.beginPath(); ctx.moveTo(this.p1.x, this.p1.y); ctx.lineTo(this.p2.x, this.p2.y); ctx.strokeStyle = `rgba(129, 140, 248, ${0.4 + (this.hits / 5) * 0.6})`; ctx.lineWidth = 5; ctx.stroke(); } }
         class HomingMissile { constructor(owner, target, canvas) { this.owner = owner; this.target = target; const startBall = owner.balls[0]; this.x = startBall.x; this.y = startBall.y; this.baseSpeed = startBall.baseSpeed; this.currentSpeed = this.baseSpeed; this.angle = Math.random() * 2 * Math.PI; this.turnSpeed = 0.04; this.endTime = Date.now() + 10000; this.radius = 5; this.canvas = canvas; } update() { const target = this.target.balls[0]; const targetAngle = Math.atan2(target.y - this.y, target.x - this.x); let angleDiff = targetAngle - this.angle; while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI; while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI; const dist = Math.hypot(this.x - target.x, this.y - target.y); if (Math.abs(angleDiff) > Math.PI / 2) this.currentSpeed = this.baseSpeed * 0.75; else if (dist < this.canvas.width / 4) this.currentSpeed = this.baseSpeed * 1.25; else this.currentSpeed = this.baseSpeed; this.angle += angleDiff * this.turnSpeed; this.x += Math.cos(this.angle) * this.currentSpeed; this.y += Math.sin(this.angle) * this.currentSpeed; return { expired: Date.now() > this.endTime || !this.target.balls.length, wallHit: this.x < 0 || this.x > this.canvas.width || this.y < 0 || this.y > this.canvas.height, targetHit: dist < this.radius + target.radius }; } draw(ctx) { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = this.owner.color; ctx.shadowBlur = 10; ctx.shadowColor = this.owner.color; ctx.beginPath(); ctx.moveTo(this.radius, 0); ctx.lineTo(-this.radius, -this.radius / 1.5); ctx.lineTo(-this.radius, this.radius / 1.5); ctx.closePath(); ctx.fill(); ctx.restore(); ctx.shadowBlur = 0; } }
         class Dart {
         constructor(owner, target, canvas) {
         this.owner = owner;
         const startBall = owner.balls[0];
         const targetBall = target.balls[0];
         
         this.x = startBall.x;
         this.y = startBall.y;
         this.radius = 7;
         this.canvas = canvas;
         this.bounces = 0;
         this.maxBounces = 4; // Bật tường 4 lần
         
         const speed = startBall.baseSpeed * 1.5; // Tốc độ bay
         const angle = Math.atan2(targetBall.y - this.y, targetBall.x - this.x);
         
         this.dx = Math.cos(angle) * speed;
         this.dy = Math.sin(angle) * speed;
         }
         
         update() {
         this.x += this.dx;
         this.y += this.dy;
         
         let bounced = false;
         if (this.x + this.radius > this.canvas.width || this.x - this.radius < 0) {
         this.dx = -this.dx;
         this.x = Math.max(this.radius, Math.min(this.canvas.width - this.radius, this.x));
         bounced = true;
         }
         if (this.y + this.radius > this.canvas.height || this.y - this.radius < 0) {
         this.dy = -this.dy;
         this.y = Math.max(this.radius, Math.min(this.canvas.height - this.radius, this.y));
         bounced = true;
         }
         
         if (bounced) {
         this.bounces++;
         }
         
         return { expired: this.bounces > this.maxBounces };
         }
         
         draw(ctx) {
         ctx.save();
         ctx.translate(this.x, this.y);
         ctx.rotate(Math.atan2(this.dy, this.dx));
         ctx.fillStyle = this.owner.color;
         ctx.shadowBlur = 10;
         ctx.shadowColor = this.owner.color;
         ctx.beginPath();
         ctx.moveTo(this.radius, 0);
         ctx.lineTo(-this.radius, -this.radius / 2);
         ctx.lineTo(-this.radius / 2, 0);
         ctx.lineTo(-this.radius, this.radius / 2);
         ctx.closePath();
         ctx.fill();
         ctx.restore();
         ctx.shadowBlur = 0;
         }
         }
         class PlayerBall {
         constructor(x, y, baseRadius, controller, canvas) { this.controller = controller; this.x = x; this.y = y; this.trail = []; this.baseRadius = baseRadius; this.baseSpeed = (canvas.width / 200) * 4.5 * 0.75 * 0.9; this.speed = this.baseSpeed; let angle = Math.random() * Math.PI * 2; this.dx = Math.cos(angle) * this.speed; this.dy = Math.sin(angle) * this.speed; }
         get radius() { return this.controller.sizeEffect === 'shrink' ? this.baseRadius * 0.75 : (this.controller.sizeEffect === 'grow' ? this.baseRadius * 1.25 : this.baseRadius); }
         get isSnared() { return this.controller.snaredUntil && Date.now() < this.controller.snaredUntil; }
         draw(ctx) { ctx.globalAlpha = 1; if (this.controller.invincibleUntil && Date.now() < this.controller.invincibleUntil) if (Math.floor(Date.now() / 150) % 2 === 0) ctx.globalAlpha = 0.5;  if (this.controller.speedMultiplier > 1 && this.trail.length > 1) { // <-- Sửa thành this.trail
         ctx.beginPath();
         ctx.moveTo(this.trail[0].x, this.trail[0].y); // <-- Sửa thành this.trail
         for(let i = 1; i < this.trail.length; i++) { // <-- Sửa thành this.trail
         const p = this.trail[i];  ctx.globalAlpha = (i / this.controller.trail.length) * 0.4; ctx.lineTo(p.x, p.y); } ctx.strokeStyle = ITEM_COLORS.speedBoost; ctx.lineWidth = this.radius * 0.6; ctx.lineCap = 'round'; ctx.stroke(); ctx.globalAlpha = 1; } this.controller.armor.forEach((type, i) => { if (type === 'weapon' || type === 'superSpike') return; const armorRadius = this.radius + 5 + (i * 4); ctx.beginPath(); ctx.arc(this.x, this.y, armorRadius, 0, Math.PI * 2); ctx.strokeStyle = ITEM_COLORS[type] || '#fff'; ctx.lineWidth = 2; ctx.stroke(); }); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.controller.color; ctx.fill(); const weaponType = this.controller.armor.find(a => a === 'weapon' || a === 'superSpike'); if (weaponType) { const isSuper = weaponType === 'superSpike'; const spikes = isSuper ? 12 : 8, step = (Math.PI*2)/spikes, len = this.radius * (isSuper ? 0.7 : 0.6), rot = (Date.now()/(isSuper?100:150)); ctx.strokeStyle = ITEM_COLORS[weaponType]; ctx.lineWidth = isSuper ? 4 : 3; ctx.beginPath(); for(let i=0;i<spikes;i++){const a=i*step+rot,sX=this.x+Math.cos(a)*this.radius,sY=this.y+Math.sin(a)*this.radius,eX=this.x+Math.cos(a)*(this.radius+len),eY=this.y+Math.sin(a)*(this.radius+len); ctx.moveTo(sX,sY);ctx.lineTo(eX,eY);} ctx.stroke(); } if (this.controller.sizeEffect) { ctx.strokeStyle = this.controller.sizeEffect === 'grow' ? '#f6ad55' : '#63b3ed'; ctx.lineWidth = 4; ctx.stroke(); } if (this.controller.cannotEatUntil && Date.now() < this.controller.cannotEatUntil) { ctx.strokeStyle = ITEM_COLORS.cannotEat; ctx.lineWidth = 4; ctx.stroke(); } if (this.isSnared) { ctx.strokeStyle = ITEM_COLORS.snare; ctx.lineWidth = 4; ctx.stroke(); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2); ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]); } ctx.globalAlpha = 1; }
         update() { if (!this.isSnared) { this.x += this.dx; this.y += this.dy; } }
         }
         class PlayerController {
         constructor(name, color, initialBall) { this.name = name; this.color = color; this.balls = [initialBall]; this.reset(); }
         reset() {
         this.lives = 5;
         this.armor = [];
         this.invincibleUntil = null;
         this.sizeEffect = null;
         this.speedMultiplier = 1.0;
         this.effectTimeouts = {};
         this.timedEffects = {};
         this.cannotEatUntil = null;
         this.snaredUntil = null;
         this.score = 0;
         this.hasThieuThanBuff = false;
         this.isThieuThanActive = false;
         this.trail = [];
         this.hasSpikeWallImmunity = false;
         // MỚI: Thêm 3 dòng này
         this.hasPoisonBuffUntil = null;
         this.poisonHits = 0;
         this.isPoisonedUntil = null;
         }
         takeDamage(ball, attackInfo, allPlayers, soundManager, uiManager, endGameCallback, attacker = null, isReflected = false) {
         const now = Date.now();
         if (this.invincibleUntil && now < this.invincibleUntil) return false;
         soundManager.playDamage();
         
         // MỚI: Logic xuyên giáp của phi tiêu
         if (attackInfo.type === 'dart') {
         this.lives -= attackInfo.damage;
         this.invincibleUntil = now + 2000;
         uiManager.updateLives(allPlayers);
         if (attacker) {
         attacker.score++;
         uiManager.updateScores(allPlayers);
         }
         if (this.lives <= 0) {
         endGameCallback(false, allPlayers.find(p => p !== this));
         }
         return true; // Sát thương đã được gây ra
         }
         
         // 1. Check for Reflective Cloak first
         const reflectiveCloakIndex = this.armor.indexOf('reflectiveCloak');
         if (!isReflected && reflectiveCloakIndex > -1 && attacker && attacker.balls.length > 0) {
         this.armor.splice(reflectiveCloakIndex, 1);
         clearTimeout(this.effectTimeouts.reflectiveCloak);
         delete this.timedEffects.reflectiveCloak;
         attacker.takeDamage(attacker.balls[0], attackInfo, allPlayers, soundManager, uiManager, endGameCallback, this, true);
         uiManager.updateLives(allPlayers);
         return false; // Damage was reflected, not taken
         }
         
         // 2. Check for other armor (Shield)
         const armorIndex = this.armor.findIndex(t => t === 'shield');
         let damageTaken = true;
         
         if (armorIndex > -1) {
         this.armor.splice(armorIndex, 1); // Break armor
         // Special case for Super Spike: it deals 1 damage even if armor is broken
         if (attackInfo.type === 'superSpike') {
         this.lives -= 1;
         } else {
         damageTaken = false; // Normal armor blocked the attack
         }
         } else {
         // 3. No armor, take full damage
         this.lives -= attackInfo.damage;
         }
         
         this.invincibleUntil = now + 2000;
         uiManager.updateLives(allPlayers);
         
         if (attacker) {
         attacker.score++;
         uiManager.updateScores(allPlayers);
         if (attacker.score >= 10) endGameCallback(false, attacker);
         }
         
         if (this.lives <= 0) {
         endGameCallback(false, allPlayers.find(p => p !== this));
         }
         
         return damageTaken;
         }
         applyEffect(effectType, duration, value) { clearTimeout(this.effectTimeouts[effectType]); const endTime = Date.now() + duration; this.timedEffects[effectType] = { endTime, duration }; switch(effectType) { case 'size': this.sizeEffect = value; break; case 'speed': this.speedMultiplier = value; break; case 'cannotEat': this.cannotEatUntil = endTime; break; case 'snare': this.snaredUntil = endTime; break; case 'reflectiveCloak': if (!this.armor.includes('reflectiveCloak')) this.armor.push('reflectiveCloak'); break; } this.effectTimeouts[effectType] = setTimeout(() => { delete this.timedEffects[effectType]; switch(effectType) { case 'size': this.sizeEffect = null; break; case 'speed': this.speedMultiplier = 1.0; this.balls.forEach(ball => ball.trail = []); break; case 'cannotEat': this.cannotEatUntil = null; break; case 'snare': this.snaredUntil = null; break; case 'reflectiveCloak': const i = this.armor.indexOf('reflectiveCloak'); if(i > -1) this.armor.splice(i, 1); break; } }, duration); }
         }
         class Item { constructor(x, y, r, type, owner) { this.x = x; this.y = y; this.radius = r; this.type = type; this.owner = owner; } draw(ctx) { if (this.owner && this.owner !== 'neutral') { ctx.shadowBlur = 15; ctx.shadowColor = this.owner.color; } const drawFunc = GameLogic.ITEM_DRAW_LOGIC[this.type]; if (drawFunc) drawFunc(this, ctx); ctx.shadowBlur = 0; } }
         
         class GameLogic {
         constructor(canvas, uiManager, soundManager, endGameCallback) { this.canvas = canvas; this.ctx = canvas.getContext('2d'); this.ui = uiManager; this.sound = soundManager; this.endGame = endGameCallback; this.reset(); }
         reset() {
         this.players = [];
         this.items = {};
         this.activeEffects = { laser: null, missile: null, rain: null, spikeWall: null, diagonalWall: null, dart: null }; // THÊM dart VÀO ĐÂY
         this.itemSpawnTimeouts = [];
         this.particles = [];
         this.gameEndTime = 0;
         }
         updateDart(dart) {
         const status = dart.update();
         if (status.expired) {
         this.activeEffects.dart = null;
         return;
         }
         
         const opponent = this.players.find(p => p !== dart.owner);
         if (opponent) {
         for (const ball of opponent.balls) {
         if (Math.hypot(dart.x - ball.x, dart.y - ball.y) < dart.radius + ball.radius) {
           opponent.takeDamage(ball, { damage: 1, type: 'dart' }, this.players, this.sound, this.ui, this.endGame, dart.owner);
           this.triggerEffect(dart.x, dart.y, ITEM_COLORS.dart, { count: 20, speed: 4 });
           this.activeEffects.dart = null;
           return;
         }
         }
         }
         }
         setupMatch(activeItemTypes) { this.reset(); this.ui.toggleGameUI(true); const r = (this.canvas.width / 25) * 1.4 * 0.7, cX = this.canvas.width / 2, cY = this.canvas.height / 2; const p1Spawn = { x: cX + cX / 2, y: cY / 2 }, p2Spawn = { x: cX / 2, y: cY + cY / 2 }; const p1 = new PlayerController('Người chơi 1', '#3b82f6', new PlayerBall(p1Spawn.x, p1Spawn.y, r, null, this.canvas)); p1.balls[0].controller = p1; const p2 = new PlayerController('Người chơi 2', '#ef4444', new PlayerBall(p2Spawn.x, p2Spawn.y, r, null, this.canvas)); p2.balls[0].controller = p2; this.players.push(p1, p2); for (const type in activeItemTypes) { let owner = 'neutral'; if(activeItemTypes[type].owner === 'p1') owner = p1; if(activeItemTypes[type].owner === 'p2') owner = p2; this.items[type] = { ...ITEM_CONFIG[type], owner, item: null, cooldownEndTime: Date.now() + INITIAL_SPAWN_TIME, initialCooldownUsed: false }; } this.ui.updateLives(this.players); this.ui.updatePlayerStatus(this.players); this.ui.updateCooldowns(this.items, this.players); this.ui.updateScores(this.players); this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); this.players.flatMap(p => p.balls).forEach(ball => ball.draw(this.ctx)); }
         startMatch() { this.gameEndTime = Date.now() + TOTAL_GAME_TIME; for (const type in this.items) { this.itemSpawnTimeouts.push(setTimeout(() => { this.spawnItem(type); this.items[type].initialCooldownUsed = true; }, INITIAL_SPAWN_TIME)); } }
         stopMatch() { this.itemSpawnTimeouts.forEach(clearTimeout); this.itemSpawnTimeouts = []; }
         spawnItem(type) { if (type === 'shield' || type === 'weapon' || type === 'superSpike') if (this.players.some(p => p.armor.includes(type))) return; if (this.items[type] && this.items[type].item) return; const r = this.canvas.width / 40; const p = this.getRandomPosition(r); this.items[type].item = new Item(p.x, p.y, r, type, this.items[type].owner); this.items[type].cooldownEndTime = null; }
         updateAndDraw() { const rem = Math.max(0, this.gameEndTime - Date.now());// MỚI: Xử lý khi độc hết hạn
         this.players.forEach(p => {
         if (p.isPoisonedUntil && Date.now() >= p.isPoisonedUntil) {
         p.takeDamage(p.balls[0], { damage: 1, type: 'poison' }, this.players, this.sound, this.ui, this.endGame);
         p.isPoisonedUntil = null;
         this.triggerEffect(p.balls[0].x, p.balls[0].y, ITEM_COLORS.poison, { count: 30, speed: 3 });
         }
         });
            if (rem <= 0 && this.gameEndTime > 0) { this.endGame(true); return; } const mult = this.calculateCurrentMultiplier(rem); for (const type in this.items) if(this.items[type] && this.items[type].baseRespawn) this.items[type].currentRespawn = this.items[type].baseRespawn / mult; this.players.flatMap(p => p.balls).forEach(b => { b.speed = b.baseSpeed * mult * b.controller.speedMultiplier; this.updatePlayerVelocity(b); });
           this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); this.drawTimer(rem); this.drawSpikeWall();
           // Sửa dòng này
         const { rain, laser, missile, diagonalWall, dart } = this.activeEffects;
         
         
         
           if(diagonalWall) diagonalWall.draw(this.ctx);
           if(dart) { this.updateDart(dart); dart.draw(this.ctx); }
           if(rain) { rain.draw(this.ctx); this.updateRainZone(rain); }
           if(laser) { laser.draw(this.ctx); this.updateLaser(laser); }
           if(missile) { missile.draw(this.ctx); this.updateMissile(missile); }
           this.players.forEach(p => { const hasW = p.armor.includes('weapon') || p.armor.includes('superSpike'); if(p.hasThieuThanBuff && hasW && !p.isThieuThanActive) p.isThieuThanActive = true; if(p.isThieuThanActive && !hasW) p.isThieuThanActive = false; });
           this.players.flatMap(p => p.balls).forEach(b => {
               const p = b.controller; if(p.isThieuThanActive) { const opp = this.players.find(pl => pl !== p); if (opp && opp.balls.length > 0) { const t = opp.balls[0], dist = Math.hypot(t.x-b.x, t.y-b.y), maxD = this.canvas.width * 0.75, prox = Math.max(0, 1 - (dist / maxD)), speedM = 1 + (prox * 0.25), ang = Math.atan2(t.y-b.y, t.x-b.x); b.dx = Math.cos(ang) * b.speed * speedM; b.dy = Math.sin(ang) * b.speed * speedM; } }  b.update();
         if (p.speedMultiplier > 1) {
         b.trail.push({ x: b.x, y: b.y }); // <-- Sửa thành b.trail
         if (b.trail.length > 10) b.trail.shift();
         } else if (b.trail.length > 0) {
         b.trail.shift(); // <-- Sửa thành b.trail
         }
         });
           this.players.flatMap(p=>p.balls).forEach(this.handleWallCollisions.bind(this)); this.players.flatMap(p=>p.balls).forEach(this.handleDiagonalWallCollision.bind(this)); this.handlePlayerCollisions();
           this.players.flatMap(p=>p.balls).forEach(ball => ball.draw(this.ctx)); for (const type in this.items) if(this.items[type]?.item) this.items[type].item.draw(this.ctx); this.particles.forEach((p, i) => { p.update(); p.draw(this.ctx); if (p.life <= 0) this.particles.splice(i, 1); });
           this.ui.updateCooldowns(this.items, this.players); this.ui.updatePlayerStatus(this.players);
         }
         updateRainZone(rain) { const now = Date.now(); rain.drops.forEach(d => { if (!d.tr && now > rain.startTime + d.t) { this.players.flatMap(p=>p.balls).forEach(b => { if (b.controller !== rain.owner && Math.hypot(b.x-rain.x, b.y-rain.y) < b.radius + rain.radius) b.controller.takeDamage(b, {damage: 1, type: 'rain'}, this.players, this.sound, this.ui, this.endGame); }); d.tr = true; } }); if (now > rain.endTime) this.activeEffects.rain = null; }
         updateLaser(laser) { const opp = this.players.find(p => p !== laser.owner); if (opp) opp.balls.forEach(b => { if (laser && laser.checkCollision(b)) { opp.takeDamage(b, {damage: 1, type: 'laser'}, this.players, this.sound, this.ui, this.endGame, laser.owner); this.activeEffects.laser = null; } }); if (laser && Date.now() > laser.endTime) this.activeEffects.laser = null; }
         updateMissile(missile) { const status = missile.update(); if (status.expired) this.activeEffects.missile = null; if (status.wallHit) { this.triggerEffect(missile.x, missile.y, ITEM_COLORS.homingMissile, { count: 20 }); this.activeEffects.missile = null; } if (status.targetHit) { missile.target.takeDamage(missile.target.balls[0], {damage: 1, type: 'missile'}, this.players, this.sound, this.ui, this.endGame, missile.owner); this.triggerEffect(missile.x, missile.y, ITEM_COLORS.homingMissile, { count: 30, speed: 4 }); this.activeEffects.missile = null; } }
         handleDiagonalWallCollision(ball) { const wall = this.activeEffects.diagonalWall; if (!wall) return; const p1 = wall.p1, p2 = wall.p2, p1_to_p = { x: ball.x - p1.x, y: ball.y - p1.y }, p1_to_p2 = { x: p2.x - p1.x, y: p2.y - p1.y }; const len_sq = p1_to_p2.x**2 + p1_to_p2.y**2, dot = p1_to_p.x * p1_to_p2.x + p1_to_p.y * p1_to_p2.y; const t = Math.max(0, Math.min(1, dot / len_sq)); const closest = { x: p1.x + t * p1_to_p2.x, y: p1.y + t * p1_to_p2.y }; const distSq = (ball.x - closest.x)**2 + (ball.y - closest.y)**2; if (distSq < ball.radius**2) { const dist = Math.sqrt(distSq), overlap = ball.radius - dist; if (dist > 0) { ball.x += overlap * (ball.x - closest.x) / dist; ball.y += overlap * (ball.y - closest.y) / dist; } const v = { x: ball.dx, y: ball.dy }, n = { ...wall.normal }; if (((ball.x-p1.x)*n.y - (ball.y-p1.y)*n.x) > 0) { n.x*=-1; n.y*=-1; } const dot_v_n = v.x * n.x + v.y * n.y; ball.dx = v.x - 2 * dot_v_n * n.x; ball.dy = v.y - 2 * dot_v_n * n.y; wall.hits--; this.triggerEffect(closest.x, closest.y, ITEM_COLORS.diagonalWall, { count: 10, speed: 2 }); if (wall.hits <= 0) { this.triggerEffect(closest.x, closest.y, ITEM_COLORS.diagonalWall, { count: 30, speed: 5 }); this.activeEffects.diagonalWall = null; } } }
         handleWallCollisions(ball) { let bounced = false; if (ball.x + ball.radius > this.canvas.width || ball.x - ball.radius < 0) { ball.dx = -ball.dx; bounced = true; } if (ball.y + ball.radius > this.canvas.height || ball.y - ball.radius < 0) { ball.dy = -ball.dy; bounced = true; } ball.x = Math.max(ball.radius, Math.min(this.canvas.width - ball.radius, ball.x)); ball.y = Math.max(ball.radius, Math.min(this.canvas.height - ball.radius, ball.y)); const spikeWall = this.activeEffects.spikeWall; if (spikeWall && bounced) { const hit = (ball.x - ball.radius <= 1 && spikeWall.side === 'left') || (ball.x + ball.radius >= this.canvas.width - 1 && spikeWall.side === 'right') || (ball.y - ball.radius <= 1 && spikeWall.side === 'top') || (ball.y + ball.radius >= this.canvas.height - 1 && spikeWall.side === 'bottom'); if (hit && ball.controller !== spikeWall.owner) { ball.controller.takeDamage(ball, {damage: 1, type: 'wallSpikes'}, this.players, this.sound, this.ui, this.endGame); this.triggerEffect(ball.x, ball.y, ITEM_COLORS.wallSpikes, { count: 20, speed: 5 }); this.activeEffects.spikeWall = null; } } }
         handlePlayerCollisions() {
         const allBalls = this.players.flatMap(p => p.balls);
         for (let i = 0; i < allBalls.length; i++) {
         for (let j = i + 1; j < allBalls.length; j++) {
         const b1 = allBalls[i], b2 = allBalls[j];
         const dist = Math.hypot(b1.x - b2.x, b1.y - b2.y);
         if (dist < b1.radius + b2.radius) {
           const overlap = b1.radius + b2.radius - dist, nx = (b2.x - b1.x) / dist, ny = (b2.y - b1.y) / dist;
           if (!b1.isSnared && !b2.isSnared) { b1.x -= overlap / 2 * nx; b1.y -= overlap / 2 * ny; b2.x += overlap / 2 * nx; b2.y += overlap / 2 * ny; }
           else if (b1.isSnared && !b2.isSnared) { b2.x += overlap * nx; b2.y += overlap * ny; }
           else if (!b1.isSnared && b2.isSnared) { b1.x -= overlap * nx; b1.y -= overlap * ny; }
           const tx = -ny, ty = nx, dpTan1 = b1.dx * tx + b1.dy * ty, dpTan2 = b2.dx * tx + b2.dy * ty, dpNorm1 = b1.dx * nx + b1.dy * ny, dpNorm2 = b2.dx * nx + b2.dy * ny;
           if (!b1.isSnared) { b1.dx = tx * dpTan1 + nx * dpNorm2; b1.dy = ty * dpTan1 + ny * dpNorm2; }
           if (!b2.isSnared) { b2.dx = tx * dpTan2 + nx * dpNorm1; b2.dy = ty * dpTan2 + ny * dpNorm1; }
           this.updatePlayerVelocity(b1); this.updatePlayerVelocity(b2);
         
           if (b1.controller !== b2.controller) {
               // MỚI: Xử lý Thuốc Độc
               const checkPoison = (attackerBall, defenderBall) => {
                   const attacker = attackerBall.controller;
                   const defender = defenderBall.controller;
                   if (attacker.hasPoisonBuffUntil && Date.now() < attacker.hasPoisonBuffUntil && !defender.isPoisonedUntil) {
                       attacker.poisonHits++;
                       this.triggerEffect(defenderBall.x, defenderBall.y, ITEM_COLORS.poison, { count: 10, speed: 2 });
                       if (attacker.poisonHits >= 2) {
                           defender.isPoisonedUntil = Date.now() + 10000;
                           attacker.hasPoisonBuffUntil = null;
                           attacker.poisonHits = 0;
                       }
                   }
               };
               checkPoison(b1, b2);
               checkPoison(b2, b1);
         
               const b1WeaponType = b1.controller.armor.find(a => a === 'weapon' || a === 'superSpike');
               const b2WeaponType = b2.controller.armor.find(a => a === 'weapon' || a === 'superSpike');
               const startWeaponCD = (type) => { const w = this.items[type]; if (w) { w.cooldownEndTime = Date.now() + w.currentRespawn; this.itemSpawnTimeouts.push(setTimeout(() => this.spawnItem(type), w.currentRespawn)); } };
               if (b1WeaponType) { if (b2.controller.takeDamage(b2, { damage: b1WeaponType === 'superSpike' ? 2 : 1, type: b1WeaponType }, this.players, this.sound, this.ui, this.endGame, b1.controller)) { const index = b1.controller.armor.lastIndexOf(b1WeaponType); if (index > -1) b1.controller.armor.splice(index, 1); clearTimeout(b1.controller.effectTimeouts[b1WeaponType]); delete b1.controller.timedEffects[b1WeaponType]; startWeaponCD(b1WeaponType); this.deactivateThieuThan(b1.controller); } }
               if (b2WeaponType) { if (b1.controller.takeDamage(b1, { damage: b2WeaponType === 'superSpike' ? 2 : 1, type: b2WeaponType }, this.players, this.sound, this.ui, this.endGame, b2.controller)) { const index = b2.controller.armor.lastIndexOf(b2WeaponType); if (index > -1) b2.controller.armor.splice(index, 1); clearTimeout(b2.controller.effectTimeouts[b2WeaponType]); delete b2.controller.timedEffects[b2WeaponType]; startWeaponCD(b2WeaponType); this.deactivateThieuThan(b2.controller); } }
           }
         }
         }
         const ball = allBalls[i]; for (const type in this.items) if (this.items[type]?.item && Math.hypot(ball.x - this.items[type].item.x, ball.y - this.items[type].item.y) < ball.radius + this.items[type].item.radius) this.handleItemPickup(ball, type);
         }
         }
           handleItemPickup(ball, type) { const itemData = this.items[type]; if (!itemData || !itemData.item || (ball.controller.cannotEatUntil && Date.now() < ball.controller.cannotEatUntil)) return; const itemOwner = itemData.item.owner; const configType = ITEM_CONFIG[type]?.type || 'trap'; if ((configType === 'buff' || configType === 'debuff' || configType === 'map_effect') && itemOwner !== 'neutral' && itemOwner !== ball.controller) return; const logic = this.getItemPickupLogic(type); if (!logic) return; if (logic(ball, itemData)) { this.sound.playPickup(type); this.triggerEffect(ball.x, ball.y, ITEM_COLORS[type], { count: 15, speed: 2, life: 25 }); itemData.item = null; 
         // Sửa dòng này
         const CD_ON_EXPIRE = ['shield', 'weapon', 'superSpike', 'reflectiveCloak', 'shrink', 'speedBoost', 'invisibility', 'thieuThan', 'poison'];
         if (itemData.currentRespawn && !CD_ON_EXPIRE.includes(type)) { itemData.cooldownEndTime = Date.now() + itemData.currentRespawn; this.itemSpawnTimeouts.push(setTimeout(() => this.spawnItem(type), itemData.currentRespawn)); } } }
         getItemPickupLogic(type) { const genericSpikePickup = (b, spikeType) => { const p = b.controller; clearTimeout(p.effectTimeouts[spikeType]); if (!p.armor.includes(spikeType)) p.armor.push(spikeType); const d = 5000; p.timedEffects[spikeType] = { endTime: Date.now() + d, duration: d }; p.effectTimeouts[spikeType] = setTimeout(() => { const i = p.armor.indexOf(spikeType); if (i > -1) p.armor.splice(i, 1); delete p.timedEffects[spikeType]; }, d); this.ui.updateLives(this.players); return true; }; const logic = {
           weapon: b => genericSpikePickup(b, 'weapon'),
           superSpike: b => genericSpikePickup(b, 'superSpike'),
           health: b => { if (b.controller.lives < 5) { b.controller.lives++; this.ui.updateLives(this.players); return true; } return false; },
           bomb: b => { const r = this.canvas.width/40, p = this.getRandomPosition(r); this.items['bomb_trap'] = { item: new Item(p.x, p.y, r, 'bomb_trap', b.controller) }; return true; },
           bomb_trap: (b, i) => { if (b.controller !== i.item.owner) { this.triggerEffect(i.item.x, i.item.y, ITEM_COLORS.bomb, { count: 40, speed: 7 }); b.controller.takeDamage(b, {damage: 1, type: 'bomb'}, this.players, this.sound, this.ui, this.endGame, i.item.owner); return true; } return false; },
           shield: b => { if (b.controller.armor.includes('shield')) return false; b.controller.armor.push('shield'); this.ui.updateLives(this.players); return true; },
           reflectiveCloak: b => { b.controller.applyEffect('reflectiveCloak', 10000); return true; },
           snare: b => { const r = this.canvas.width/40, p = this.getRandomPosition(r); this.items['snare_trap'] = { item: new Item(p.x, p.y, r, 'snare_trap', b.controller) }; return true; },
           snare_trap: (b, i) => { if (b.controller !== i.item.owner) { b.controller.applyEffect('snare', 3000); return true; } return false; },
           grow: b => { const o = this.players.find(p=>p!==b.controller); if(o) o.applyEffect('size', 10000, 'grow'); return true; },
           shrink: b => { b.controller.applyEffect('size', 10000, 'shrink'); this.startCooldownOnExpire('shrink', 10000); return true; },
           speedBoost: b => { b.controller.applyEffect('speed', 5000, 1.5); this.startCooldownOnExpire('speedBoost', 5000); return true; },
           slow: b => { const o = this.players.find(p=>p!==b.controller); if(o) o.applyEffect('speed', 5000, 0.5); return true; },
           rain: b => { const r = b.baseRadius * 5, p = this.getRandomPosition(r); this.activeEffects.rain = new RainZone(p.x, p.y, r, b.controller); return true; },
           invisibility: b => { const d = 3000; b.controller.invincibleUntil = Date.now() + d; b.controller.timedEffects.invisibility = { endTime: Date.now() + d, duration: d }; this.startCooldownOnExpire('invisibility', d); return true; },
           wallSpikes: b => { this.activeEffects.spikeWall = { side: ['top','right','bottom','left'][Math.floor(Math.random()*4)], owner: b.controller }; return true; },
           diagonalWall: b => { if (this.activeEffects.diagonalWall) return false; this.activeEffects.diagonalWall = new DiagonalWall(this.canvas); return true; },
           clone: b => { if(b.controller.balls.length < 3) { const parent = b.controller.balls[0], newBall = new PlayerBall(parent.x+10, parent.y+10, parent.baseRadius, b.controller, this.canvas); b.controller.balls.push(newBall); } return true; },
           cannotEat: b => { const o = this.players.find(p=>p!==b.controller); if(o) o.applyEffect('cannotEat', 5000); return true; },
           laserGun: b => { if(this.activeEffects.laser) return false; const o = this.players.find(p=>p!==b.controller); if(!o || o.balls.length===0) return false; const t = o.balls[0], dir = {x: t.x-b.x, y: t.y-b.y}, mag = Math.hypot(dir.x, dir.y); if(mag > 0) { dir.x/=mag; dir.y/=mag; } this.activeEffects.laser = new Laser({x:b.x,y:b.y}, dir, b.controller, this.canvas); return true; },
           thieuThan: b => { if(b.controller.hasThieuThanBuff) return false; b.controller.hasThieuThanBuff = true; return true; },
           homingMissile: b => { if(this.activeEffects.missile) return false; const o = this.players.find(p=>p!==b.controller); if(o) this.activeEffects.missile = new HomingMissile(b.controller, o, this.canvas); return true; },
            dart: b => {
         if (this.activeEffects.dart) return false;
         const opponent = this.players.find(p => p !== b.controller);
         if (opponent && opponent.balls.length > 0) {
         this.activeEffects.dart = new Dart(b.controller, opponent, this.canvas);
         return true;
         }
         return false;
         },
         poison: b => {
         if (b.controller.hasPoisonBuffUntil) return false; // Không nhặt khi đang có buff
         b.controller.hasPoisonBuffUntil = Date.now() + 15000;
         b.controller.poisonHits = 0;
         return true;
         },
         }; return logic[type]; }
         startCooldownOnExpire(type, duration) { setTimeout(() => { const item = this.items[type]; if (item) { const rt = item.currentRespawn; item.cooldownEndTime = Date.now() + rt; this.itemSpawnTimeouts.push(setTimeout(() => this.spawnItem(type), rt)); } }, duration); }
         deactivateThieuThan(player) { if (!player.hasThieuThanBuff) return; player.isThieuThanActive = false; player.hasThieuThanBuff = false; this.startCooldownOnExpire('thieuThan', 0); }
         drawTimer(remaining) { if (remaining > 0) { let color = 'rgba(255, 255, 255, 0.08)'; if(remaining <= 5000) color = 'rgba(239, 68, 68, 0.2)'; else if(remaining <= 15000) color = 'rgba(239, 68, 68, 0.15)'; else if(remaining <= 45000) color = 'rgba(239, 68, 68, 0.1)'; this.ctx.fillStyle = color; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height); this.ctx.fillStyle = '#2d3748'; this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height * (1-remaining/TOTAL_GAME_TIME)); } const sec = Math.ceil(remaining/1000); this.ctx.font = `bold ${this.canvas.width / 4}px Inter, sans-serif`; this.ctx.fillStyle = 'rgba(255, 255, 255, 0.15)'; this.ctx.textAlign = 'center'; this.ctx.textBaseline = 'middle'; this.ctx.fillText(sec, this.canvas.width/2, this.canvas.height/2); }
         drawSpikeWall() { const wall = this.activeEffects.spikeWall; if (!wall) return; this.ctx.fillStyle = ITEM_COLORS.wallSpikes; const s = this.canvas.width/40, n = Math.floor(this.canvas.width/s); for (let i=0; i<n; i++) { const p = i*s + s/2; this.ctx.beginPath(); if (wall.side==='top') { this.ctx.moveTo(p-s/2, 0); this.ctx.lineTo(p, s); this.ctx.lineTo(p+s/2, 0); } else if (wall.side==='bottom') { this.ctx.moveTo(p-s/2, this.canvas.height); this.ctx.lineTo(p, this.canvas.height-s); this.ctx.lineTo(p+s/2, this.canvas.height); } else if (wall.side==='left') { this.ctx.moveTo(0, p-s/2); this.ctx.lineTo(s, p); this.ctx.lineTo(0, p+s/2); } else { this.ctx.moveTo(this.canvas.width, p-s/2); this.ctx.lineTo(this.canvas.width-s, p); this.ctx.lineTo(this.canvas.width, p+s/2); } this.ctx.fill(); } }
         triggerEffect(x, y, color, { count=20, speed=3, life=40, friction=0.95 }={}) { for (let i = 0; i < count; i++) { const a = Math.random()*Math.PI*2, s = Math.random()*speed+1; this.particles.push(new Particle(x, y, Math.cos(a)*s, Math.sin(a)*s, Math.random()*2+1, color, life, friction)); } }
         getRandomPosition(r) { return { x: Math.random()*(this.canvas.width-r*2)+r, y: Math.random()*(this.canvas.height-r*2)+r }; }
         updatePlayerVelocity(ball) { const mag = Math.hypot(ball.dx, ball.dy); if (mag > 0) { ball.dx = (ball.dx / mag) * ball.speed; ball.dy = (ball.dy / mag) * ball.speed; } }
         calculateCurrentMultiplier(rem) { const s2=45000, s3=15000, s4=5000; if (rem>s2) return 1+((TOTAL_GAME_TIME-rem)/(TOTAL_GAME_TIME-s2)); if (rem>s3) return 2+((s2-rem)/(s2-s3)); if (rem>s4) return 3+((s3-rem)/(s3-s4)); return 4; }
         // --- BẮT ĐẦU ĐOẠN MÃ THAY THẾ ---
         static ITEM_DRAW_LOGIC = {
           // Hàm vẽ chung cho các vật phẩm, thêm hiệu ứng pulsing
           _drawBase: (item, ctx, color, drawIconCallback) => {
               const pulse = Math.sin(Date.now() / 200) * 2;
               const radius = item.radius + pulse;
         
               // Vẽ vòng sáng bên ngoài
               ctx.beginPath();
               ctx.arc(item.x, item.y, radius + 3, 0, Math.PI * 2);
               ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
               ctx.fill();
         
               // Vẽ nền màu của vật phẩm
               ctx.beginPath();
               ctx.arc(item.x, item.y, radius, 0, Math.PI * 2);
               ctx.fillStyle = color;
               ctx.fill();
         
               // Vẽ icon đặc trưng (nếu có)
               if (drawIconCallback) {
                   drawIconCallback(item, ctx, radius);
               }
           },
         
           // ---- CÁC VẬT PHẨM CŨ ĐƯỢC VẼ LẠI ----
           weapon: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.weapon, (item, ctx, r) => {
               const rotation = Date.now() / 500;
               ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
               for (let j = 0; j < 5; j++) {
                   let angle = (j / 5) * (Math.PI * 2) + rotation;
                   ctx.beginPath();
                   ctx.moveTo(item.x + Math.cos(angle) * r * 0.5, item.y + Math.sin(angle) * r * 0.5);
                   ctx.lineTo(item.x + Math.cos(angle) * r * 0.9, item.y + Math.sin(angle) * r * 0.9);
                   ctx.stroke();
               }
           }),
           health: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.health, (item, ctx, r) => {
               ctx.fillStyle = 'white';
               const w = r * 1.2, h = r * 0.4;
               ctx.fillRect(item.x - w / 2, item.y - h / 2, w, h);
               ctx.fillRect(item.x - h / 2, item.y - w / 2, h, w);
           }),
           bomb: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, '#4a5568', (item, ctx, r) => {
               const p = Math.abs(Math.sin(Date.now() / 150));
               ctx.fillStyle = `rgba(255, ${150 + p * 105}, 0, ${0.8 + p * 0.2})`;
               ctx.beginPath();
               ctx.arc(item.x, item.y, r * 0.3, 0, Math.PI * 2);
               ctx.fill();
           }),
           bomb_trap: (i, c) => GameLogic.ITEM_DRAW_LOGIC.bomb(i, c),
           shield: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.shield, (item, ctx, r) => {
               ctx.strokeStyle = 'white'; ctx.lineWidth = 3;
               ctx.beginPath();
               ctx.arc(item.x, item.y, r * 0.7, 0, Math.PI * 2);
               ctx.stroke();
           }),
           snare_trap: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.snare, (item, ctx, r) => {
               ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
               ctx.beginPath();
               ctx.arc(item.x, item.y, r * 0.8, 0, Math.PI * 2);
               ctx.stroke();
                ctx.beginPath();
               ctx.arc(item.x, item.y, r * 0.4, 0, Math.PI * 2);
               ctx.stroke();
           }),
         
           // ---- LOGIC VẼ CHO CÁC VẬT PHẨM BỊ THIẾU ----
           superSpike: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.superSpike, (item, ctx, r) => {
               const rotation = Date.now() / 400;
               ctx.strokeStyle = 'white'; ctx.lineWidth = 3;
               for (let j = 0; j < 6; j++) {
                   let angle = (j / 6) * (Math.PI * 2) + rotation;
                   ctx.beginPath();
                   ctx.moveTo(item.x + Math.cos(angle) * r * 0.6, item.y + Math.sin(angle) * r * 0.6);
                   ctx.lineTo(item.x + Math.cos(angle) * r * 1.0, item.y + Math.sin(angle) * r * 1.0);
                   ctx.stroke();
               }
           }),
           reflectiveCloak: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.reflectiveCloak, (item, ctx, r) => {
               const sides = 6;
               ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
               ctx.beginPath();
               for(let j=0; j <= sides; j++) {
                   const angle = j * 2 * Math.PI / sides - Math.PI / 2;
                   ctx.lineTo(item.x + r * 0.8 * Math.cos(angle), item.y + r * 0.8 * Math.sin(angle));
               }
               ctx.closePath();
               ctx.stroke();
           }),
           snare: (i,c) => GameLogic.ITEM_DRAW_LOGIC.snare_trap(i,c),
           grow: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.grow, (item, ctx, r) => {
               ctx.fillStyle = 'white'; ctx.beginPath();
               ctx.moveTo(item.x, item.y - r * 0.5);
               ctx.lineTo(item.x + r * 0.6, item.y + r * 0.5);
               ctx.lineTo(item.x - r * 0.6, item.y + r * 0.5);
               ctx.closePath(); ctx.fill();
           }),
           shrink: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.shrink, (item, ctx, r) => {
                ctx.fillStyle = 'white'; ctx.beginPath();
               ctx.moveTo(item.x, item.y + r * 0.5);
               ctx.lineTo(item.x + r * 0.6, item.y - r * 0.5);
               ctx.lineTo(item.x - r * 0.6, item.y - r * 0.5);
               ctx.closePath(); ctx.fill();
           }),
           speedBoost: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.speedBoost, (item, ctx, r) => {
               ctx.fillStyle = 'white';
               const drawChevron = (offset) => {
                   ctx.beginPath();
                   ctx.moveTo(item.x - r * 0.5 + offset, item.y + r * 0.5);
                   ctx.lineTo(item.x + offset, item.y - r * 0.5);
                   ctx.lineTo(item.x + r * 0.5 + offset, item.y + r * 0.5);
                   ctx.lineTo(item.x + offset, item.y + r * 0.2);
                   ctx.closePath(); ctx.fill();
               }
               drawChevron(-r*0.2); drawChevron(r*0.2);
           }),
           slow: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.slow, (item, ctx, r) => {
               ctx.fillStyle = 'white';
               const barHeight = r * 0.8;
               ctx.fillRect(item.x - r * 0.5, item.y - barHeight/2, r*0.25, barHeight);
               ctx.fillRect(item.x + r * 0.25, item.y - barHeight/2, r*0.25, barHeight);
           }),
           rain: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.rain, (item, ctx, r) => {
               ctx.fillStyle = 'rgba(255,255,255,0.8)';
               for(let j=0; j<3; j++) {
                   ctx.beginPath();
                   ctx.arc(item.x - r*0.4 + j*r*0.4, item.y - r*0.2, r*0.2, 0, Math.PI*2);
                   ctx.fill();
               }
           }),
           invisibility: (i, c) => { // Hiệu ứng đặc biệt: chỉ vẽ vòng ngoài nhấp nháy
               const pulse = Math.sin(Date.now() / 200) * 2;
               const radius = i.radius + pulse;
               ctx.beginPath();
               ctx.arc(i.x, i.y, radius, 0, Math.PI * 2);
               ctx.strokeStyle = `rgba(200, 200, 200, ${0.5 + Math.sin(Date.now()/150)*0.5})`;
               ctx.lineWidth = 3;
               ctx.stroke();
           },
           wallSpikes: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.wallSpikes, (item, ctx, r) => {
               ctx.fillStyle = 'white';
               ctx.fillRect(item.x-r*0.8, item.y-r*0.1, r*1.6, r*0.2);
               ctx.beginPath();
               ctx.moveTo(item.x-r*0.5, item.y);
               ctx.lineTo(item.x, item.y-r*0.5);
               ctx.lineTo(item.x+r*0.5, item.y);
               ctx.fill();
           }),
           diagonalWall: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.diagonalWall, (item, ctx, r) => {
               ctx.strokeStyle = 'white'; ctx.lineWidth = 3;
               ctx.beginPath();
               ctx.moveTo(item.x - r*0.6, item.y + r*0.6);
               ctx.lineTo(item.x + r*0.6, item.y - r*0.6);
               ctx.stroke();
           }),
           clone: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.clone, (item, ctx, r) => {
               ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
               ctx.beginPath(); ctx.arc(item.x - r*0.2, item.y - r*0.2, r*0.5, 0, Math.PI*2); ctx.stroke();
               ctx.beginPath(); ctx.arc(item.x + r*0.2, item.y + r*0.2, r*0.5, 0, Math.PI*2); ctx.stroke();
           }),
           cannotEat: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.cannotEat, (item, ctx, r) => {
               ctx.strokeStyle = 'red'; ctx.lineWidth = 3;
               ctx.beginPath();
               ctx.moveTo(item.x - r*0.6, item.y + r*0.6);
               ctx.lineTo(item.x + r*0.6, item.y - r*0.6);
               ctx.stroke();
           }),
           laserGun: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.laserGun, (item, ctx, r) => {
               const rotation = Date.now()/1000;
               ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
               ctx.save(); ctx.translate(item.x, item.y); ctx.rotate(rotation);
               ctx.beginPath(); ctx.moveTo(-r*0.8, 0); ctx.lineTo(r*0.8, 0); ctx.stroke();
               ctx.beginPath(); ctx.arc(0, 0, r*0.4, 0, Math.PI*2); ctx.stroke();
               ctx.restore();
           }),
           thieuThan: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.thieuThan, (item, ctx, r) => {
               const pulse = Math.sin(Date.now() / 100);
               ctx.fillStyle = `rgba(255, 255, 255, ${0.8 + pulse * 0.2})`;
               ctx.beginPath(); ctx.arc(item.x, item.y, r * (0.4 + pulse * 0.1), 0, Math.PI * 2); ctx.fill();
           }),
           homingMissile: (i, c) => GameLogic.ITEM_DRAW_LOGIC._drawBase(i, c, ITEM_COLORS.homingMissile, (item, ctx, r) => {
               ctx.fillStyle = 'white'; ctx.beginPath();
               ctx.moveTo(item.x + r * 0.8, item.y);
               ctx.lineTo(item.x - r * 0.4, item.y - r * 0.5);
               ctx.lineTo(item.x - r * 0.4, item.y + r * 0.5);
               ctx.closePath(); ctx.fill();
           })
         };
         // --- KẾT THÚC ĐOẠN MÃ THAY THẾ ---
         }
         
         class GameManager {
         constructor() {
           this.ui = new UIManager();
           this.sound = new SoundManager();
           this.logic = new GameLogic(this.ui.dom.canvas, this.ui, this.sound, this.endGame.bind(this));
           
           this.state = { gameMode: 'ban-pick', seriesType: 1, p1SeriesWins: 0, p2SeriesWins: 0, wakeLock: null, animationFrameId: null, effectLoopId: null };
           this.banPickState = {};
           this.bindEvents();
           this.init();
         }
         
         init() {
           this.stopGameLoop();
           this.releaseWakeLock();
           this.ui.setCanvasSize();
           this.logic.reset();
         
           this.state.p1SeriesWins = 0;
           this.state.p2SeriesWins = 0;
           
           this.ui.dom.buttons.nextMatch.classList.add('hidden');
           this.ui.dom.series.ui.classList.add('hidden');
           this.ui.showScreen('start');
           this.ui.toggleGameUI(false);
           this.ui.dom.winner.text.className = 'text-4xl font-bold mb-4';
           
           this.ui.ctx.clearRect(0, 0, this.ui.dom.canvas.width, this.ui.dom.canvas.height);
           this.ui.ctx.font = `bold ${this.ui.dom.canvas.width / 10}px Inter, sans-serif`;
           this.ui.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
           this.ui.ctx.textAlign = 'center';
           this.ui.ctx.textBaseline = 'middle';
           this.ui.ctx.fillText("Sẵn Sàng...", this.ui.dom.canvas.width / 2, this.ui.dom.canvas.height / 2);
         
           this.checkSavedGame();
         }
         
         bindEvents() {
           window.addEventListener('resize', () => this.init());
           this.ui.dom.buttons.start.addEventListener('click', () => this.handleStartClick());
           this.ui.dom.buttons.restart.addEventListener('click', () => { this.sound.playClick(); this.init(); });
           this.ui.dom.buttons.nextMatch.addEventListener('click', () => { this.sound.playClick(); this.startNextMatch(); });
           this.ui.dom.buttons.loadLast.addEventListener('click', () => this.loadAndStart());
           
           document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible' && this.state.animationFrameId) this.requestWakeLock(); });
           
           this.ui.dom.selectors.mode.addEventListener('click', e => this.handleSelectorClick(e, 'mode'));
           this.ui.dom.selectors.series.addEventListener('click', e => this.handleSelectorClick(e, 'series'));
         }
         
         handleSelectorClick(event, type) {
           const button = event.target.closest('button');
           if (!button) return;
           this.sound.playClick();
           const selector = type === 'mode' ? this.ui.dom.selectors.mode : this.ui.dom.selectors.series;
           selector.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
           button.classList.add('active');
           if (type === 'mode') this.state.gameMode = button.dataset.mode;
           else this.state.seriesType = parseInt(button.dataset.series, 10);
         }
         
         async handleStartClick() {
           await this.sound.init();
           this.sound.playClick();
           this.saveGameSettings();
           this.startNextMatch();
         }
         
         startNextMatch() {
           if(this.state.seriesType > 1) {
               this.ui.dom.series.ui.classList.remove('hidden');
               this.ui.dom.series.info.textContent = `BO${this.state.seriesType}`;
               this.ui.dom.series.p1Score.textContent = this.state.p1SeriesWins;
               this.ui.dom.series.p2Score.textContent = this.state.p2SeriesWins;
           }
           this.showBanPickPhase();
         }
         
         showBanPickPhase() {
           this.ui.showScreen('banPick');
           this.banPickState = { currentIndex: 0, p1Bans: [], p2Bans: [], p1Picks: [], p2Picks: [], selectionCandidate: null };
           const bannable = Object.keys(ITEM_CONFIG).filter(t => ITEM_CONFIG[t].type !== 'neutral');
           const groups = { buff: [], debuff: [], map_effect: [] };
           bannable.forEach(t => { const type = ITEM_CONFIG[t].type; if(groups[type]) groups[type].push(t); });
           const sorted = [...groups.buff.sort(), ...groups.debuff.sort(), ...groups.map_effect.sort()];
           this.ui.dom.banPick.grid.innerHTML = '';
           sorted.forEach(type => {
               const div = document.createElement('div'); div.id = `bp-item-${type}`; div.className = 'ban-pick-item selectable';
               let typeIcon = '';
               if(ITEM_CONFIG[type].type === 'buff') typeIcon = `<div class="type-icon text-green-400">▲</div>`;
               else if (ITEM_CONFIG[type].type === 'debuff') typeIcon = `<div class="type-icon text-red-400">▼</div>`;
               else if (ITEM_CONFIG[type].type === 'map_effect') typeIcon = `<div class="type-icon text-yellow-400">♦</div>`;
               div.innerHTML = `${ICONS[type]}${typeIcon}<div class="overlay">/</div>`;
               const isTouch = 'ontouchstart' in window;
               if(isTouch) div.addEventListener('click', () => this.handleBanPickSelection(type));
               else { div.onclick = () => this.handleBanPickSelection(type); div.onmouseenter = e => this.ui.showTooltip(e, type); div.onmouseleave = () => this.ui.hideTooltip(); }
               this.ui.dom.banPick.grid.appendChild(div);
           });
           this.updateBanPickUI();
         }
         
         updateBanPickUI() {
           const { title, mobileInfo, p1Picks, p2Picks, p1Bans, p2Bans } = this.ui.dom.banPick;
           document.querySelectorAll('.pulsing-slot, .border-yellow-400').forEach(el => el.classList.remove('pulsing-slot', 'border-yellow-400'));
           const renderSlots = (container, items, max, isBan = false) => { container.innerHTML = ''; for(let i=0; i<max; i++) { let content = items[i] ? ICONS[items[i]].replace('h-8 w-8', 'h-full w-full') + (isBan ? '<div class="absolute inset-0 bg-red-800/70 flex items-center justify-center text-white text-3xl font-bold">/</div>' : '') : ''; container.innerHTML += `<div class="${isBan ? 'p-1' : 'p-1 border-dashed'} aspect-square bg-gray-900 border-2 border-gray-700 rounded flex justify-center items-center relative">${content}</div>`; }};
           renderSlots(p1Bans, this.banPickState.p1Bans, 2, true); renderSlots(p2Bans, this.banPickState.p2Bans, 2, true); renderSlots(p1Picks, this.banPickState.p1Picks, 3); renderSlots(p2Picks, this.banPickState.p2Picks, 3);
           
           const currentStep = banPickSequence[this.banPickState.currentIndex];
           if (currentStep) {
               const isP1 = currentStep.player === 1, isPick = currentStep.phase === 'pick';
               const phaseText = isPick ? 'Chọn' : 'Cấm';
               title.className = 'text-2xl md:text-3xl font-bold'; title.classList.add(isP1 ? 'text-blue-500' : 'text-red-500');
               const titleText = this.state.gameMode === 'random' && isPick ? 'Vật phẩm ngẫu nhiên' : `Người chơi ${currentStep.player} - ${phaseText}`;
               title.textContent = titleText;
         
               const container = isPick ? (isP1 ? p1Picks : p2Picks) : (isP1 ? p1Bans : p2Bans);
               const itemsList = isPick ? (isP1 ? this.banPickState.p1Picks : this.banPickState.p2Picks) : (isP1 ? this.banPickState.p1Bans : this.banPickState.p2Bans);
               if (itemsList.length < (isPick ? 3:2)) container.children[itemsList.length]?.classList.add('pulsing-slot');
           }
           
           const isTouch = 'ontouchstart' in window;
           if(isTouch && this.banPickState.selectionCandidate) {
               const item = ITEM_CONFIG[this.banPickState.selectionCandidate]; let stats = [`⏳ ${item.baseRespawn/1000}s`]; if(item.stats) for(const[k,v]of Object.entries(item.stats)){let i='🔹';if(k.toLowerCase().includes('thời gian'))i='⏱️';if(k.toLowerCase().includes('hiệu ứng'))i='✨';stats.push(`${i} ${v}`);} mobileInfo.innerHTML = `<p class="font-bold text-lg">${item.name}</p><p class="text-xs text-gray-400 mb-1">${item.desc}</p><div class="mt-1 pt-1 border-t border-gray-700 text-xs text-gray-300">${stats.join(' • ')}</div>`; mobileInfo.classList.remove('hidden'); title.classList.add('hidden');
           } else { mobileInfo.classList.add('hidden'); title.classList.remove('hidden'); }
         
           const banned = [...this.banPickState.p1Bans, ...this.banPickState.p2Bans];
           document.querySelectorAll('.ban-pick-item').forEach(el => {
               const type = el.id.replace('bp-item-','');
               el.classList.remove('banned', 'picked-p1', 'picked-p2', 'selectable');
               if(this.banPickState.selectionCandidate === type) el.classList.add('border-yellow-400');
               if(banned.includes(type)) el.classList.add('banned');
               else if (this.banPickState.p1Picks.includes(type)) el.classList.add('picked-p1');
               else if (this.banPickState.p2Picks.includes(type)) el.classList.add('picked-p2');
               else el.classList.add('selectable');
           });
         }
         
         handleBanPickSelection(type) {
           const currentStep = banPickSequence[this.banPickState.currentIndex]; if (!currentStep) return; const banned = [...this.banPickState.p1Bans, ...this.banPickState.p2Bans], picked = [...this.banPickState.p1Picks, ...this.banPickState.p2Picks]; if (banned.includes(type) || picked.includes(type)) return;
           this.sound.playSelect();
           
           if (this.state.gameMode === 'random' && currentStep.phase === 'pick') {
               this.finalizeSelectionsAndStart();
               return;
           }
         
           if (this.banPickState.selectionCandidate === type) {
               if (currentStep.phase === 'ban') { if (currentStep.player === 1) this.banPickState.p1Bans.push(type); else this.banPickState.p2Bans.push(type); }
               else { if (currentStep.player === 1) this.banPickState.p1Picks.push(type); else this.banPickState.p2Picks.push(type); }
               this.banPickState.currentIndex++; this.banPickState.selectionCandidate = null;
               if (this.banPickState.currentIndex >= banPickSequence.length) this.finalizeSelectionsAndStart();
               else this.updateBanPickUI();
           } else { this.banPickState.selectionCandidate = type; this.updateBanPickUI(); }
         }
         
         finalizeSelectionsAndStart() {
           const banned = [...this.banPickState.p1Bans, ...this.banPickState.p2Bans];
           const allItems = Object.keys(ITEM_CONFIG);
           let available = allItems.filter(t => !banned.includes(t) && ITEM_CONFIG[t].type !== 'neutral');
         
           if (this.state.gameMode === 'random') {
               this.banPickState.p1Picks = []; this.banPickState.p2Picks = [];
               for(let i=0; i<3; i++) { if(available.length > 0) this.banPickState.p1Picks.push(available.splice(Math.floor(Math.random()*available.length), 1)[0]); }
               for(let i=0; i<3; i++) { if(available.length > 0) this.banPickState.p2Picks.push(available.splice(Math.floor(Math.random()*available.length), 1)[0]); }
           }
         
           let commonItems = [];
           const picked = [...this.banPickState.p1Picks, ...this.banPickState.p2Picks];
           available = available.filter(t => !picked.includes(t));
           while(commonItems.length < 2 && available.length > 0) commonItems.push(available.splice(Math.floor(Math.random()*available.length), 1)[0]);
           
           const active = {}; ['health','weapon','shield'].forEach(t => active[t] = {owner: 'neutral'});
           this.banPickState.p1Picks.forEach(t => active[t] = {owner: 'p1'}); this.banPickState.p2Picks.forEach(t => active[t] = {owner: 'p2'});
           commonItems.forEach(t => active[t] = {owner: 'neutral'});
           
           this.showIntroScreen(this.banPickState.p1Picks, this.banPickState.p2Picks, commonItems, active);
         }
         
         showIntroScreen(p1Picks, p2Picks, common, activeItems) {
           this.ui.showScreen('intro');
           const { p1Panel, p2Panel, countdown } = this.ui.dom.intro;
           const createPanel = (picks, title, color) => `<h2 class="text-3xl font-bold mb-6 ${color}">${title}</h2><div class="space-y-4">${picks.map(type => `<div class="intro-item flex items-center gap-4 bg-gray-800 p-2 rounded-lg"><div class="scale-125">${ICONS[type]}</div><span class="text-lg font-semibold">${ITEM_CONFIG[type].name}</span></div>`).join('')}</div>`;
           p1Panel.innerHTML = createPanel(p1Picks, 'Người chơi 1', 'text-blue-400');
           p2Panel.innerHTML = createPanel(p2Picks, 'Người chơi 2', 'text-red-400');
           
           setTimeout(() => {
               countdown.classList.remove('opacity-0');
               let count = 3; countdown.textContent = count;
               const interval = setInterval(() => {
                   count--;
                   if (count > 0) { countdown.textContent = count; this.sound.playClick(); }
                   else if (count === 0) { countdown.textContent = "Bắt Đầu!"; countdown.classList.add('text-7xl'); this.sound.playStart(); }
                   else { clearInterval(interval); this.ui.showScreen(''); countdown.classList.remove('text-7xl'); countdown.classList.add('opacity-0'); this.startGame(activeItems); }
               }, 1000);
           }, 1500);
         }
         
         startGame(activeItems) {
           this.requestWakeLock();
           this.logic.setupMatch(activeItems);
           this.logic.startMatch();
           this.state.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
         }
         
         gameLoop() {
           if (!this.state.animationFrameId) return;
           this.logic.updateAndDraw();
           this.state.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
         }
         
         stopGameLoop() {
           if (this.state.animationFrameId) { cancelAnimationFrame(this.state.animationFrameId); this.state.animationFrameId = null; }
           if (this.state.effectLoopId) { cancelAnimationFrame(this.state.effectLoopId); this.state.effectLoopId = null; }
           this.logic.stopMatch();
         }
         
         endGame(isTimeUp = false, winnerPlayer = null) {
           this.stopGameLoop();
           this.releaseWakeLock();
           this.ui.showScreen('gameOver');
           this.ui.toggleGameUI(false);
           
           const p1 = this.logic.players[0], p2 = this.logic.players[1];
           let winner = null;
           
           if (winnerPlayer) { winner = winnerPlayer; } 
           else if (isTimeUp) { if (p1.score > p2.score) winner = p1; else if (p2.score > p1.score) winner = p2; else { if (p1.lives > p2.lives) winner = p1; else if (p2.lives > p1.lives) winner = p2; } }
         
           if (winner === p1) this.state.p1SeriesWins++;
           else if (winner === p2) this.state.p2SeriesWins++;
           
           const { text, results, seriesResults } = this.ui.dom.winner;
           text.className = 'text-4xl font-bold mb-4';
           if (winner) { text.textContent = `${winner.name} chiến thắng trận này!`; text.classList.add(winner === p1 ? 'text-blue-500' : 'text-red-500'); this.sound.playGameOver(true); }
           else { text.textContent = 'Hòa!'; this.sound.playGameOver(false); }
           
           results.innerHTML = `<div class="flex justify-around items-center text-center"><div class="p-4 bg-gray-800 rounded-lg w-2/5"><p class="font-bold text-blue-500">Người chơi 1</p><p>Điểm: <span class="font-bold text-2xl">${p1.score}</span></p><p class="text-sm">Mạng còn lại: ${p1.lives}</p></div><div class="text-2xl font-bold px-2">VS</div><div class="p-4 bg-gray-800 rounded-lg w-2/5"><p class="font-bold text-red-500">Người chơi 2</p><p>Điểm: <span class="font-bold text-2xl">${p2.score}</span></p><p class="text-sm">Mạng còn lại: ${p2.lives}</p></div></div>`;
           
           const winTarget = Math.ceil(this.state.seriesType / 2);
           if (this.state.seriesType > 1) {
               seriesResults.innerHTML = `<p class="mt-4 text-xl">Tỉ số series: <span class="font-bold text-blue-500">${this.state.p1SeriesWins}</span> - <span class="font-bold text-red-500">${this.state.p2SeriesWins}</span></p>`;
               if (this.state.p1SeriesWins >= winTarget || this.state.p2SeriesWins >= winTarget) {
                   const seriesWinner = this.state.p1SeriesWins > this.state.p2SeriesWins ? p1 : p2;
                   seriesResults.innerHTML += `<p class="mt-2 text-2xl font-bold ${seriesWinner === p1 ? 'text-blue-400' : 'text-red-400'}"> ${seriesWinner.name} chiến thắng chung cuộc!</p>`;
                   this.ui.dom.buttons.nextMatch.classList.add('hidden');
               } else {
                   this.ui.dom.buttons.nextMatch.classList.remove('hidden');
               }
           } else {
               seriesResults.innerHTML = '';
           }
         }
         
         // --- UTILITIES ---
         async requestWakeLock() { if ('wakeLock' in navigator) try { this.state.wakeLock = await navigator.wakeLock.request('screen'); } catch (err) { console.error(`Wake Lock failed: ${err.name}, ${err.message}`); } }
         async releaseWakeLock() { if (this.state.wakeLock) { await this.state.wakeLock.release(); this.state.wakeLock = null; } }
         saveGameSettings() { const settings = { mode: this.state.gameMode, series: this.state.seriesType }; localStorage.setItem('lastGameSettings', JSON.stringify(settings)); }
         checkSavedGame() { const saved = localStorage.getItem('lastGameSettings'); this.ui.dom.buttons.loadLast.disabled = !saved; }
         loadAndStart() {
           const saved = localStorage.getItem('lastGameSettings');
           if (saved) {
               const settings = JSON.parse(saved);
               this.state.gameMode = settings.mode;
               this.state.seriesType = settings.series;
               this.ui.dom.selectors.mode.querySelector(`[data-mode="${settings.mode}"]`).click();
               this.ui.dom.selectors.series.querySelector(`[data-series="${settings.series}"]`).click();
               this.handleStartClick();
           }
         }
         }
         
         const gameManager = new GameManager();
         
      </script>
   </body>
</html>
