<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Trận Tử Chiến: Ghép Cặp Hoàn Hảo</title>
    
    <!-- PWA Additions -->
    <meta name="theme-color" content="#3b82f6"/>
    <!-- End PWA Additions -->

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation;
            overscroll-behavior-y: contain;
            -webkit-user-select: none; user-select: none;
            background: linear-gradient(-45deg, #f0f9ff, #e0f2fe, #dbeafe, #e0e7ff);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
        }
        
        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes deal {
            from { opacity: 0; transform: translateY(20px) scale(0.9); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        @keyframes pop {
            0%, 100% { transform: scale(1.05); }
            50% { transform: scale(1.15); }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        @keyframes timeBonus {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
        @keyframes pulse {
           50% { box-shadow: 0 0 0 5px rgba(22, 163, 74, 0.5); }
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card {
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .card.selected, .card.tut-correct {
            transform: scale(1.08);
            border-color: #3b82f6;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.5), 0 10px 15px -3px rgb(0 0 0 / 0.1);
        }
        .card.dimmed { 
            filter: blur(4px);
            opacity: 0.5;
            transform: scale(0.95);
        }
        .card svg { width: 70%; height: 70%; }
        #game-board, #demo-board {
            display: grid;
            gap: 0.75rem; /* 12px */
            width: 100%;
            max-width: 600px;
            margin: auto;
        }
        #game-board.level-1, #demo-board.size-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        #game-board.level-2 { grid-template-columns: repeat(4, minmax(0, 1fr)); }
        #game-board.level-3 { grid-template-columns: repeat(5, minmax(0, 1fr)); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .history-list { display: flex; flex-direction: column; gap: 8px; }
        .history-item { 
            display: flex; align-items: center; gap: 0.75rem; padding: 0.5rem; 
            border-radius: 0.5rem; background-color: rgba(255, 255, 255, 0.7); cursor: pointer;
            transition: background-color 0.2s;
        }
         .history-item:hover { background-color: rgba(230, 240, 255, 0.9); }
        #missed-sets-summary .history-item { background-color: rgba(255, 255, 255, 0.1); color: white; }
        #missed-sets-summary .history-item .text-gray-500 { color: #d1d5db; /* gray-300 */ }
        .history-item .card-container { display: flex; flex-grow: 1; justify-content: center; gap: 0.375rem; }
        .history-item .card { width: 24px; height: 24px; border-width: 1px; box-shadow: none; border-radius: 4px; }
        .history-item .card svg { width: 80%; height: 80%; }
        
        .mode-btn.active, .assist-btn.active { background-color: #3b82f6; color: white; }
        .assist-btn { transition: all 0.2s; }

        #missed-sets-summary::-webkit-scrollbar { height: 8px; }
        #missed-sets-summary::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.1); border-radius: 4px; }
        #missed-sets-summary::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.3); border-radius: 4px; }
        #missed-sets-summary::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.5); }

        .panel {
            background-color: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.05), 0 2px 4px -2px rgb(0 0 0 / 0.05);
        }
    </style>
</head>
<body class="text-gray-800 flex items-center justify-center p-2">

    <div id="app-container" class="w-full max-w-7xl h-full mx-auto relative">
        <!-- Main Menu -->
        <div id="main-menu" class="h-full flex flex-col items-center justify-center text-center p-4" style="animation: fadeInUp 0.5s ease-out;">
            <h1 class="text-4xl sm:text-6xl font-extrabold text-gray-900 mb-4">Trận Tử Chiến</h1>
            <p class="text-gray-600 mb-8 max-w-md mx-auto text-lg">Thử thách khả năng quan sát và logic của bạn.</p>
            
            <div class="flex flex-col md:flex-row gap-8 mb-8">
                <div class="p-4 panel">
                    <h3 class="text-lg font-bold text-gray-800 mb-3">Chế độ chơi</h3>
                    <div class="flex justify-center rounded-lg shadow-sm" role="group">
                        <button id="mode-classic-btn" type="button" class="mode-btn px-6 py-3 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-l-lg hover:bg-gray-100 focus:z-10 focus:ring-2 focus:ring-blue-700">
                            Cổ điển
                        </button>
                        <button id="mode-dual-btn" type="button" class="mode-btn px-6 py-3 text-sm font-medium text-gray-900 bg-white border border-gray-200 rounded-r-lg hover:bg-gray-100 focus:z-10 focus:ring-2 focus:ring-blue-700 active">
                            Nền Kép
                        </button>
                    </div>
                </div>
                 <div class="p-4 panel">
                    <h3 class="text-lg font-bold text-gray-800 mb-3">Hỗ trợ</h3>
                    <div class="grid grid-cols-3 gap-2 text-center">
                        <button id="assist-useless-btn" class="assist-btn p-2 rounded-lg bg-white border border-gray-200 hover:bg-gray-100 flex flex-col items-center justify-center gap-1 active">
                           <svg class="w-7 h-7" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59" /></svg>
                           <span class="text-xs font-semibold">Làm mờ ô vô dụng</span>
                        </button>
                        <button id="assist-bg-btn" class="assist-btn p-2 rounded-lg bg-white border border-gray-200 hover:bg-gray-100 flex flex-col items-center justify-center gap-1">
                           <svg class="w-7 h-7" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.5 11.5a8.5 8.5 0 1117 0 8.5 8.5 0 01-17 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.5 11.5a6 6 0 10-12 0 6 6 0 0012 0z" /></svg>
                           <span class="text-xs font-semibold">Làm mờ nền khác</span>
                        </button>
                        <button id="assist-shape-btn" class="assist-btn p-2 rounded-lg bg-white border border-gray-200 hover:bg-gray-100 flex flex-col items-center justify-center gap-1">
                            <svg class="w-7 h-7" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.196-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.783-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z" /></svg>
                            <span class="text-xs font-semibold">Ẩn hình đã chọn</span>
                        </button>
                    </div>
                </div>
            </div>

            <div class="flex flex-col sm:flex-row gap-4 justify-center">
                <button id="start-game-btn" class="bg-blue-600 text-white font-bold py-4 px-8 rounded-lg text-lg hover:bg-blue-700 transition-transform hover:scale-105 shadow-lg">Bắt đầu chơi</button>
                <button id="start-tutorial-btn" class="bg-white text-gray-800 font-bold py-4 px-8 rounded-lg text-lg hover:bg-gray-100 transition-transform hover:scale-105 shadow-lg">Hướng dẫn</button>
            </div>
        </div>
        
        <!-- Tutorial Container -->
        <div id="tutorial-container" class="hidden h-full flex flex-col panel p-4 sm:p-6" style="animation: fadeInUp 0.5s ease-out;">
             <h2 class="text-2xl font-bold text-center mb-4">Hướng dẫn chơi</h2>
             <p id="tutorial-instructions" class="text-center text-gray-700 mb-4 h-20"></p>
             <div id="tutorial-board" class="grid grid-cols-3 gap-2 sm:gap-3 mb-4 max-w-sm mx-auto"></div>
             <button id="tutorial-next-btn" class="w-full max-w-sm mx-auto bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 transition-colors hidden mt-auto shadow-lg">OK, Đã hiểu!</button>
        </div>

        <!-- Game Container -->
        <div id="game-container" class="hidden h-full relative flex flex-col panel">
            <!-- Main Content -->
            <div class="flex-grow flex flex-col lg:flex-row gap-4 p-4 lg:p-6 overflow-hidden">
                
                <!-- Left Panel -->
                <div class="w-full lg:w-60 flex-shrink-0 flex flex-col gap-4">
                    <div class="flex justify-between items-center">
                        <button id="back-to-menu-btn" class="text-sm font-semibold text-blue-600 hover:text-blue-800">‹ Trang chính</button>
                        <button id="pause-btn" class="lg:hidden p-2 rounded-full bg-white/50 hover:bg-white/80">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M5.5 16a1 1 0 01-1-1V5a1 1 0 012 0v10a1 1 0 01-1 1zm8 0a1 1 0 01-1-1V5a1 1 0 012 0v10a1 1 0 01-1 1z" /></svg>
                        </button>
                    </div>
                    
                    <div class="bg-white/50 border border-white/30 rounded-xl p-3 text-sm">
                        <!-- Row 1: Level & Score -->
                        <div class="flex justify-between items-baseline mb-2">
                            <div class="flex items-baseline gap-2">
                                <span class="font-semibold text-gray-600">Cấp:</span>
                                <span id="level-stat" class="font-bold text-base">1</span>
                            </div>
                            <div class="flex items-baseline gap-2">
                                <span class="font-semibold text-gray-600">Điểm:</span>
                                <span id="score-stat" class="font-bold text-base">0</span>
                            </div>
                        </div>
            
                        <!-- Row 2: Time, Penalty, Lives -->
                        <div class="flex justify-between items-center">
                            <div id="total-time-stat" class="font-bold text-base w-14">00:00</div>
                            <div id="penalty-tracker" class="flex items-center justify-center gap-1.5 flex-grow"></div>
                            <div id="lives-stat" class="font-bold text-xl w-14 text-right"></div>
                        </div>
                    </div>
                    
                    <div class="hidden lg:flex flex-col gap-3 mt-auto">
                        <button id="pause-btn-desktop" class="w-full flex items-center justify-center gap-2 bg-yellow-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-yellow-600 shadow-md">
                           <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M5.5 16a1 1 0 01-1-1V5a1 1 0 012 0v10a1 1 0 01-1 1zm8 0a1 1 0 01-1-1V5a1 1 0 012 0v10a1 1 0 01-1 1z" /></svg>
                           Tạm dừng
                        </button>
                    </div>
                </div>

                <!-- Center Panel -->
                <div class="flex-grow flex flex-col min-w-0 relative game-board-container">
                    <div id="game-info-bar" class="flex items-center gap-4 mb-2">
                         <div class="flex-grow flex items-center gap-2">
                            <div class="w-full bg-gray-200/70 rounded-full h-2.5">
                                <div id="completion-bar" class="bg-green-500 h-2.5 rounded-full transition-all" style="width: 0%"></div>
                            </div>
                            <span id="completion-stat" class="font-semibold text-sm text-gray-600 w-12 text-right">0%</span>
                        </div>
                        <div class="flex items-center gap-2 text-blue-600 font-semibold text-sm flex-shrink-0">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 100-2H9V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                            <p id="selection-time-stat" class="w-6 text-center">00</p>
                        </div>
                    </div>
                    <div class="flex-grow flex flex-col items-center justify-center min-h-0 relative">
                        <div id="game-board" class="aspect-square"></div>
                        <div id="board-pause-overlay" class="hidden absolute inset-0 bg-white/50 backdrop-blur-sm flex flex-col items-center justify-center gap-8 rounded-lg z-20">
                            <h3 class="text-2xl font-bold text-gray-800">Đã tạm dừng</h3>
                            <button id="surrender-btn-pause" class="bg-red-600 text-white font-bold py-3 px-6 rounded-lg text-lg hover:bg-red-700 shadow-md">Bỏ cuộc</button>
                        </div>
                    </div>
                </div>

                <!-- Right Panel -->
                <div class="w-full lg:w-72 flex-shrink-0 flex flex-col min-h-[120px] lg:min-h-0">
                    <div id="history-panel" class="history-list flex-grow bg-white/50 border border-white/30 rounded-xl p-2 overflow-y-auto">
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- MODALS & POPUPS - Moved outside of main container for correct positioning -->
    <div id="game-modal-container"></div>
    
    <div id="feedback-popup" class="fixed top-5 right-5 rounded-lg shadow-lg p-4 font-semibold z-50 transition-transform duration-500" style="transform: translateX(calc(100% + 1.25rem));">
        <p id="feedback-popup-text"></p>
    </div>


    <script type="module">
        // --- CONSTANTS & CONFIG ---
        const ALL_SHAPES = ['square', 'circle', 'triangle', 'inv-triangle'];
        const DUAL_SHAPE_COLORS = ['#ef4444', '#f59e0b', '#3b82f6', '#22c55e']; 
        const DUAL_BACKGROUNDS = ['#FFFFFF', '#27272a'];
        const CLASSIC_BACKGROUNDS = ['#9CA3AF', '#FFFFFF', '#1F2937']; // Gray, White, Black
        const CLASSIC_SHAPE_COLORS = ['#ef4444', '#3b82f6', '#22c55e', '#FFFFFF', '#111827']; // Red, Blue, Green, White, near-Black
        const LEVEL_CONFIG = {
            1: { size: 3, totalTime: 180, baseLives: 3 },
            2: { size: 4, totalTime: 240, baseLives: 4 },
            3: { size: 5, totalTime: 300, baseLives: 5 },
        };
        const SVGS = {
            square: c => `<svg viewBox="0 0 100 100" fill="${c}"><rect x="10" y="10" width="80" height="80" rx="8"></rect></svg>`,
            circle: c => `<svg viewBox="0 0 100 100" fill="${c}"><circle cx="50" cy="50" r="45"></circle></svg>`,
            triangle: c => `<svg viewBox="0 0 100 100" fill="${c}"><polygon points="50,5 95,95 5,95"></polygon></svg>`,
            'inv-triangle': c => `<svg viewBox="0 0 100 100" fill="${c}"><polygon points="5,5 95,5 50,95"></polygon></svg>`,
        };
        const FIXED_SELECTION_TIME = 15;
        const TIME_BONUS_ON_CORRECT = 5;
        const TIME_PENALTY_ON_WRONG = 5;
        const COMBO_TIME_BONUS = 30;
        const MAX_PENALTY_COUNT = 5;
        const AUTO_REDIRECT_DELAY = 5; // seconds

        // --- GAME STATE & UI ELEMENTS ---
        let state = {}; let tutorialState = {}; let selectedGameMode = 'dual';
        let settings = {
            isUselessDimEnabled: true,
            isBgDimEnabled: false,
            isShapeDimEnabled: false,
        };

        const ui = {
            views: { mainMenu: document.getElementById('main-menu'), tutorial: document.getElementById('tutorial-container'), game: document.getElementById('game-container') },
            gameBoard: document.getElementById('game-board'),
            gameBoardContainer: document.querySelector('.game-board-container'),
            pauseBtns: [document.getElementById('pause-btn'), document.getElementById('pause-btn-desktop')],
            surrenderBtnPause: document.getElementById('surrender-btn-pause'),
            boardPauseOverlay: document.getElementById('board-pause-overlay'),
            historyPanel: document.getElementById('history-panel'),
            gameInfoBar: document.getElementById('game-info-bar'),
            feedbackPopup: { container: document.getElementById('feedback-popup'), text: document.getElementById('feedback-popup-text') },
            gameModalContainer: document.getElementById('game-modal-container'),
            stats: { 
                level: document.getElementById('level-stat'), 
                score: document.getElementById('score-stat'), 
                lives: document.getElementById('lives-stat'), 
                completion: document.getElementById('completion-stat'), 
                completionBar: document.getElementById('completion-bar'),
                totalTime: document.getElementById('total-time-stat'),
                selectionTime: document.getElementById('selection-time-stat'),
                penaltyTracker: document.getElementById('penalty-tracker'),
            },
            tutorial: { board: document.getElementById('tutorial-board'), instructions: document.getElementById('tutorial-instructions'), nextBtn: document.getElementById('tutorial-next-btn') },
            modeButtons: { classic: document.getElementById('mode-classic-btn'), dual: document.getElementById('mode-dual-btn') },
            assistBtns: {
                useless: document.getElementById('assist-useless-btn'),
                bg: document.getElementById('assist-bg-btn'),
                shape: document.getElementById('assist-shape-btn')
            },
            assistTexts: document.querySelectorAll('.assist-text')
        };

        // --- UTILITY & CORE LOGIC ---
        const formatTime = s => `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;
        const getSetId = cs => cs.map(c => c.id).sort((a,b) => a-b).join('-');
        const parseMarkdown = (text) => text.replace(/\*\*(.*?)\*\*/g, '<strong class="font-bold text-blue-600">$1</strong>');
        
        function getCardPool(mode) {
            let cs = [], id = 0;
            if (mode === 'classic') {
                const BGS = CLASSIC_BACKGROUNDS; 
                const COLORS = CLASSIC_SHAPE_COLORS;
                BGS.forEach(bg => {
                    ALL_SHAPES.forEach(s => {
                        let allowedColors = COLORS;
                        if (bg === '#9CA3AF') {
                            allowedColors = ['#FFFFFF', '#111827'];
                        }
                        
                        allowedColors.forEach(sc => {
                            const isWhiteOnWhite = bg === '#FFFFFF' && sc === '#FFFFFF';
                            const isBlackOnBlack = bg === '#1F2937' && sc === '#111827';
                            
                            if (!isWhiteOnWhite && !isBlackOnBlack) {
                                cs.push({ id: id++, background: bg, shape: s, shapeColor: sc });
                            }
                        });
                    });
                });
            } else { // 'dual' mode
                const bgs = DUAL_BACKGROUNDS; // White and Black
                bgs.forEach(b => {
                    ALL_SHAPES.forEach(s => {
                        DUAL_SHAPE_COLORS.forEach(sc => {
                            cs.push({ id: id++, background: b, shape: s, shapeColor: sc });
                        });
                    });
                });
            }
            return cs;
        }

        function checkSet(cards, mode) {
            if (cards.length !== 3) return false;

            const gameMode = mode || state.gameMode;
            const backgrounds = new Set(cards.map(c => c.background));
            const shapes = new Set(cards.map(c => c.shape));
            const shapeColors = new Set(cards.map(c => c.shapeColor));

            if (gameMode === 'classic') {
                return backgrounds.size === 3 && shapes.size === 3 && shapeColors.size === 3;
            } else { // 'dual' mode
                return backgrounds.size === 1 && shapes.size === 3 && shapeColors.size === 3;
            }
        }

        function findAllSets(board, mode) {
            const sets = [];
            for (let i = 0; i < board.length; i++) for (let j = i + 1; j < board.length; j++) for (let k = j + 1; k < board.length; k++) {
                if (checkSet([board[i], board[j], board[k]], mode)) sets.push([board[i], board[j], board[k]]);
            }
            return sets;
        }

        function generateBoard(level, mode) {
            const boardSize = LEVEL_CONFIG[level].size ** 2;
            const cardPool = getCardPool(mode);
            while (true) {
                let currentPool = [...cardPool];
                for(let i=currentPool.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[currentPool[i],currentPool[j]]=[currentPool[j],currentPool[i]];}
                const candidateBoard=currentPool.slice(0,boardSize);
                if (findAllSets(candidateBoard, mode).length > 0) return candidateBoard;
            }
        }
        
        // --- RENDER & UI ---
        function showView(viewName) { 
            Object.values(ui.views).forEach(v => v.classList.add('hidden')); 
            ui.views[viewName].classList.remove('hidden'); 
        }
        
        function showMessage(text, textColor, bgColor) {
            const popup = ui.feedbackPopup;
            if (state.messageTimer) {
                clearTimeout(state.messageTimer);
            }
            popup.container.style.transition = 'none';
            popup.container.style.transform = 'translateX(calc(100% + 1.25rem))';
            popup.container.offsetHeight; 
            popup.text.textContent = text;
            const colorsToRemove = ['bg-red-600', 'text-white', 'bg-yellow-300', 'text-yellow-800', 'bg-green-600'];
            popup.container.classList.remove(...colorsToRemove);
            popup.container.classList.add(bgColor, textColor);
            popup.container.style.transition = 'transform 0.5s ease-out';
            popup.container.style.transform = 'translateX(0)';

            state.messageTimer = setTimeout(() => { 
                popup.container.style.transform = 'translateX(calc(100% + 1.25rem))';
            }, 2500);
        }

        function renderCard(card, index = 0) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card aspect-square rounded-xl flex items-center justify-center cursor-pointer border-4 border-transparent';
            cardEl.dataset.id = card.id;
            cardEl.style.backgroundColor = card.background;
            if (card.background === DUAL_BACKGROUNDS[1]) cardEl.classList.add('border-gray-700');
            cardEl.innerHTML = SVGS[card.shape](card.shapeColor);
            cardEl.style.animation = `deal 0.5s ease-out ${index * 0.04}s both`;
            
            const onDealAnimationEnd = (e) => {
                if (e.animationName === 'deal') {
                    cardEl.style.animation = '';
                    cardEl.removeEventListener('animationend', onDealAnimationEnd);
                }
            };
            cardEl.addEventListener('animationend', onDealAnimationEnd);

            return cardEl;
        }

        function renderBoard(container, cards, clickHandler) {
            container.innerHTML = '';
            if (container.id === 'game-board' && state.level) { 
                container.classList.remove('level-1', 'level-2', 'level-3');
                container.classList.add(`level-${state.level}`);
            }
            cards.forEach((card, index) => {
                const cardEl = renderCard(card, index);
                if (clickHandler) cardEl.addEventListener('click', () => clickHandler(cardEl, card));
                
                 cardEl.addEventListener('mouseover', () => {
                    if (state.isGameOver || state.isPaused || state.isChecking || document.getElementById('post-game-overlay')) return;
                    state.hoveredShape = card.shape;
                    updateBoardAppearance();
                });
                cardEl.addEventListener('mouseout', () => {
                    if (state.isGameOver || state.isPaused || state.isChecking) return;
                    state.hoveredShape = null;
                    updateBoardAppearance();
                });

                container.appendChild(cardEl);
            });
        }
        
        function createHistoryItem(cards, itemNumber) {
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item flex-shrink-0';
            
            historyItem.addEventListener('mouseover', () => {
                if (state.isGameOver) return;
                state.historyHoverSet = cards;
                updateBoardAppearance();
            });

            historyItem.addEventListener('mouseout', () => {
                if (state.isGameOver) return;
                state.historyHoverSet = null;
                updateBoardAppearance();
            });

            const numberEl = document.createElement('span');
            numberEl.className = 'text-sm font-bold text-gray-500 w-5 text-center';
            numberEl.textContent = `${itemNumber}.`;
            historyItem.appendChild(numberEl);

            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-container';
            cards.sort((a, b) => a.id - b.id).forEach(card => {
                const cardEl = renderCard(card);
                cardEl.classList.remove('cursor-pointer', 'aspect-square');
                cardEl.style.animation = 'none';
                cardContainer.appendChild(cardEl);
            });
            historyItem.appendChild(cardContainer);
            return historyItem;
        }
        
        function renderStats() {
             ui.stats.level.textContent = state.level;
             ui.stats.score.textContent = state.score;
             ui.stats.lives.textContent = '❤️'.repeat(state.lives > 0 ? state.lives : 0);
             
             const percentage = state.totalSetsInRound > 0 ? Math.round((state.foundSets.size / state.totalSetsInRound) * 100) : 0;
             ui.stats.completion.textContent = `${percentage}%`;
             ui.stats.completionBar.style.width = `${percentage}%`;
             
             ui.stats.totalTime.textContent = formatTime(state.totalTimeLeft || 0);
             ui.stats.selectionTime.textContent = String(state.selectionTimeLeft || 0).padStart(2, '0');

            ui.stats.penaltyTracker.innerHTML = '';
            for (let i = 0; i < MAX_PENALTY_COUNT; i++) {
                const dot = document.createElement('div');
                dot.className = 'w-2 h-2 rounded-full transition-colors duration-300';
                if (state.comboCount > 0 && i < state.comboCount) {
                    dot.classList.add('bg-green-500'); // Green dot for combo
                } else if (state.penaltyCount > 0 && i < state.penaltyCount) {
                     dot.classList.add('bg-red-500'); // Red dot for penalty
                }
                else {
                    dot.classList.add('bg-gray-300'); // Default empty dot
                }
                ui.stats.penaltyTracker.appendChild(dot);
            }
        }
        
        function updateBoardAppearance() {
            if (!state.boardCards) return;

            const historyCardIds = state.historyHoverSet ? new Set(state.historyHoverSet.map(c => c.id)) : null;

            const reFoundThirdCardIds = new Set();
            if (state.selectedCards.length === 2) {
                state.boardCards.forEach(cardOnBoard => {
                    if (state.selectedCards.some(sel => sel.id === cardOnBoard.id)) return;
                    const potentialSetId = getSetId([...state.selectedCards, cardOnBoard]);
                    if (state.foundSets.has(potentialSetId)) {
                        reFoundThirdCardIds.add(cardOnBoard.id);
                    }
                });
            }

            ui.gameBoard.querySelectorAll('.card').forEach(cardEl => {
                const cardId = parseInt(cardEl.dataset.id, 10);
                const cardData = state.boardCards.find(c => c.id === cardId);
                if (!cardData) return;
                const isSelected = state.selectedCards.some(c => c.id === cardId);

                // Priority 1: History Hovering
                if (historyCardIds) {
                    cardEl.classList.toggle('dimmed', !historyCardIds.has(cardId));
                    return;
                }

                // Priority 2: Re-found set (dim the 3rd card of an already found set)
                if (reFoundThirdCardIds.has(cardId)) {
                    cardEl.classList.toggle('dimmed', true);
                    return;
                }

                // --- Core Dimming Logic ---
                let isDimmed = false;

                // Base Rule: Is the card globally useless?
                if (settings.isUselessDimEnabled && !state.usefulCardIds.has(cardId)) {
                    isDimmed = true;
                }
                
                // Additive Rule: Dim cards of the same shape as selected cards
                if (!isDimmed && settings.isShapeDimEnabled && state.selectedCards.length > 0) {
                    const selectedShapes = new Set(state.selectedCards.map(c => c.shape));
                    if (!isSelected && selectedShapes.has(cardData.shape)) {
                        isDimmed = true;
                    }
                }

                // Additive Rule: Is the background different (and at least one card is selected)?
                if (!isDimmed && state.gameMode === 'dual' && settings.isBgDimEnabled && state.selectedCards.length > 0) {
                    if (!isSelected && cardData.background !== state.selectedCards[0].background) {
                        isDimmed = true;
                    }
                }
                
                cardEl.classList.toggle('dimmed', isDimmed);
            });
        }
        
        function handlePenalty() {
            state.comboCount = 0; // Reset combo streak on any penalty
            state.penaltyCount++;
            state.totalTimeLeft -= TIME_PENALTY_ON_WRONG;
            if (state.penaltyCount >= MAX_PENALTY_COUNT) {
                loseLife();
                showMessage('5 lần bị phạt, -1 mạng!', 'text-white', 'bg-red-600');
                state.penaltyCount = 0;
            }
            renderStats();
        }

        // --- TIMERS & PAUSE ---
        function togglePause() {
            if (ui.views.game.classList.contains('hidden') || document.getElementById('post-game-overlay')) return;
            state.isPaused = !state.isPaused;

            const continueIcon = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z" /></svg>';
            const pauseIcon = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M5.5 16a1 1 0 01-1-1V5a1 1 0 012 0v10a1 1 0 01-1 1zm8 0a1 1 0 01-1-1V5a1 1 0 012 0v10a1 1 0 01-1 1z" /></svg>';

            if (state.isPaused) {
                stopAllTimers();
                ui.boardPauseOverlay.classList.remove('hidden');
                ui.pauseBtns.forEach(btn => {
                    if (btn.id === 'pause-btn-desktop') {
                        btn.innerHTML = `${continueIcon} Tiếp tục`;
                    } else {
                        btn.innerHTML = continueIcon;
                    }
                });
            } else {
                startAllTimers();
                ui.boardPauseOverlay.classList.add('hidden');
                ui.pauseBtns.forEach(btn => {
                    if (btn.id === 'pause-btn-desktop') {
                        btn.innerHTML = `${pauseIcon} Tạm dừng`;
                    } else {
                        btn.innerHTML = pauseIcon;
                    }
                });
            }
        }

        function stopAllTimers() {
            clearInterval(state.totalTimerId);
            clearInterval(state.selectionTimerId);
            if(state.revealInterval) clearInterval(state.revealInterval);
            if(state.gameOverCountdown) clearInterval(state.gameOverCountdown);
        }

        function startAllTimers() {
            stopAllTimers();
            state.totalTimerId = setInterval(() => {
                if (state.totalTimeLeft > 0) state.totalTimeLeft--;
                renderStats();
                if (state.totalTimeLeft <= 0) gameOver('Hết giờ!');
            }, 1000);
            
            state.selectionTimerId = setInterval(() => {
                if(state.isPaused) return;
                if (state.selectionTimeLeft > 0) {
                    state.selectionTimeLeft--;
                } else {
                    handlePenalty(); 
                    resetAndStartSelectionTimer();
                }
                renderStats();
            }, 1000);
        }

        function resetAndStartSelectionTimer() {
            state.selectionTimeLeft = FIXED_SELECTION_TIME;
            renderStats();
        }
        
        // --- GAME FLOW ---
        function handleConfirm() {
            if (state.isGameOver || state.isPaused || state.selectedCards.length !== 3 || state.isChecking) return;
            state.isChecking = true;

            const cards = state.selectedCards.map(c => ui.gameBoard.querySelector(`[data-id='${c.id}']`));

            const isAValidSet = checkSet(state.selectedCards);
            const currentSetId = getSetId(state.selectedCards);
            if (isAValidSet) {
                if (!state.foundSets.has(currentSetId)) {
                    state.foundSets.add(currentSetId);
                    
                    const timeTaken = (Date.now() - state.lastSetFoundTimestamp) / 1000;
                    const basePoints = Math.round(Math.max(10, 500 / timeTaken)); // Adjusted scoring
                    const multiplier = state.gameMode === 'classic' ? 1.5 : 1;
                    const pointsEarned = Math.round(basePoints * multiplier);
                    state.score += pointsEarned;

                    state.totalTimeLeft += TIME_BONUS_ON_CORRECT;
                    
                    cards.forEach(c => c.style.animation = 'pop 0.3s');

                    ui.historyPanel.prepend(createHistoryItem(state.selectedCards, state.foundSets.size));
                    
                    state.lastSetFoundTimestamp = Date.now();
                    state.penaltyCount = 0; // Reset red penalty dots on correct find
                    state.comboCount++; // Increment green combo dot

                    if (state.comboCount >= MAX_PENALTY_COUNT) {
                        state.totalTimeLeft += COMBO_TIME_BONUS;
                        showMessage(`COMBO! +${COMBO_TIME_BONUS}s`, 'text-white', 'bg-green-600');
                        state.comboCount = 0; // Reset combo after bonus
                    }
                    
                    const unfoundSets = state.allSetsInRound.filter(set => !state.foundSets.has(getSetId(set)));
                    state.usefulCardIds = new Set(unfoundSets.flat().map(card => card.id));

                    if (state.foundSets.size >= state.totalSetsInRound) {
                        renderStats();
                        setTimeout(() => levelUp(), 500);
                    }
                } else { 
                    showMessage('Đã tìm thấy!', 'text-yellow-800', 'bg-yellow-300');
                }
            } else { 
                showMessage('Sai rồi!', 'text-white', 'bg-red-600');
                handlePenalty();
                cards.forEach(c => c.style.animation = 'shake 0.4s');
            }

            setTimeout(() => {
                cards.forEach(c => c.style.animation = '');
                state.selectedCards.forEach(c => ui.gameBoard.querySelector(`[data-id='${c.id}']`)?.classList.remove('selected'));
                state.selectedCards = [];
                state.isChecking = false;
                renderStats(); 
                updateBoardAppearance();
                if (state.foundSets.size < state.totalSetsInRound) {
                     resetAndStartSelectionTimer();
                }
                if (state.totalTimeLeft <= 0) gameOver('Hết giờ!');
            }, 400);
        }
        
        function loseLife(){ if(state.lives>0){ state.lives--; renderStats(); if(state.lives<=0) gameOver('Hết mạng!'); } }

        function showGameModal(title, message, buttonText, callback, options = {}) {
            ui.gameModalContainer.innerHTML = `
                <div class="fixed inset-0 bg-black/30 backdrop-blur-sm flex items-center justify-center z-50 p-4">
                    <div class="bg-white rounded-xl shadow-2xl p-6 sm:p-8 text-center max-w-sm w-full" style="animation: fadeInUp 0.3s ease-out;">
                        <h2 class="text-2xl font-bold mb-4">${title}</h2>
                        <p class="mb-6">${message}</p>
                        <button id="modal-button" class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700">OK</button>
                    </div>
                </div>`;
            
            const modalButton = document.getElementById('modal-button');
            stopAllTimers();

            const originalOnClick = () => {
                stopAllTimers();
                ui.gameModalContainer.innerHTML = '';
                if (callback) callback();
            };
            
            modalButton.onclick = originalOnClick;

            if (options.autoCloseDelay) {
                let countdown = options.autoCloseDelay;
                modalButton.textContent = `${buttonText} (${countdown})`;
                state.gameOverCountdown = setInterval(() => {
                    countdown--;
                    if (countdown > 0) {
                        modalButton.textContent = `${buttonText} (${countdown})`;
                    } else {
                        originalOnClick();
                    }
                }, 1000);
            } else {
                 modalButton.textContent = buttonText;
            }
        }

        function gameOver(reason) {
            if (state.isPaused) {
                togglePause();
            }
            stopAllTimers();
            state.isGameOver = true;
            ui.gameInfoBar.classList.add('hidden');
            
            const allSetsOnBoard = findAllSets(state.boardCards, state.gameMode);
            const missedSets = allSetsOnBoard.filter(set => !state.foundSets.has(getSetId(set)));

            const showFinalModal = () => {
                const overlay = document.getElementById('post-game-overlay');
                if (overlay) {
                    overlay.removeEventListener('click', handleOverlayClick);
                    overlay.remove(); // Remove the overlay from the DOM
                }
                stopAllTimers();
                ui.gameBoardContainer.style.zIndex = ''; // Reset z-index
                ui.gameBoard.querySelectorAll('.card').forEach(c => c.classList.remove('dimmed'));
                showGameModal(
                    'Trò Chơi Kết Thúc', 
                    `${reason}<br>Điểm cuối cùng: <span class="font-bold">${state.score}</span>`, 
                    'Về Trang Chính', 
                    () => showView('mainMenu'),
                    { autoCloseDelay: AUTO_REDIRECT_DELAY }
                );
            };
            
            const handleOverlayClick = (event) => {
                 const overlay = document.getElementById('post-game-overlay');
                if (event.target === overlay) {
                     showFinalModal();
                }
            };

            if (missedSets.length > 0) {
                 const gameContainer = document.getElementById('game-container');
                 // Inject the overlay into the game container. This fixes the stacking context issue.
                 gameContainer.insertAdjacentHTML('beforeend', `
                    <div id="post-game-overlay" class="absolute inset-0 bg-black/70 backdrop-blur-sm flex flex-col justify-between items-center py-8 px-4 z-40 cursor-pointer" style="animation: fadeInUp 0.5s;">
                        <div class="w-full max-w-3xl mx-auto pointer-events-none">
                            <div id="missed-sets-summary" class="flex flex-nowrap gap-4 overflow-x-auto pb-4 pointer-events-auto">
                            </div>
                        </div>
                        <div class="w-full max-w-3xl mx-auto pointer-events-none">
                            <p class="text-white/80 text-center text-sm">Nhấn vào vùng trống để bỏ qua</p>
                        </div>
                    </div>`);

                const missedSetsSummary = document.getElementById('missed-sets-summary');
                const postGameOverlay = document.getElementById('post-game-overlay');

                // Now that the overlay and the board container are in the same stacking context (#game-container),
                // this z-index will correctly place the board container on top of the overlay.
                ui.gameBoardContainer.style.zIndex = '45'; 
                postGameOverlay.addEventListener('click', handleOverlayClick);

                let revealIndex = 0;
                state.revealInterval = setInterval(() => {
                    if (revealIndex < missedSets.length) {
                        ui.gameBoard.querySelectorAll('.card').forEach(c => c.classList.add('dimmed'));
                        
                        const set = missedSets[revealIndex];
                        set.forEach(card => {
                            const cardEl = ui.gameBoard.querySelector(`[data-id='${card.id}']`);
                            if (cardEl) cardEl.classList.remove('dimmed');
                        });
                        
                        const historyItem = createHistoryItem(set, revealIndex + 1);
                        missedSetsSummary.appendChild(historyItem);
                        missedSetsSummary.scrollLeft = missedSetsSummary.scrollWidth;

                        revealIndex++;
                    } else {
                        stopAllTimers();
                        setTimeout(showFinalModal, 2000);
                    }
                }, 2000);
            } else {
                showFinalModal();
            }
        }
        
        function levelUp() {
            stopAllTimers();
            state.timeRollover = state.totalTimeLeft;
            const nextLevel = state.level + 1;
            if (LEVEL_CONFIG[nextLevel]) {
                showGameModal(`Hoàn Thành Cấp Độ ${state.level}!`, `Bạn thật xuất sắc!<br>Thưởng +${state.timeRollover} giây và +1 mạng!<br>Điểm hiện tại: <span class="font-bold">${state.score}</span>`, `Tới Cấp Độ ${nextLevel}`, () => startLevel(nextLevel));
            } else {
                showGameModal('Chúc Mừng!', `Bạn đã hoàn thành tất cả các cấp độ!<br>Điểm tổng: <span class="font-bold">${state.score}</span>`, 'Về Trang Chính', () => showView('mainMenu'), { autoCloseDelay: AUTO_REDIRECT_DELAY });
            }
        }

        function startLevel(level) {
            ui.gameInfoBar.classList.remove('hidden');
            ui.gameBoardContainer.style.zIndex = '';
            const config = LEVEL_CONFIG[level];
            state.level = level;
            state.isGameOver = false;
            state.isChecking = false;
            state.hoveredShape = null;
            state.historyHoverSet = null;

            if (level === 1) { 
                state.lives = config.baseLives; 
                state.timeRollover = 0; 
                state.totalTimeLeft = config.totalTime;
            } else { 
                state.lives++;
                state.totalTimeLeft += state.timeRollover;
            }
             
            state.penaltyCount = 0;
            state.comboCount = 0;
            state.selectedCards = []; 
            state.foundSets = new Set();
            state.lastSetFoundTimestamp = Date.now();
            state.boardCards = generateBoard(level, state.gameMode);
            state.allSetsInRound = findAllSets(state.boardCards, state.gameMode);
            state.totalSetsInRound = state.allSetsInRound.length;
            state.usefulCardIds = new Set(state.allSetsInRound.flat().map(card => card.id));
            ui.historyPanel.innerHTML = '';
            const postGameOverlay = document.getElementById('post-game-overlay');
            if(postGameOverlay) postGameOverlay.remove();
            
            renderBoard(ui.gameBoard, state.boardCards, (el, card) => {
                if (state.isGameOver || state.isPaused || state.isChecking) return;
                
                if (el.classList.contains('dimmed') && !state.selectedCards.some(c => c.id == el.dataset.id)) {
                    return;
                }

                const cardData = state.boardCards.find(c => c.id == el.dataset.id);
                const index = state.selectedCards.findIndex(c => c.id == cardData.id);

                if (index > -1) { 
                    state.selectedCards.splice(index, 1); 
                    el.classList.remove('selected'); 
                } 
                else if (state.selectedCards.length < 3) { 
                    state.selectedCards.push(cardData); 
                    el.classList.add('selected'); 
                    if (state.selectedCards.length === 3) {
                        setTimeout(() => handleConfirm(), 100);
                    }
                }
                updateBoardAppearance();
            });
            startAllTimers();
            resetAndStartSelectionTimer();
            updateBoardAppearance();
        }

        function initializeGame() { 
            state = { score: 0, gameMode: selectedGameMode, isPaused: false, historyHoverSet: null }; 
            startLevel(1); 
            showView('game'); 
        }

        // --- TUTORIAL LOGIC ---
        function startTutorial() {
            const makeCard = (id, shape, shapeColor, background) => ({ id, shape, shapeColor, background });
            
            let steps;
            if (selectedGameMode === 'classic') {
                const classicColors = [...CLASSIC_SHAPE_COLORS];
                const step_set = [
                    makeCard(3001, 'square', classicColors[0], CLASSIC_BACKGROUNDS[1]),
                    makeCard(3002, 'circle', classicColors[1], CLASSIC_BACKGROUNDS[2]),
                    makeCard(3003, 'triangle', classicColors[3], CLASSIC_BACKGROUNDS[0]),
                ];
                const step_board = [
                    ...step_set,
                    makeCard(3004, 'square', classicColors[1], CLASSIC_BACKGROUNDS[1]), 
                    makeCard(3005, 'circle', classicColors[0], CLASSIC_BACKGROUNDS[2]),
                    makeCard(3006, 'inv-triangle', classicColors[1], CLASSIC_BACKGROUNDS[2]), 
                    makeCard(3007, 'square', classicColors[2], CLASSIC_BACKGROUNDS[0]),
                    makeCard(3008, 'circle', classicColors[3], CLASSIC_BACKGROUNDS[1]),
                    makeCard(3009, 'inv-triangle', DUAL_SHAPE_COLORS[0], CLASSIC_BACKGROUNDS[2])
                ].sort(() => Math.random() - 0.5);

                steps = [{
                    board: step_board,
                    instruction: "Cổ Điển: Tìm bộ 3 có **nền**, **hình dạng** & **màu sắc** khác nhau."
                }];

            } else { // dual mode
                const allColors = [...DUAL_SHAPE_COLORS];
                const step_set = [ makeCard(2001, 'square', allColors[0], DUAL_BACKGROUNDS[0]), makeCard(2002, 'circle', allColors[1], DUAL_BACKGROUNDS[0]), makeCard(2003, 'triangle', allColors[2], DUAL_BACKGROUNDS[0]) ];
                const step_board = [
                    ...step_set,
                    makeCard(2004, 'square', allColors[1], DUAL_BACKGROUNDS[0]),      
                    makeCard(2005, 'circle', allColors[0], DUAL_BACKGROUNDS[0]),      
                    makeCard(2006, 'inv-triangle', allColors[1], DUAL_BACKGROUNDS[0]),
                    makeCard(2007, 'square', allColors[2], DUAL_BACKGROUNDS[0]),      
                    makeCard(2008, 'circle', allColors[3], DUAL_BACKGROUNDS[0]),      
                    makeCard(2009, 'inv-triangle', allColors[0], DUAL_BACKGROUNDS[0]) 
                ].sort(() => Math.random() - 0.5);

                steps = [{
                    board: step_board,
                    instruction: "Nền Kép: Tìm bộ 3 có **cùng nền**, **khác hình dạng** & **khác màu**."
                }];
            }
            
            tutorialState = {
                step: 0, 
                selectedIds: new Set(),
                steps: steps,
                gameMode: selectedGameMode, // Store mode for tutorial check
            };
            showView('tutorial'); 
            loadTutorialStep();
        }

        function loadTutorialStep() {
            const stepData = tutorialState.steps[tutorialState.step];
            tutorialState.selectedIds.clear();
            ui.tutorial.instructions.innerHTML = parseMarkdown(stepData.instruction);
            ui.tutorial.nextBtn.classList.add('hidden');
            
            renderBoard(ui.tutorial.board, stepData.board, (el, card) => {
                 if (tutorialState.selectedIds.size === 3 && !ui.tutorial.nextBtn.classList.contains('hidden')) return;
                 
                 if (tutorialState.selectedIds.has(card.id)) {
                    tutorialState.selectedIds.delete(card.id);
                    el.classList.remove('selected', 'tut-correct');
                 } else if (tutorialState.selectedIds.size < 3) {
                    tutorialState.selectedIds.add(card.id);
                    el.classList.add('selected');
                 }
                 
                 if (tutorialState.selectedIds.size === 3) {
                    const selectedCards = stepData.board.filter(c => tutorialState.selectedIds.has(c.id));
                    const isCorrect = checkSet(selectedCards, tutorialState.gameMode);
                    
                    if (isCorrect) {
                        ui.tutorial.instructions.innerHTML = parseMarkdown("Chính xác! **Bạn đã hiểu rồi.**");
                        ui.tutorial.nextBtn.classList.remove('hidden');
                        tutorialState.selectedIds.forEach(id => {
                             const cardEl = ui.tutorial.board.querySelector(`[data-id='${id}']`);
                             if (cardEl) cardEl.classList.add('tut-correct');
                        });
                    } else {
                        ui.tutorial.instructions.innerHTML = parseMarkdown("Chưa đúng. **Hãy thử lại!**");
                        setTimeout(() => {
                            tutorialState.selectedIds.forEach(id => { 
                                const cardEl = ui.tutorial.board.querySelector(`[data-id='${id}']`);
                                if (cardEl) cardEl.classList.remove('selected');
                            });
                            tutorialState.selectedIds.clear(); 
                            ui.tutorial.instructions.innerHTML = parseMarkdown(stepData.instruction);
                        }, 1000);
                    }
                }
            });
        }

        // --- APP INITIALIZATION ---
        function initApp() {
            document.getElementById('start-game-btn').addEventListener('click', initializeGame);
            document.getElementById('start-tutorial-btn').addEventListener('click', startTutorial);
            document.getElementById('back-to-menu-btn').addEventListener('click', () => { stopAllTimers(); showView('mainMenu'); });
            
            ui.pauseBtns.forEach(btn => btn.addEventListener('click', togglePause));
            ui.surrenderBtnPause.addEventListener('click', () => gameOver("Bạn đã bỏ cuộc"));
            
            ui.tutorial.nextBtn.addEventListener('click', () => {
                showView('mainMenu');
            });
            
            Object.keys(ui.assistBtns).forEach(key => {
                const button = ui.assistBtns[key];
                button.addEventListener('click', () => {
                        button.classList.toggle('active');
                        switch(key) {
                            case 'useless': settings.isUselessDimEnabled = !settings.isUselessDimEnabled; break;
                            case 'bg': settings.isBgDimEnabled = !settings.isBgDimEnabled; break;
                            case 'shape': settings.isShapeDimEnabled = !settings.isShapeDimEnabled; break;
                        }
                });
            });

            ui.assistTexts.forEach(textEl => {
                textEl.addEventListener('click', () => {
                    const type = textEl.dataset.type;
                    // Demo logic was removed from this snippet for brevity, but would go here
                });
            });

            ui.modeButtons.classic.addEventListener('click', () => {
                selectedGameMode = 'classic';
                ui.modeButtons.classic.classList.add('active');
                ui.modeButtons.dual.classList.remove('active');
                ui.assistBtns.bg.disabled = true;
            });
            ui.modeButtons.dual.addEventListener('click', () => {
                selectedGameMode = 'dual';
                ui.modeButtons.dual.classList.add('active');
                ui.modeButtons.classic.classList.remove('active');
                 ui.assistBtns.bg.disabled = false;
            });

            document.addEventListener('keydown', (event) => {
                if (ui.views.game.classList.contains('hidden')) return;
                
                if (event.key === 'p' || event.key === 'P') {
                    event.preventDefault();
                    togglePause();
                }
            });

            showView('mainMenu');
        }
        
        // --- PWA MANIFEST SETUP (FIXED) ---
        function setupManifest() {
            // Helper function to create icon Data URLs using a standard canvas
            const createIconDataUrl = (size, isMaskable) => {
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                if (isMaskable) {
                    // For a maskable icon, the "safe zone" is a circle with a radius of 40% of the canvas size
                    ctx.fillStyle = '#3b82f6'; // theme-color
                    ctx.beginPath();
                    ctx.arc(size / 2, size / 2, size * 0.4, 0, 2 * Math.PI);
                    ctx.fill();
                } else {
                     ctx.fillStyle = '#3b82f6';
                     ctx.fillRect(0, 0, size, size);
                }

                // Draw the letter 'S' for "Set" or "Chiến"
                ctx.fillStyle = 'white';
                ctx.font = `bold ${size * 0.7}px 'Inter', sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('S', size / 2, size / 2 + size * 0.05); // Minor vertical adjustment
                
                return canvas.toDataURL('image/png');
            };

            // Generate icon data URLs
            const icon192 = createIconDataUrl(192, false);
            const icon512 = createIconDataUrl(512, false);
            const maskableIcon512 = createIconDataUrl(512, true);

            // Create the manifest content with Data URLs for icons
            const manifestContent = {
                "name": "Trận Tử Chiến: Ghép Cặp Hoàn Hảo",
                "short_name": "Trận Tử Chiến",
                "description": "Thử thách khả năng quan sát và logic của bạn trong trò chơi tìm bộ ba.",
                "start_url": ".",
                "display": "standalone",
                "orientation": "portrait",
                "background_color": "#f0f9ff",
                "theme_color": "#3b82f6",
                "icons": [
                    { "src": icon192, "type": "image/png", "sizes": "192x192" },
                    { "src": icon512, "type": "image/png", "sizes": "512x512" },
                    { "src": maskableIcon512, "type": "image/png", "sizes": "512x512", "purpose": "maskable" }
                ]
            };

            // Create a Data URL for the manifest file itself
            const manifestString = JSON.stringify(manifestContent);
            // Correctly encode the string for base64, handling unicode characters
            const manifestDataUrl = 'data:application/manifest+json;base64,' + btoa(unescape(encodeURIComponent(manifestString)));

            // Remove any existing manifest link
            const existingLink = document.querySelector('link[rel="manifest"]');
            if (existingLink) {
                existingLink.remove();
            }
            
            // Create and append the new manifest link to the head
            const manifestLink = document.createElement('link');
            manifestLink.rel = 'manifest';
            manifestLink.href = manifestDataUrl;
            document.head.appendChild(manifestLink);
            
            console.log("PWA manifest has been set up dynamically via Data URL.");
        }


        // Initialize the application and the PWA manifest
        initApp();
        setupManifest();

    </script>
</body>
</html>
