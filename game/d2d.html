<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Tử Chiến Song Khu Oẳn Tù Tì</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet" />
    <style>
        /* ============================================= */
        /* 1. THIẾT KẾ HỆ THỐNG & BIẾN MÀU MỚI           */
        /* ============================================= */
        :root {
            /* Bảng màu mới - Phong cách Material Dark */
            --bg-primary: #12121c;
            /* Nền chính sâu hơn */
            --bg-surface-1: #1e1e2d;
            /* Nền cho các khu vực */
            --bg-surface-2: #2a2a3c;
            /* Nền nổi bật hơn, cho thẻ bài */
            --text-primary: #e0e0e0;
            /* Chữ chính, không quá trắng */
            --text-secondary: #a0a0b0;
            /* Chữ phụ, xám hơn */
            --accent-primary: #4a90e2;
            /* Xanh dương làm điểm nhấn */
            --accent-primary-hover: #357abd;
            --border-color: rgba(255, 255, 255, 0.1);
            --win-color: #4caf50;
            --loss-color: #f44336;
            --draw-color: #9e9e9e;
            --priority-glow: 0 0 10px 2px #ffc107;
            --special-glow: 0 0 10px 2px #03a9f4;
            --font-main: "Inter", sans-serif;
            --border-radius-md: 12px;
            --border-radius-lg: 16px;
            font-size: 16px;
        }

        /* ============================================= */
        /* 2. THIẾT LẬP CƠ BẢN & BỐ CỤC CHUNG           */
        /* ============================================= */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100dvh;
            overflow: hidden;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: var(--font-main);
            user-select: none;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 480px;
            /* Tăng nhẹ max-width */
            height: 100dvh;
            margin: 0 auto;
            position: relative;
            padding: 0.5rem;
            gap: 0.75rem;
        }

        /* ============================================= */
        /* 3. CÁC KHU VỰC CHÍNH (HEADER, PLAYER, BOARD) */
        /* ============================================= */
        #game-header {
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background-color: var(--bg-surface-1);
            border-radius: var(--border-radius-md);
            border: 1px solid var(--border-color);
        }

        #turn-info {
            font-weight: 700;
            font-size: 1rem;
            color: var(--accent-primary);
        }

        #history-trigger {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        #history-dots {
            display: flex;
            gap: 0.3rem;
        }

        .history-dot {
            width: 0.8rem;
            height: 0.8rem;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .history-dot.win {
            background: var(--win-color);
        }

        .history-dot.loss {
            background: var(--loss-color);
        }

        .history-dot.draw {
            background: var(--draw-color);
        }

        .player-area {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem 1rem;
            background-color: var(--bg-surface-1);
            border-radius: var(--border-radius-md);
            border: 1px solid var(--border-color);
            /* THÊM DÒNG NÀY để đẩy bộ đếm sang phải */
            justify-content: space-between;
        }

        .player-name {
            font-weight: 700;
            font-size: 1.1rem;
            /* THÊM CÁC DÒNG NÀY để tạo style mặc định */
            padding: 0.15rem 0.5rem;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        /* THÊM CLASS MỚI: Style cho vai trò Tấn Công */
        /* BỎ CÁC ĐỊNH NGHĨA .player-name.role-attacker và .player-name.role-defender */

        /* THAY THẾ BẰNG CÁC ĐỊNH NGHĨA MỚI CHO .player-info */
        .player-info.role-attacker {
            background-color: var(--loss-color);
            /* Màu đỏ */
            border-color: var(--loss-color);
        }

        .player-info.role-defender {
            background-color: var(--accent-primary);
            /* Màu xanh dương */
            border-color: var(--accent-primary);
        }

        /* Đảm bảo chữ và điểm bên trong có màu tương phản khi nền thay đổi */
        .player-info.role-attacker .player-name,
        .player-info.role-attacker .player-score,
        .player-info.role-defender .player-name,
        .player-info.role-defender .player-score {
            color: white;
        }

        /* Bỏ nền trắng mặc định của player-name để không che mất màu vai trò */
        .player-name {
            font-weight: 700;
            font-size: 1.1rem;
            padding: 0;
            /* Bỏ padding cũ */
            border-radius: 6px;
            transition: all 0.3s ease;
            background-color: transparent;
            /* Đặt nền trong suốt */
        }

        /* SỬA LẠI player-role ĐỂ DÙNG CHO BỘ ĐẾM */
        .player-role {
            font-size: 0.9rem;
            /* Tăng kích thước chữ một chút */
            font-weight: 700;
            padding: 0.25rem 0.6rem;
            border-radius: 8px;
            background-color: #ffc107;
            /* Màu vàng đậm */
            color: black;
            /* Chữ đen */
        }

        .player-score {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--accent-primary);
        }

        /* Bố cục tay bài - linh hoạt và rộng rãi hơn */
        .hand {
            min-height: 6.5rem;
            /* Đảm bảo có không gian cho thẻ bài */
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Bảng đấu - trung tâm của trò chơi */
        #board {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            /* Sửa thành 3 hàng để chứa action-bar */
            grid-template-rows: 6rem 3rem 6rem;
            /* Thay 1fr bằng auto */
            align-items: center;
            /* Căn giữa các hàng theo chiều dọc */
            gap: 0.75rem;
            place-content: center;
            padding: 0.75rem;
            background-color: var(--bg-surface-1);
            border-radius: var(--border-radius-lg);
            border: 1px solid var(--border-color);
            justify-content: center;
            align-content: center;
            justify-items: center;
            align-items: center;
        }

        /* Style cho Action Bar mới */
        #action-bar {
            grid-column: 1 / -1;
            /* Trải dài hết 2 cột */
            width: 100%;
            height: auto;
            /* Chiều cao tự động */
            min-height: 20px;
            /* Chiều cao tối thiểu */
            border: none;
            background: transparent;
            padding: 0.25rem;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            gap: 1rem;
            /* THÊM: Khoảng cách giữa các nút */
        }

        /* THÊM MỚI: Định nghĩa riêng để thu nhỏ nút trong action-bar */
        #action-bar .btn {
            padding: 0.5rem 1.25rem;
            font-size: 0.9rem;
        }

        .action-bar__text {
            font-size: 1rem;
            font-weight: 500;
            animation: fade-in 0.3s ease;
        }

        /* Loại bỏ Game Log cũ */
        #game-log {
            display: none !important;
        }

        .card-slot {
            width: 4.2rem;
            /* SỬA LẠI: Bằng chiều rộng thẻ bài */
            height: 6rem;
            /* SỬA LẠI: Bằng chiều cao thẻ bài */
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: var(--border-radius-md);
            border: 1px dashed var(--border-color);
            position: relative;
            /* Cần cho việc đặt tên khu vực ở bước 3 */
            transition: all 0.3s ease;
        }

        /* Thêm lại hiệu ứng drop-hover cho từng ô */
        .card-slot.drop-hover {
            border-style: solid;
            border-color: var(--accent-primary);
            box-shadow: 0 0 15px rgba(74, 144, 226, 0.5);
        }

        .card-slot::before {
            position: absolute;
            bottom: 0.25rem;
            /* Đưa xuống dưới */
            left: 50%;
            transform: translateX(-50%);
            font-size: 1rem;
            /* Cho to hơn một chút */
            font-weight: 900;
            /* Đậm hơn cho nổi bật */
            z-index: 10;
            /* QUAN TRỌNG: Để nổi lên trên lá bài */
            pointer-events: none;
            /* Để không cản trở việc kéo thả */
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.7);
            /* Thêm bóng cho dễ đọc */
        }

        /* Tô màu VÀNG cho cả 2 nhãn */
        .card-slot[data-zone="main"]::before {
            content: "x2";
            color: var(--priority-glow-color, #ffc107);
        }

        .card-slot[data-zone="side"]::before {
            content: "x1";
            color: var(--priority-glow-color, #ffc107);
        }

        #player-hand .card.touch-peek {
            transform: translateY(-1.2rem) scale(1.1);
            z-index: 100 !important;
        }

        /* ============================================= */
        /* 4. THIẾT KẾ THẺ BÀI (CARD) MỚI               */
        /* ============================================= */
        .card {
            width: 4.2rem;
            height: 6rem;
            border-radius: var(--border-radius-md);
            background-color: var(--bg-surface-2);
            position: relative;
            transition: transform 0.3s ease, opacity 0.3s ease,
                left 0.4s ease-in-out;
            transform-style: preserve-3d;
            flex-shrink: 0;
            border: 2px solid var(--border-color);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .hand .card {
            position: absolute;
            cursor: grab;
        }

        #player-hand .card {
            bottom: 0;
            /* Ghim chặt lá bài vào cạnh dưới khu vực tay bài */
        }

        #opponent-hand .card {
            top: 0;
            /* Ghim chặt lá bài vào cạnh trên khu vực tay bài */
        }

        .hand .card:active {
            cursor: grabbing;
        }

        /* === FIX: CHỈ CHO PHÉP HOVER BÀI CỦA NGƯỜI CHƠI === */
        #player-hand .card:hover {
            transform: translateY(-1.2rem) scale(1.1);
            z-index: 100 !important;
        }

        .card.dragging {
            opacity: 0.8;
            transform: scale(1.15);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        .card.priority {
            border-color: #ffc107;
            box-shadow: var(--priority-glow);
        }

        .card.special {
            border-color: #03a9f4;
            box-shadow: var(--special-glow);
        }

        .card.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            border-radius: 10px;
            /* Match inner radius */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            overflow: hidden;
            padding: 0.4rem;
        }

        .card-front {
            background: linear-gradient(135deg, var(--bg-surface-2), #3c3c4d);
        }

        .card-back {
            background: linear-gradient(45deg, #4a90e2, #357abd);
            font-size: 2.5rem;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.8);
            transform: rotateY(180deg);
            justify-content: center;
        }

        .card-header,
        .card-footer {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-name {
            font-size: 0.6rem;
            font-weight: 500;
        }

        .card-priority-tag {
            font-size: 0.6rem;
            font-weight: 700;
            color: #ffc107;
        }

        .card-symbol {
            font-size: 2.2rem;
            line-height: 1;
            font-weight: 900;
            margin-top: -0.5rem;
            /* Tinh chỉnh vị trí */
        }

        .card-value {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--accent-primary);
        }

        /* ============================================= */
        /* 5. CÁC PHẦN TỬ ĐỘNG & POPUP                  */
        /* ============================================= */

        /* Lớp phủ cho tất cả modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 200;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            animation: fade-in 0.3s ease;
        }

        @keyframes fade-in {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .modal-content {
            background: var(--bg-surface-1);
            border-radius: var(--border-radius-lg);
            padding: 1.5rem;
            width: 100%;
            max-width: 400px;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            gap: 1rem;
            animation: slide-up-fade 0.4s ease-out;
        }

        @keyframes slide-up-fade {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-content h2 {
            font-size: 1.4rem;
            color: var(--accent-primary);
            text-align: center;
        }

        .modal-content p {
            font-size: 1rem;
            color: var(--text-primary);
            line-height: 1.5;
            text-align: center;
        }

        .modal-options {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .btn {
            background: var(--accent-primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--border-radius-md);
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: var(--accent-primary-hover);
        }

        .btn-secondary {
            background: var(--bg-surface-2);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-surface-1);
        }

        /* Game Log - Tinh tế hơn */
        #game-log {
            position: fixed;
            bottom: 30%;
            left: 50%;
            transform: translateX(-50%);
            width: auto;
            max-width: 90%;
            padding: 0.75rem 1.5rem;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            border-radius: var(--border-radius-lg);
            text-align: center;
            font-size: 1rem;
            font-weight: 500;
            z-index: 150;
            animation: fade-in-out-log 4s forwards ease-in-out;
            pointer-events: none;
        }

        @keyframes fade-in-out-log {

            0%,
            100% {
                opacity: 0;
                transform: translate(-50%, 20px);
            }

            15%,
            85% {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        /* Score change animation */
        .score-change {
            position: fixed;
            font-weight: 900;
            font-size: 2rem;
            animation: score-fade-up 1.5s ease-out forwards;
            z-index: 200;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        @keyframes score-fade-up {
            from {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }

            to {
                opacity: 0;
                transform: translate(-50%, -200%) scale(0.8);
            }
        }

        /* CSS cho modal lịch sử chi tiết */
        .detailed-history-content {
            max-height: 60dvh;
            overflow-y: auto;
            text-align: left;
            padding-right: 0.5rem;
            /* Khoảng trống cho thanh cuộn */
        }

        .detailed-history-list {
            list-style: none;
        }

        .detailed-history-list li {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .detailed-history-list li:last-child {
            border-bottom: none;
        }

        .detailed-history-list strong {
            color: var(--accent-primary);
        }

        .detailed-history-list .win-text {
            color: var(--win-color);
            font-weight: 700;
        }

        .detailed-history-list .loss-text {
            color: var(--loss-color);
            font-weight: 700;
        }

        .detailed-history-list .draw-text {
            color: var(--draw-color);
            font-weight: 700;
        }

        /* Thêm vào cuối phần CSS của bạn */
        #confirm-placement-btn {
            position: absolute;
            bottom: 8rem;
            /* Vị trí phía trên tay bài của người chơi */
            left: 50%;
            transform: translateX(-50%);
            z-index: 150;
            width: 200px;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
            /* Vô hiệu hóa khi ẩn */
        }

        #confirm-placement-btn.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(-10px);
            /* Hiệu ứng trồi lên */
            pointer-events: auto;
            /* Kích hoạt lại khi hiện */
        }

        /* Thêm vào cuối phần CSS của bạn */
        .card-tooltip {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--bg-surface-1);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md);
            z-index: 100;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            animation: fade-in 0.2s ease;
        }

        .card-tooltip button {
            background: none;
            border: none;
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            cursor: pointer;
            font-size: 0.9rem;
            text-align: left;
            transition: background-color 0.2s ease;
            border-bottom: 1px solid var(--border-color);
        }

        .card-tooltip button:last-child {
            border-bottom: none;
        }

        .card-tooltip button:hover {
            background-color: var(--bg-surface-2);
        }

        .card-selection-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            padding: 1rem;
            max-height: 40vh;
            overflow-y: auto;
            background-color: var(--bg-primary);
            border-radius: var(--border-radius-md);
        }

        .card-selection-grid .card {
            position: static;
            /* Ghi đè position: absolute để hiển thị đúng trong grid */
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .card-selection-grid .card:hover {
            transform: scale(1.05) translateY(-5px);
            z-index: 10;
        }

        /* ============================================= */
        /* 6. TỐI ƯU GIAO DIỆN LỊCH SỬ ĐẤU (FIX)       */
        /* ============================================= */
        .detailed-history-content {
            /* Tối ưu cuộn trên mobile */
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
        }

        /* Tùy chỉnh thanh cuộn cho đẹp hơn */
        .detailed-history-content::-webkit-scrollbar {
            width: 6px;
        }

        .detailed-history-content::-webkit-scrollbar-track {
            background: var(--bg-primary);
            border-radius: 3px;
        }

        .detailed-history-content::-webkit-scrollbar-thumb {
            background-color: var(--bg-surface-2);
            border-radius: 3px;
        }

        .detailed-history-content::-webkit-scrollbar-thumb:hover {
            background-color: var(--accent-primary);
        }

        /* Giao diện mới cho mỗi dòng lịch sử */
        .history-item {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .history-item__header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        .history-item__clash {
            display: flex;
            justify-content: space-around;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 0.75rem;
            border-radius: var(--border-radius-md);
        }

        .history-item__vs {
            font-size: 1.5rem;
            font-weight: 900;
            color: var(--text-secondary);
        }

        /* Thiết kế cho thẻ bài mini trong lịch sử */
        .mini-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            width: 80px;
            /* Cố định chiều rộng */
        }

        .mini-card__symbol {
            font-size: 2rem;
        }

        .mini-card__name {
            font-weight: 500;
            font-size: 0.8rem;
        }

        .mini-card__tags {
            display: flex;
            flex-wrap: wrap;
            /* Cho phép tag xuống dòng nếu cần */
            justify-content: center;
            /* Căn giữa các tag */
            gap: 0.25rem;
        }

        .mini-card__tag {
            font-size: 0.65rem;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 4px;
            color: black;
        }

        .tag--attacker {
            background-color: var(--loss-color);
            color: white;
        }

        .tag--defender {
            background-color: var(--accent-primary);
            color: white;
        }

        .tag--priority {
            background-color: #ffc107;
        }

        .tag--special {
            background-color: #03a9f4;
        }

        /* Ghi chú tăng điểm */
        .point-increase-note {
            text-align: center;
            font-size: 0.85rem;
            font-style: italic;
            color: var(--text-secondary);
            background-color: var(--bg-primary);
            padding: 0.4rem;
            border-radius: 8px;
            margin-top: 0.25rem;
        }

        .point-increase-note strong {
            color: var(--win-color);
        }

        .player-req {
            font-size: 0.8rem;
            font-weight: 800;
            padding: 0.2rem 0.5rem;
            border-radius: 8px;
            background: transparent;
            border: 1px dashed #000000;
            color: #ffffff;
            margin-left: 0.4rem;
            white-space: nowrap;
        }

        .card-selection-grid .card.selected {
            border-color: #ffc107;
            box-shadow: var(--priority-glow);
            transform: scale(1.05) translateY(-5px);
        }

        /* ================================================== */
        /* === CSS BỔ SUNG CHO LỊCH SỬ MỚI (06/2024)      === */
        /* ================================================== */

        .mini-card__points {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--accent-primary);
            margin: 0.25rem 0;
        }

        .tag--score-change.win {
            background-color: var(--win-color);
            color: white;
        }

        .tag--score-change.loss {
            background-color: var(--loss-color);
            color: white;
        }

        /* Container cho các tag chung của lượt đấu */
        .history-item__tags {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        /* Tag cho việc tăng điểm cơ bản */
        .tag--points-up {
            background-color: #ffc107;
            color: black;
        }

        .draw-text {
            color: var(--draw-color);
            background-color: var(--bg-surface-2);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 700;
        }

        .win-text {
            color: white;
            background-color: var(--win-color);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 700;
        }

        .loss-text {
            color: white;
            background-color: var(--loss-color);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 700;
        }

        /* Xóa bỏ phần ghi chú cũ để thay bằng tag */
        .point-increase-note {
            display: none;
        }

        /* ================================================== */
        /* === CSS BỔ SUNG CHO CHẾ ĐỘ PVP (MỚI)           === */
        /* ================================================== */

        /* Style cho màn hình chờ chuyển lượt */
        #turn-handoff-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-primary);
            z-index: 9999;
            display: none;
            /* Mặc định ẩn đi */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2rem;
            animation: fade-in 0.3s ease;
        }

        #turn-handoff-overlay h1 {
            font-size: 2rem;
            color: var(--accent-primary);
            margin-bottom: 1rem;
        }

        #turn-handoff-overlay p {
            font-size: 1.1rem;
            margin-bottom: 2rem;
            max-width: 400px;
        }
    </style>
</head>

<body>

    <div id="turn-handoff-overlay">
        <h1 id="handoff-player-name">Lượt của Người Chơi X</h1>

        <p id="handoff-last-action" style="display: none; font-style: italic; color: var(--text-secondary); border: 1px solid var(--border-color); padding: 0.75rem; border-radius: 8px; margin-bottom: 1.5rem; max-width: 400px;"></p>

        <p>Hãy đảm bảo đối thủ không nhìn vào màn hình. <br />Khi bạn đã sẵn sàng, hãy nhấn nút bên dưới.</p>
        <button id="handoff-start-turn-btn" class="btn">Bắt Đầu Lượt</button>
    </div>
    <div id="player-name-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2>Nhập Tên Người Chơi</h2>
            <div id="player-name-inputs" style="display: flex; flex-direction: column; gap: 1rem;">
            </div>
            <div class="modal-options">
                <button id="start-game-btn" class="btn">Bắt Đầu</button>
            </div>
        </div>
    </div>

    <div id="game-mode-modal" class="modal-overlay">
        <div class="modal-content">
            <div id="continue-game-section" style="display: none; margin-bottom: 1rem; text-align: center;">
                <p style="margin-bottom: 0.5rem; color: var(--text-secondary);">Bạn có một màn chơi đang dang dở:</p>
                <button id="continue-btn" class="btn"></button>
                <hr style="border-color: var(--border-color); margin: 1rem 0;">
            </div>
            <h2>Chọn Chế Độ Chơi</h2>
            <p>Bạn muốn chơi theo chế độ nào?</p>
            <div class="modal-options">
                <button id="pvai-btn" class="btn">🤖 Chơi với Máy</button>
                <button id="pvp-btn" class="btn btn-secondary">🧑‍🤝‍🧑 Chơi 2 Người</button>
            </div>
        </div>
    </div>
    <div id="game-container">
        <div id="game-container">
            <!-- KHU VỰC ĐỐI THỦ -->
            <div id="opponent-area" class="player-area">
                <div id="opponent-hand" class="hand"></div>
                <div class="player-info">
                    <div style="display: flex; align-items: center; gap: 0.75rem">
                        <div id="opponent-score" class="player-score">0</div>
                        <div id="opponent-priority-count" class="player-role">0/2</div>
                    </div>
                    <div class="player-details">
                        <div id="opponent-name" class="player-name">Đối Thủ</div>
                    </div>
                </div>
            </div>

            <!-- BẢNG ĐẤU TRUNG TÂM -->
            <div id="board">
                <div id="opponent-side-slot" class="card-slot" data-zone="side"></div>
                <div id="opponent-main-slot" class="card-slot" data-zone="main"></div>

                <div id="action-bar" class="card-slot"></div>

                <div id="player-side-slot" class="card-slot" data-zone="side"></div>
                <div id="player-main-slot" class="card-slot" data-zone="main"></div>
            </div>

            <!-- KHU VỰC NGƯỜI CHƠI -->
            <div id="player-area" class="player-area">
                <div class="player-info">
                    <div class="player-details">
                        <div id="player-name" class="player-name">Bạn</div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.75rem">
                        <div id="player-priority-count" class="player-role">0/2</div>
                        <div id="player-score" class="player-score">0</div>
                    </div>
                </div>
                <div id="player-hand" class="hand"></div>
            </div>

            <!-- HEADER GAME - Đặt ở cuối để có z-index cao hơn theo luồng DOM tự nhiên -->
            <div id="game-header">
                <div id="turn-info">Vòng 1 - Ván 1</div>
                <div id="history-trigger">
                    <div id="history-dots">
                        <!-- Các chấm lịch sử sẽ được JS render ở đây -->
                    </div>
                    <span style="font-size: 0.8rem; color: var(--text-secondary)">Xem</span>
                </div>
            </div>
            <button id="confirm-placement-btn" class="btn" style="display: none">
                Xác Nhận
            </button>
        </div>
        <!-- Container cho các phần tử động như modal, thông báo -->
        <div id="dynamic-elements-container"></div>

        <script>
            /* ================================================================== */
            /* SỬA ĐỔI DOM ELEMENTS ĐỂ TRỎ ĐẾN CÁC ID VÀ CLASS MỚI               */
            /* ================================================================== */
            const DOMElements = {
                player: {
                    hand: document.getElementById("player-hand"),
                    score: document.getElementById("player-score"),
                    role: document.getElementById("player-role"),
                    priorityCount: document.getElementById("player-priority-count"),
                },
                opponent: {
                    hand: document.getElementById("opponent-hand"),
                    score: document.getElementById("opponent-score"),
                    role: document.getElementById("opponent-role"),
                    priorityCount: document.getElementById("opponent-priority-count"),
                },
                board: {
                    // Đổi tên từ battlefield
                    mainLane: document.getElementById("main-lane"),
                    sideLane: document.getElementById("side-lane"),
                    opponentMainSlot: document.getElementById("opponent-main-slot"),
                    opponentSideSlot: document.getElementById("opponent-side-slot"),
                    playerMainSlot: document.getElementById("player-main-slot"), // Đổi tên
                    playerSideSlot: document.getElementById("player-side-slot"), // Đổi tên
                },
                header: {
                    // Thêm mục mới
                    turnInfo: document.getElementById("turn-info"),
                    historyTrigger: document.getElementById("history-trigger"),
                    historyDots: document.getElementById("history-dots"),
                },
                dynamicContainer: document.getElementById("dynamic-elements-container"),
            };

            // Giữ tên biến cũ trong logic game để tránh phải sửa nhiều
            // Chỉ cần ánh xạ lại ở đây
            DOMElements.battlefield = {
                ...DOMElements.board,
                mainZone: DOMElements.board.mainLane, // Ánh xạ tên cũ
                sideZone: DOMElements.board.sideLane, // Ánh xạ tên cũ
                attackerMainSlot: DOMElements.board.playerMainSlot, // Mặc định attacker là player
                attackerSideSlot: DOMElements.board.playerSideSlot, // Mặc định attacker là player
            };

            /* ================================================================== */
            /* PHẦN LOGIC GAME (JAVASCRIPT) - Chỉ sửa những phần liên quan đến    */
            /* render và DOM, giữ nguyên cốt lõi game.                            */
            /* ================================================================== */

            const CARD_TYPES = {
                BUA: "Búa",
                KEO: "Kéo",
                BAO: "Bao"
            };
            const SPECIAL_CARDS = {
                WIN: "Luôn Thắng",
                LOSE: "Luôn Thua"
            };
            const ROLES = {
                ATTACKER: "Tấn Công",
                DEFENDER: "Phòng Thủ"
            };
            // THAY THẾ KHỐI HẰNG SỐ PHASES
            const PHASES = {
                START_TURN: "START_TURN",
                CHECK_DRAW: "CHECK_DRAW",
                ROLE_SELECTION: "ROLE_SELECTION",
                DEFENDER_PLACE_CARDS: "DEFENDER_PLACE_CARDS",
                ATTACKER_CHOOSE_CARD: "ATTACKER_CHOOSE_CARD",
                // --- THÊM 2 GIAI ĐOẠN MỚI, XÓA FINAL_DECISION ---
                DEFENDER_SWAP_CHOICE: "DEFENDER_SWAP_CHOICE",
                ATTACKER_SWAP_CHOICE: "ATTACKER_SWAP_CHOICE",
                RESOLUTION: "RESOLUTION",
                GAME_OVER: "GAME_OVER",
            };
            const ZONES = {
                MAIN: "main",
                SIDE: "side"
            };
            const SYMBOLS = {
                Búa: "✊",
                Kéo: "✌️",
                Bao: "✋",
                "Luôn Thắng": "👑",
                "Luôn Thua": "🏳️",
            };
            let gameState = {};
            let dragState = {
                isDragging: false,
                draggedElement: null,
                cardData: null,
                offsetX: 0,
                offsetY: 0,
            };

            class Game {
                constructor() {
                    this.gameMode = null; // Thêm biến mới để lưu chế độ chơi
                    this.activePlayerId = 0; // Thêm biến mới để biết ai đang chơi ở dưới
                }
                init(mode, name1, name2) {
                    this.gameMode = mode;
                    console.log(`Game started in ${this.gameMode} mode.`);

                    gameState = {
                        round: 0,
                        turn: 0,
                        phase: null,
                        players: [{
                                id: 0,
                                name: name1,
                                score: 0,
                                isAI: false, // Luôn là người
                                hand: [],
                                specialCardsUsed: {
                                    [SPECIAL_CARDS.WIN]: false,
                                    [SPECIAL_CARDS.LOSE]: false,
                                },
                                priorityUsedThisRound: 0,
                            },
                            {
                                id: 1,
                                name: name2,
                                score: 0,
                                // SỬA ĐỔI QUAN TRỌNG:
                                isAI: this.gameMode === 'pvai', // Chỉ là AI nếu chế độ là pvai
                                hand: [],
                                specialCardsUsed: {
                                    [SPECIAL_CARDS.WIN]: false,
                                    [SPECIAL_CARDS.LOSE]: false,
                                },
                                priorityUsedThisRound: 0,
                            },
                        ],
                        cardBasePoints: {
                            [CARD_TYPES.BUA]: 1,
                            [CARD_TYPES.KEO]: 1,
                            [CARD_TYPES.BAO]: 1,
                        },
                        commonDeck: [],
                        battlefield: {
                            main: {
                                defenderCard: null,
                                attackerCard: null
                            },
                            side: {
                                defenderCard: null,
                                attackerCard: null
                            },
                        },
                        currentAttackerId: null,
                        currentDefenderId: null,
                        attackerCardChoice: null,
                        attackerZoneChoice: null,
                        detailedHistory: [],
                        lastTurnWinnerId: null,
                    };

                    [0, 1].forEach((playerId) => {
                        const player = gameState.players[playerId];
                        Object.values(CARD_TYPES).forEach((type) => {
                            player.hand.push(this.createCard(type, true));
                            player.hand.push(this.createCard(type, false));
                        });
                        player.hand.push(this.createCard(SPECIAL_CARDS.WIN, false, true));
                        player.hand.push(this.createCard(SPECIAL_CARDS.LOSE, false, true));
                    });
                    if (this.gameMode === 'pvai') {
                        gameState.players[0].name = "Bạn";
                        gameState.players[1].name = "Đối Thủ";
                    }
                    DOMElements.header.historyTrigger.onclick = () =>
                        this.showDetailedHistoryModal();
                    this.startRound();
                    document.getElementById("confirm-placement-btn").onclick = () =>
                        this.confirmAction();
                    this.saveGameState();
                }
                // THÊM 3 HÀM MỚI NÀY VÀO BẤT KỲ ĐÂU TRONG CLASS GAME

                saveGameState() {
                    if (!gameState || gameState.phase === PHASES.GAME_OVER) return;

                    // Quan trọng: Lưu cả các thuộc tính của class Game
                    const stateToSave = {
                        ...gameState,
                        gameMode: this.gameMode,
                        activePlayerId: this.activePlayerId
                    };
                    localStorage.setItem('savedGame', JSON.stringify(stateToSave));
                    console.log("Game state saved.");
                }

                resumeGame(savedState) {
                    // Tải lại toàn bộ trạng thái
                    gameState = savedState;
                    this.gameMode = savedState.gameMode;
                    this.activePlayerId = savedState.activePlayerId;

                    // Gắn lại các sự kiện
                    DOMElements.header.historyTrigger.onclick = () => this.showDetailedHistoryModal();
                    document.getElementById("confirm-placement-btn").onclick = () => this.confirmAction();

                    console.log("Game resumed from phase:", gameState.phase);

                    // Render lại giao diện và kích hoạt lại logic của phase hiện tại
                    this.render();
                    this.reEngagePhase(gameState.phase);
                }

                reEngagePhase(phase) {
                    // Hàm này kích hoạt lại các lời nhắc hoặc nút bấm của phase hiện tại
                    // mà không chạy lại toàn bộ logic phức tạp của setPhase.
                    const defender = this.getCurrentDefender();
                    const attacker = this.getCurrentAttacker();

                    switch (phase) {
                        case PHASES.ROLE_SELECTION:
                            this.handleRoleSelection();
                            break;
                        case PHASES.DEFENDER_PLACE_CARDS:
                            if (!defender.isAI) {
                                this.log("Phòng Thủ: Kéo 2 lá bài vào 2 khu vực.");
                                if (gameState.battlefield.main.defenderCard && gameState.battlefield.side.defenderCard) {
                                    this.showConfirmButton(true);
                                }
                            } else {
                                this.setPhase(phase); // AI cần chạy lại logic
                            }
                            break;
                        case PHASES.ATTACKER_CHOOSE_CARD:
                            if (!attacker.isAI) {
                                this.log("Tấn Công: Kéo 1 lá bài vào khu vực muốn tấn công.");
                                if (gameState.attackerCardChoice) {
                                    this.showConfirmButton(true);
                                }
                            } else {
                                this.setPhase(phase); // AI cần chạy lại logic
                            }
                            break;
                        case PHASES.DEFENDER_SWAP_CHOICE:
                            this.handleDefenderSwapChoice();
                            break;
                        case PHASES.ATTACKER_SWAP_CHOICE:
                            this.handleAttackerSwapChoice();
                            break;
                        default:
                            // Các phase khác sẽ tự động tiếp diễn hoặc không cần tương tác
                            break;
                    }
                }
                // THAY THẾ TOÀN BỘ HÀM NÀY
                async showTurnHandoff(nextPlayerId) {
                    // Chỉ hiển thị màn hình này ở chế độ PvP và khi lượt chơi thực sự thay đổi
                    if (this.gameMode !== 'pvp' || this.activePlayerId === nextPlayerId) {
                        // Xóa thông tin cũ nếu không hiển thị màn hình chờ
                        if (gameState.lastTurnActionInfo) {
                            gameState.lastTurnActionInfo = null;
                        }
                        return;
                    }

                    const handoffScreen = document.getElementById('turn-handoff-overlay');
                    const playerNameEl = document.getElementById('handoff-player-name');
                    const startBtn = document.getElementById('handoff-start-turn-btn');

                    const lastActionEl = document.getElementById('handoff-last-action');

                    this.activePlayerId = nextPlayerId;
                    const nextPlayer = this.getPlayer(nextPlayerId);
                    playerNameEl.textContent = `Lượt của ${nextPlayer.name}`;


                    if (gameState.lastTurnActionInfo) {
                        lastActionEl.textContent = `Ghi chú: ${gameState.lastTurnActionInfo}`;
                        lastActionEl.style.display = 'block';
                    } else {
                        lastActionEl.style.display = 'none';
                    }

                    gameState.lastTurnActionInfo = null;

                    return new Promise(resolve => {
                        const onStartClick = () => {
                            handoffScreen.style.display = 'none';
                            this.render();
                            startBtn.removeEventListener('click', onStartClick);
                            resolve();
                        };
                        handoffScreen.style.display = 'flex';
                        startBtn.addEventListener('click', onStartClick);
                    });
                }

                showPrioritySelectionModal(player, drawnCards, neededCount) {
                    const overlay = document.createElement("div");
                    overlay.className = "modal-overlay";

                    let selectedCards = [];

                    let cardsHTML = '<div class="card-selection-grid">';
                    drawnCards.forEach((card, index) => {
                        const cardEl = this.createCardElement(card);
                        // Gắn dữ liệu index vào element để xử lý click
                        cardEl.dataset.cardIndex = index;
                        cardsHTML += cardEl.outerHTML;
                    });
                    cardsHTML += "</div>";

                    const modal = document.createElement("div");
                    modal.className = "modal-content";
                    modal.innerHTML = `
                <h2>Chỉ Định Thẻ Ưu Tiên</h2>
                <p>Bạn cần chọn <strong>${neededCount}</strong> lá bài để trở thành Thẻ Ưu Tiên.</p>
                ${cardsHTML}
                <div class="modal-options">
                    <button id="confirm-priority-btn" class="btn" disabled>Xác Nhận</button>
                </div>
            `;

                    overlay.appendChild(modal);
                    DOMElements.dynamicContainer.appendChild(overlay);

                    const confirmBtn = modal.querySelector("#confirm-priority-btn");
                    const cardElements = modal.querySelectorAll(".card");

                    cardElements.forEach((cardEl) => {
                        cardEl.onclick = () => {
                            const cardIndex = parseInt(cardEl.dataset.cardIndex);
                            const cardData = drawnCards[cardIndex];

                            const selectedIndex = selectedCards.findIndex(
                                (c) => c.id === cardData.id
                            );

                            if (selectedIndex > -1) {
                                // Nếu đã chọn, bỏ chọn
                                selectedCards.splice(selectedIndex, 1);
                                cardEl.classList.remove("selected");
                            } else {
                                // Nếu chưa chọn, kiểm tra nếu có thể chọn thêm
                                if (selectedCards.length < neededCount) {
                                    selectedCards.push(cardData);
                                    cardEl.classList.add("selected");
                                }
                            }

                            // Cập nhật trạng thái nút xác nhận
                            if (selectedCards.length === neededCount) {
                                confirmBtn.disabled = false;
                            } else {
                                confirmBtn.disabled = true;
                            }
                        };
                    });

                    confirmBtn.onclick = () => {
                        // Đánh dấu các lá bài đã chọn là ưu tiên
                        selectedCards.forEach((selectedCard) => {
                            const cardInDrawn = drawnCards.find(
                                (c) => c.id === selectedCard.id
                            );
                            if (cardInDrawn) {
                                cardInDrawn.isPriority = true;
                            }
                        });

                        // Thêm tất cả các lá bài đã bốc vào tay người chơi
                        player.hand.push(...drawnCards);

                        this.log(`Bạn đã chỉ định ${neededCount} Thẻ Ưu Tiên mới.`);
                        overlay.remove(); // Đóng modal

                        // Gọi hàm xử lý tiếp theo
                        this.handlePostDraw(player);
                    };
                }
                render(options = {
                    updateBattlefield: true
                }) {
                    const player = this.getPlayer(this.activePlayerId);
                    const opponent = this.getPlayer(this.activePlayerId === 0 ? 1 : 0);

                    const playerInfoEl = document.getElementById("player-area").querySelector(".player-info");
                    const opponentInfoEl = document.getElementById("opponent-area").querySelector(".player-info");

                    // Cập nhật tên
                    document.getElementById("player-name").textContent = player.name;
                    document.getElementById("opponent-name").textContent = opponent.name;

                    // Cập nhật điểm và các thông số khác
                    DOMElements.player.score.textContent = player.score;
                    DOMElements.opponent.score.textContent = opponent.score;

                    const playerPriorityEl = DOMElements.player.priorityCount;
                    const opponentPriorityEl = DOMElements.opponent.priorityCount;

                    // Luôn hiển thị bộ đếm của người chơi đang active (ở dưới)
                    playerPriorityEl.textContent = `${player.priorityUsedThisRound || 0}/2`;
                    playerPriorityEl.style.visibility = 'visible';

                    // Luôn ẩn bộ đếm của đối phương (ở trên)
                    // Dùng visibility để ẩn nhưng vẫn giữ nguyên bố cục
                    opponentPriorityEl.textContent = `${opponent.priorityUsedThisRound || 0}/2`; // Vẫn cập nhật số liệu ẩn
                    opponentPriorityEl.style.visibility = 'hidden';

                    // Logic hiển thị vai trò (Tấn Công/Phòng Thủ)
                    const setupRoleClass = (infoEl, p) => {
                        infoEl.classList.remove("role-attacker", "role-defender");
                        if (p.id === gameState.currentAttackerId) {
                            infoEl.classList.add("role-attacker");
                        } else if (p.id === gameState.currentDefenderId) {
                            infoEl.classList.add("role-defender");
                        }
                    };
                    setupRoleClass(playerInfoEl, player);
                    setupRoleClass(opponentInfoEl, opponent);

                    const ensureReqBadge = (who) => {
                        const wrap =
                            who === 0 ?
                            document.getElementById("player-priority-count").parentElement :
                            document.getElementById("opponent-priority-count")
                            .parentElement;
                        let req = wrap.querySelector(".player-req");
                        const isDefender = who === gameState.currentDefenderId;
                        const showPhases = [PHASES.CHECK_DRAW, PHASES.DEFENDER_PLACE_CARDS];
                        const shouldShow =
                            isDefender && showPhases.includes(gameState.phase);
                        if (!req) {
                            req = document.createElement("span");
                            req.className = "player-req";
                            req.textContent = "Cần ≥1 ƯT";
                            wrap.appendChild(req);
                        }
                        req.style.display = shouldShow ? "inline-block" : "none";
                    };
                    const updateReqBadge = (p, priorityCountElement) => {
                        const wrapper = priorityCountElement.parentElement;
                        let reqBadge = wrapper.querySelector(".player-req");

                        // Điều kiện để hiển thị: người chơi này phải là Phòng Thủ VÀ đang ở đúng giai đoạn
                        const isDefender = p.id === gameState.currentDefenderId;
                        const correctPhase = [PHASES.CHECK_DRAW, PHASES.DEFENDER_PLACE_CARDS].includes(gameState.phase);
                        const shouldShow = isDefender && correctPhase;

                        if (!reqBadge) {
                            reqBadge = document.createElement("span");
                            reqBadge.className = "player-req";
                            reqBadge.textContent = "Cần ≥1 ƯT";
                            // Thêm vào trước bộ đếm để giao diện đẹp hơn
                            wrapper.insertBefore(reqBadge, priorityCountElement);
                        }

                        reqBadge.style.display = shouldShow ? "inline-block" : "none";
                    };

                    // Áp dụng logic cho cả người chơi đang active (ở dưới) và đối thủ (ở trên)
                    updateReqBadge(player, DOMElements.player.priorityCount);
                    updateReqBadge(opponent, DOMElements.opponent.priorityCount);

                    // Render tay bài
                    this.renderHandLayout(player, DOMElements.player.hand);
                    this.renderHandLayout(opponent, DOMElements.opponent.hand, true); // Tay đối thủ luôn úp

                    if (options.updateBattlefield) {
                        this.renderBattlefield();
                    }
                    this.updateGameInfo();
                    this.renderHistoryBar();
                }
                // Dán hàm MỚI này vào trong class Game
                updateActionBar(content = "") {
                    const actionBar = document.getElementById("action-bar");
                    if (!actionBar) return;

                    // Xóa nội dung cũ và listener (nếu có)
                    actionBar.innerHTML = "";

                    if (typeof content === 'string' && content) {
                        // Nếu là text, chỉ cần hiển thị text
                        actionBar.innerHTML = `<p class="action-bar__text">${content}</p>`;
                    } else if (typeof content === 'object' && content) {
                        // Nếu là object (dành cho nút)
                        const fragment = document.createDocumentFragment();
                        content.options.forEach((opt, index) => {
                            const btn = document.createElement("button");
                            btn.className = index === 0 ? "btn" : "btn btn-secondary";
                            btn.textContent = opt.text;
                            btn.onclick = () => {
                                this.updateActionBar(); // Xóa nút sau khi bấm
                                content.onSelect(opt.value);
                            };
                            fragment.appendChild(btn);
                        });
                        actionBar.appendChild(fragment);
                    }
                }
                renderHandLayout(player, container, isOpponent = false) {
                    container.innerHTML = "";
                    const cards = player.hand;

                    // --- BẮT ĐẦU PHẦN THÊM MỚI ---
                    // 1. Tạo một hàm nhỏ để xác định "độ ưu tiên" sắp xếp của thẻ
                    const getCardSortWeight = (card) => {
                        if (card.isPriority) return 1; // Ưu tiên xếp đầu tiên
                        if (card.isSpecial) return 3; // Đặc biệt xếp cuối cùng
                        return 2; // Thường (không ưu tiên, không đặc biệt) xếp ở giữa
                    };

                    // 2. Sắp xếp mảng thẻ dựa trên trọng số đã định nghĩa
                    const sortedCards = [...cards].sort(
                        (a, b) => getCardSortWeight(a) - getCardSortWeight(b)
                    );
                    // --- KẾT THÚC PHẦN THÊM MỚI ---

                    // SỬA LẠI CÁC DÒNG DƯỚI ĐÂY ĐỂ DÙNG MẢNG ĐÃ SẮP XẾP
                    const cardCount = sortedCards.length; // Dùng sortedCards
                    if (cardCount === 0) return;

                    const rootFontSize = parseFloat(
                        getComputedStyle(document.documentElement).fontSize
                    );
                    const cardWidthRem = 4.2;
                    const overlapRem = 2.8;
                    const cardWidthPx = cardWidthRem * rootFontSize;
                    const overlapPx = overlapRem * rootFontSize;
                    const totalWidth =
                        cardWidthPx +
                        (cardCount > 1 ? (cardCount - 1) * (cardWidthPx - overlapPx) : 0);
                    const startX = (container.offsetWidth - totalWidth) / 2;

                    sortedCards.forEach((card, i) => {
                        // Dùng sortedCards
                        const cardEl = this.createCardElement(card, isOpponent);
                        cardEl.dataset.cardId = card.id;
                        cardEl.style.left = `${startX + i * (cardWidthPx - overlapPx)}px`;
                        cardEl.style.zIndex = i;
                        if (!isOpponent) {
                            let isDraggable =
                                (gameState.phase === PHASES.DEFENDER_PLACE_CARDS &&
                                    player.id === gameState.currentDefenderId) ||
                                (gameState.phase === PHASES.ATTACKER_CHOOSE_CARD &&
                                    player.id === gameState.currentAttackerId);
                            let touchTimeout;

                            // Sự kiện khi bắt đầu chạm vào lá bài
                            const handleTouchStart = (e) => {
                                // Đặt một bộ đếm thời gian ngắn. Nếu người dùng giữ tay đủ lâu, lá bài sẽ phóng to.
                                touchTimeout = setTimeout(() => {
                                    // Loại bỏ hiệu ứng này trên các lá bài khác
                                    document.querySelectorAll('#player-hand .card.touch-peek').forEach(c => c.classList.remove('touch-peek'));
                                    // Thêm hiệu ứng cho lá bài đang chạm
                                    cardEl.classList.add('touch-peek');
                                }, 150); // 150ms là một khoảng thời gian hợp lý
                            };

                            // Sự kiện khi nhấc ngón tay ra
                            const handleTouchEnd = (e) => {
                                // Xóa bộ đếm thời gian để ngăn việc phóng to nếu nhấc tay ra quá nhanh
                                clearTimeout(touchTimeout);
                                // Loại bỏ hiệu ứng phóng to
                                setTimeout(() => {
                                    cardEl.classList.remove('touch-peek');
                                }, 200); // Giữ hiệu ứng thêm 1 chút cho mượt
                            };

                            // --- FIX: LOGIC VÔ HIỆU HÓA THẺ (CHO CẢ 2 VAI TRÒ) ---
                            const bf = gameState.battlefield;
                            // Áp dụng giới hạn 2 thẻ ưu tiên cho cả Tấn Công và Phòng Thủ
                            if (card.isPriority && (player.priorityUsedThisRound || 0) >= 2) {
                                isDraggable = false;
                            }

                            // Logic riêng cho người Phòng Thủ: Nếu đã đặt 1 thẻ thường, thẻ tiếp theo phải là ưu tiên
                            if (
                                isDraggable &&
                                gameState.phase === PHASES.DEFENDER_PLACE_CARDS
                            ) {
                                const mainCard = bf.main.defenderCard;
                                const sideCard = bf.side.defenderCard;
                                const oneNormalCardPlaced =
                                    (mainCard && !sideCard && !mainCard.isPriority) ||
                                    (sideCard && !mainCard && !sideCard.isPriority);

                                if (oneNormalCardPlaced && !card.isPriority) {
                                    isDraggable = false;
                                }
                            }
                            // --- KẾT THÚC FIX ---

                            if (isDraggable) {
                                // Gắn sự kiện kéo-thả
                                cardEl.addEventListener("mousedown", (e) => this.dragStart(e, card, cardEl));
                                cardEl.addEventListener("touchstart", (e) => {
                                    // Khi kéo-thả trên di động, xóa bộ đếm xem bài để tránh xung đột
                                    clearTimeout(touchTimeout);
                                    this.dragStart(e, card, cardEl)
                                }, {
                                    passive: false
                                });
                                cardEl.addEventListener("touchstart", handleTouchStart, {
                                    passive: true
                                });
                                cardEl.addEventListener("touchend", handleTouchEnd);

                            } else {
                                cardEl.classList.add("disabled");
                            }
                        }
                        container.appendChild(cardEl);
                    });
                }
                showConfirmButton(visible) {
                    if (visible) {
                        this.updateActionBar({
                            options: [{
                                text: "Xác Nhận",
                                value: 'confirm'
                            }],
                            onSelect: () => this.confirmAction()
                        });
                    } else {
                        // Xóa nút xác nhận và để lại thông báo gần nhất nếu có
                        const currentText = document.querySelector('.action-bar__text');
                        if (!currentText) {
                            this.updateActionBar(); // Chỉ xóa nếu không có text
                        }
                    }
                }

                // Hàm xử lý khi nhấn nút xác nhận
                confirmAction() {
                    this.showConfirmButton(false);
                    if (gameState.phase === PHASES.DEFENDER_PLACE_CARDS) {
                        this.log("Bạn đã xác nhận vị trí các lá bài.");
                        this.removeCardInteractions(); // Vô hiệu hóa tương tác với thẻ thủ
                        this.setPhase(PHASES.ATTACKER_CHOOSE_CARD);
                    } else if (gameState.phase === PHASES.ATTACKER_CHOOSE_CARD) {
                        this.log("Bạn đã xác nhận tấn công.");
                        this.setPhase(PHASES.DEFENDER_SWAP_CHOICE);
                    }
                }
                // HÀM TẠO THẺ BÀI ĐÃ ĐƯỢC CẬP NHẬT CHO GIAO DIỆN MỚI
                createCardElement(
                    card,
                    hide = false,
                    zoneName = null,
                    isDefenderCard = false
                ) {
                    const cardEl = document.createElement("div");
                    cardEl.className = "card";
                    if (hide) cardEl.classList.add("flipped");
                    if (card.isSpecial && !hide) cardEl.classList.add("special");
                    if (card.isPriority && !hide) cardEl.classList.add("priority");

                    const priorityTag = card.isPriority ?
                        '<span class="card-priority-tag">ƯT</span>' :
                        "";

                    let displayPoints = "";
                    if (card.isBasic || card.isSpecial) {
                        let basePoints = card.isSpecial ?
                            5 :
                            gameState.cardBasePoints[card.type];
                        if (zoneName) {
                            // --- SỬA LOGIC TÍNH ĐIỂM TẠI ĐÂY ---
                            let finalMultiplier;
                            if (card.isPriority) {
                                // BỎ điều kiện && isDefenderCard
                                // Bất kỳ thẻ Ưu Tiên nào cũng được nhân điểm cao hơn
                                finalMultiplier = zoneName === ZONES.MAIN ? 3 : 2;
                            } else {
                                // Thẻ thường thì nhân điểm bình thường
                                finalMultiplier = zoneName === ZONES.MAIN ? 2 : 1;
                            }
                            displayPoints = basePoints * finalMultiplier;
                            // --- KẾT THÚC PHẦN SỬA ---
                        } else {
                            displayPoints = basePoints;
                        }
                    }
                    const pointHTML = `<span class="card-value">${displayPoints}</span>`;

                    cardEl.innerHTML = `
            <div class="card-face card-front">
                <div class="card-header">
                  <span class="card-name">${card.type}</span>
                  ${priorityTag}
                </div>
                <span class="card-symbol">${SYMBOLS[card.type] || "?"}</span>
                <div class="card-footer">
                  ${pointHTML}
                </div>
            </div>
            <div class="card-face card-back">★</div>
          `;
                    return cardEl;
                }
                showCardTooltip(card, zoneName, cardEl) {
                    // Xóa tooltip cũ nếu có
                    this.removeTooltip();

                    const tooltip = document.createElement("div");
                    tooltip.id = "card-tooltip";
                    tooltip.className = "card-tooltip";

                    tooltip.innerHTML = `
        <button data-action="return">↩️ Trả về tay</button>
        <button data-action="swap">🔄️ Chuyển vị trí</button>
    `;

                    // Gắn tooltip vào chính thẻ bài
                    cardEl.style.position = "relative"; // Cần thiết để định vị tooltip
                    cardEl.appendChild(tooltip);

                    tooltip.querySelector('[data-action="return"]').onclick = (e) => {
                        e.stopPropagation();
                        this.returnCardToHand(card, zoneName);
                    };

                    tooltip.querySelector('[data-action="swap"]').onclick = (e) => {
                        e.stopPropagation();
                        this.swapDefenderCards();
                    };

                    // Thêm sự kiện để xóa tooltip khi click ra ngoài
                    setTimeout(() => {
                        document.addEventListener("click", this.removeTooltip, {
                            once: true,
                        });
                    }, 0);
                }

                removeTooltip() {
                    const existingTooltip = document.getElementById("card-tooltip");
                    if (existingTooltip) {
                        existingTooltip.remove();
                    }
                    document.removeEventListener("click", this.removeTooltip);
                }

                returnCardToHand(card, zoneName) {
                    const player = this.getCurrentDefender();

                    // Xóa thẻ khỏi bàn đấu
                    gameState.battlefield[zoneName].defenderCard = null;

                    // Trả thẻ về tay
                    player.hand.push(card);

                    // Cập nhật lại bộ đếm ưu tiên
                    let priorityOnBoard = 0;
                    if (gameState.battlefield.main.defenderCard?.isPriority)
                        priorityOnBoard++;
                    if (gameState.battlefield.side.defenderCard?.isPriority)
                        priorityOnBoard++;
                    player.priorityCardsUsedThisRound = priorityOnBoard;

                    // Ẩn nút xác nhận vì chưa đặt đủ bài
                    this.showConfirmButton(false);

                    this.removeTooltip();
                    this.render();
                }

                swapDefenderCards() {
                    const bf = gameState.battlefield;
                    // Hoán đổi 2 lá bài
                    [bf.main.defenderCard, bf.side.defenderCard] = [
                        bf.side.defenderCard,
                        bf.main.defenderCard,
                    ];

                    this.removeTooltip();
                    this.render();
                }

                // Hàm tiện ích để xóa hết các event listener trên thẻ
                removeCardInteractions() {
                    const playerSlots = [
                        DOMElements.board.playerMainSlot,
                        DOMElements.board.playerSideSlot,
                    ];
                    playerSlots.forEach((slot) => {
                        const cardEl = slot.querySelector(".card");
                        if (cardEl) {
                            // Thay thế node bằng bản clone của nó để xóa hết listener
                            cardEl.parentNode.replaceChild(cardEl.cloneNode(true), cardEl);
                        }
                    });
                }
                // THAY THẾ TOÀN BỘ hàm renderBattlefield() bằng phiên bản mới này
                renderBattlefield(flip = false) {
                    const bf = gameState.battlefield;

                    // Xóa sạch các slot trước khi render
                    const clearSlot = (slot) => (slot.innerHTML = "");
                    [
                        DOMElements.board.opponentMainSlot,
                        DOMElements.board.opponentSideSlot,
                        DOMElements.board.playerMainSlot,
                        DOMElements.board.playerSideSlot,
                    ].forEach(clearSlot);

                    // Hàm phụ để đặt thẻ, logic không đổi
                    const placeCard = (card, slot, zoneName, isHidden, isDefender) => {
                        if (!card) return;

                        const cardEl = this.createCardElement(
                            card,
                            isHidden,
                            zoneName,
                            isDefender
                        );

                        // Logic thêm tooltip cho người phòng thủ không phải AI
                        const currentDefender = this.getCurrentDefender();
                        if (
                            currentDefender &&
                            !currentDefender.isAI &&
                            currentDefender.id === this.activePlayerId &&
                            isDefender &&
                            gameState.phase === PHASES.DEFENDER_PLACE_CARDS
                        ) {
                            cardEl.style.cursor = "pointer";
                            cardEl.onclick = (e) => {
                                e.stopPropagation();
                                this.showCardTooltip(card, zoneName, cardEl);
                            };
                        }
                        slot.appendChild(cardEl);
                    };

                    const defender = this.getCurrentDefender();
                    const attacker = this.getCurrentAttacker();

                    // Nếu chưa có vai trò thì không render gì cả
                    if (!defender || !attacker) return;

                    // ======================================================================
                    // === THAY ĐỔI CỐT LÕI: LOGIC HIỂN THỊ DỰA TRÊN activePlayerId ===
                    // ======================================================================

                    // 1. Xác định vị trí đặt bài dựa trên người chơi active
                    const defenderIsActive = defender.id === this.activePlayerId;
                    const attackerIsActive = attacker.id === this.activePlayerId;

                    const defenderMainSlot = defenderIsActive ? DOMElements.board.playerMainSlot : DOMElements.board.opponentMainSlot;
                    const defenderSideSlot = defenderIsActive ? DOMElements.board.playerSideSlot : DOMElements.board.opponentSideSlot;
                    const attackerMainSlot = attackerIsActive ? DOMElements.board.playerMainSlot : DOMElements.board.opponentMainSlot;
                    const attackerSideSlot = attackerIsActive ? DOMElements.board.playerSideSlot : DOMElements.board.opponentSideSlot;

                    // 2. Xác định khi nào cần ẩn bài phòng thủ
                    // Bài phòng thủ sẽ bị ẩn NẾU:
                    //   - Chưa đến giai đoạn lật bài (flip === false)
                    //   - VÀ người đang chơi active KHÔNG PHẢI là người phòng thủ.
                    const shouldHideDefenderCards = !flip && !defenderIsActive;

                    // ======================================================================
                    // === KẾT THÚC THAY ĐỔI CỐT LÕI                                      ===
                    // ======================================================================

                    // Render thẻ của người Phòng thủ
                    placeCard(
                        bf.main.defenderCard,
                        defenderMainSlot,
                        ZONES.MAIN,
                        shouldHideDefenderCards, // Sử dụng biến logic mới
                        true // isDefender
                    );
                    placeCard(
                        bf.side.defenderCard,
                        defenderSideSlot,
                        ZONES.SIDE,
                        shouldHideDefenderCards, // Sử dụng biến logic mới
                        true // isDefender
                    );

                    // Render thẻ của người Tấn công (luôn hiện)
                    placeCard(
                        bf.main.attackerCard,
                        attackerMainSlot,
                        ZONES.MAIN,
                        false, // Thẻ tấn công không bao giờ ẩn
                        false // isDefender
                    );
                    placeCard(
                        bf.side.attackerCard,
                        attackerSideSlot,
                        ZONES.SIDE,
                        false, // Thẻ tấn công không bao giờ ẩn
                        false // isDefender
                    );
                }
                showConfirmationBar({
                    text,
                    options,
                    onSelect,
                    isRoleSelection = false
                }) {
                    this.log(text); // Hiển thị text trước
                    this.sleep(500).then(() => { // Đợi 1 chút rồi mới hiện nút
                        this.updateActionBar({
                            options,
                            onSelect: (value) => {
                                let finalValue = value;
                                if (!isRoleSelection && typeof value !== 'boolean') {
                                    finalValue = value === "true";
                                }
                                onSelect(finalValue);
                            }
                        });
                    });
                }
                showInfoModal({
                    title,
                    content,
                    modalClass = ""
                }) {
                    const overlay = document.createElement("div");
                    overlay.className = "modal-overlay";

                    const modal = document.createElement("div");
                    modal.className = `modal-content ${modalClass}`;

                    modal.innerHTML = `
                <h2>${title}</h2>
                <div class="detailed-history-content">${content}</div>
                <div class="modal-options">
                    <button class="btn">Đóng</button>
                </div>
            `;
                    overlay.appendChild(modal);
                    DOMElements.dynamicContainer.appendChild(overlay);
                    modal.querySelector(".btn").onclick = () => overlay.remove();
                }

                // HÀM RENDER THANH LỊCH SỬ ĐÃ ĐƯỢC CẬP NHẬT
                renderHistoryBar() {
                    DOMElements.header.historyDots.innerHTML = "";
                    // Chỉ hiển thị 10 lượt gần nhất cho gọn
                    const recentHistory = gameState.detailedHistory.slice(-10);
                    recentHistory.forEach((turn) => {
                        const item = document.createElement("div");
                        item.className = "history-dot";
                        if (turn.winnerId === null) item.classList.add("draw");
                        else if (turn.winnerId === 0) item.classList.add("win");
                        else item.classList.add("loss");
                        DOMElements.header.historyDots.appendChild(item);
                    });
                }

                // CẬP NHẬT LẠI HÀM DRAG-DROP ĐỂ DÙNG `data-zone`
                dragEnd(e) {
                    if (!dragState.isDragging) return;
                    document.removeEventListener("mousemove", game.dragging);
                    document.removeEventListener("touchmove", game.dragging);
                    document.removeEventListener("mouseup", game.dragEnd);
                    document.removeEventListener("touchend", game.dragEnd);

                    let droppedOnZone = null;
                    const pointer = e.changedTouches ? e.changedTouches[0] : e;

                    // SỬA Ở ĐÂY: Lặp qua các ô người chơi có thể thả vào
                    const dropTargets = [
                        DOMElements.board.playerMainSlot,
                        DOMElements.board.playerSideSlot,
                        // Thêm 2 ô của đối thủ để có hiệu ứng hover, nhưng việc thả vào sẽ do logic game quyết định
                        DOMElements.board.opponentMainSlot,
                        DOMElements.board.opponentSideSlot,
                    ];

                    dropTargets.forEach((slotEl) => {
                        slotEl.classList.remove("drop-hover");
                        const slotRect = slotEl.getBoundingClientRect();
                        if (
                            pointer.clientX > slotRect.left &&
                            pointer.clientX < slotRect.right &&
                            pointer.clientY > slotRect.top &&
                            pointer.clientY < slotRect.bottom
                        ) {
                            // Chỉ tính là thả hợp lệ vào ô của người chơi
                            if (
                                slotEl === DOMElements.board.playerMainSlot ||
                                slotEl === DOMElements.board.playerSideSlot
                            ) {
                                droppedOnZone = slotEl.dataset.zone;
                            }
                        }
                    });

                    if (droppedOnZone) {
                        game.handleDrop(dragState.cardData, droppedOnZone);
                    } else {
                        // Nếu không thả vào ô hợp lệ, phục hồi độ mờ cho lá bài gốc
                        const originalCard = document.querySelector(`#player-hand .card[data-card-id='${dragState.cardData.id}']`); // Giả sử bạn có thể thêm data-card-id
                        // Hoặc cách đơn giản hơn là render lại toàn bộ
                        game.render();
                    }
                    dragState.draggedElement.remove();
                    dragState.isDragging = false;
                    dragState.draggedElement = null;
                    dragState.cardData = null;
                    game.render();
                }
                dragging(e) {
                    if (!dragState.isDragging) return;
                    e.preventDefault();
                    const pointer = e.touches ? e.touches[0] : e;
                    const x = pointer.clientX - dragState.offsetX;
                    const y = pointer.clientY - dragState.offsetY;
                    dragState.draggedElement.style.left = `${x}px`;
                    dragState.draggedElement.style.top = `${y}px`;

                    // SỬA Ở ĐÂY: Lặp qua các ô người chơi có thể thả vào để hiện hiệu ứng
                    const dropTargets = [
                        DOMElements.board.playerMainSlot,
                        DOMElements.board.playerSideSlot,
                    ];

                    dropTargets.forEach((slotEl) => {
                        const zoneRect = slotEl.getBoundingClientRect();
                        if (
                            pointer.clientX > zoneRect.left &&
                            pointer.clientX < zoneRect.right &&
                            pointer.clientY > zoneRect.top &&
                            pointer.clientY < zoneRect.bottom
                        ) {
                            slotEl.classList.add("drop-hover");
                        } else {
                            slotEl.classList.remove("drop-hover");
                        }
                    });
                }
                // HÀM CẬP NHẬT THÔNG TIN TRẬN ĐẤU
                updateGameInfo() {
                    DOMElements.header.turnInfo.textContent = `Vòng ${gameState.round} - Ván ${gameState.turn}`;
                }

                // ========================================================= //
                // CÁC HÀM LOGIC KHÁC GIỮ NGUYÊN HOẶC CHỈ THAY ĐỔI NHỎ
                // Phần còn lại của script có thể copy từ file cũ của bạn
                // hoặc dùng bản đầy đủ đã được kiểm tra dưới đây.
                // ========================================================= //

                dragStart(e, card, cardEl) {
                    if (dragState.isDragging) return;
                    e.preventDefault();

                    const pointer = e.touches ? e.touches[0] : e;
                    const rect = cardEl.getBoundingClientRect();

                    dragState.isDragging = true;
                    dragState.draggedElement = cardEl.cloneNode(true);
                    document.body.appendChild(dragState.draggedElement);
                    dragState.cardData = card;

                    // --- PHẦN SỬA LỖI QUAN TRỌNG ---
                    // Tính toán khoảng cách từ điểm chạm đến góc trên-trái của lá bài
                    dragState.offsetX = pointer.clientX - rect.left;
                    dragState.offsetY = pointer.clientY - rect.top;
                    // --- KẾT THÚC PHẦN SỬA ---

                    dragState.draggedElement.style.position = "fixed";
                    dragState.draggedElement.style.zIndex = 1000;
                    dragState.draggedElement.classList.add("dragging");
                    // Giảm độ mờ của lá bài gốc để rõ ràng hơn
                    cardEl.style.opacity = "0.3";

                    // Gọi hàm dragging ngay lập tức để lá bài "nhảy" đến đúng vị trí dưới con trỏ
                    this.dragging(e);

                    document.addEventListener("mousemove", this.dragging);
                    document.addEventListener("touchmove", this.dragging, {
                        passive: false,
                    });
                    document.addEventListener("mouseup", this.dragEnd);
                    document.addEventListener("touchend", this.dragEnd);
                }
                handleDrop(card, zoneName) {
                    if (gameState.phase === PHASES.DEFENDER_PLACE_CARDS) {
                        this.handleDefenderPlacementDrop(card, zoneName);
                    } else if (gameState.phase === PHASES.ATTACKER_CHOOSE_CARD) {
                        this.handleAttackerDrop(card, zoneName);
                    }
                }
                createCard(type, isPriority = false, isSpecial = false) {
                    return {
                        id: `card_${Date.now()}_${Math.random()}`,
                        type: type,
                        isPriority: isPriority,
                        isSpecial: isSpecial,
                        isBasic: !isSpecial,
                    };
                }
                getPlayer(id) {
                    return gameState.players.find((p) => p.id === id);
                }
                getCurrentAttacker() {
                    return this.getPlayer(gameState.currentAttackerId);
                }
                getCurrentDefender() {
                    return this.getPlayer(gameState.currentDefenderId);
                }
                sleep(ms) {
                    return new Promise((resolve) => setTimeout(resolve, ms));
                }
                log(message) {
                    console.log(message);
                    this.updateActionBar(message); // Dùng action bar mới
                }

                handleDefenderPlacementDrop(card, zoneName) {
                    const bf = gameState.battlefield;
                    const player = this.getCurrentDefender();

                    // Không cho đặt vào ô đã có thẻ
                    if (bf[zoneName].defenderCard) return;

                    bf[zoneName].defenderCard = card;
                    player.hand = player.hand.filter((c) => c.id !== card.id);
                    if (card.isPriority) {
                        player.priorityUsedThisRound =
                            (player.priorityUsedThisRound || 0) + 1;
                    }

                    // Kiểm tra xem cả hai thẻ đã được đặt chưa
                    if (bf.main.defenderCard && bf.side.defenderCard) {
                        const mainCard = bf.main.defenderCard;
                        const sideCard = bf.side.defenderCard;

                        // Kiểm tra luật: Phải có ít nhất 1 thẻ ưu tiên
                        if (!mainCard.isPriority && !sideCard.isPriority) {
                            this.log("Lỗi: Phải đặt ít nhất 1 Thẻ Ưu Tiên!");
                            player.hand.push(mainCard, sideCard); // Trả bài về tay
                            bf.main.defenderCard = null;
                            bf.side.defenderCard = null;
                            player.priorityCardsUsedThisRound = 0; // Reset bộ đếm
                            this.render();
                            return;
                        }

                        // Kiểm tra luật: Không được đặt 2 thẻ đặc biệt
                        if (mainCard.isSpecial && sideCard.isSpecial) {
                            this.log("Lỗi: Không được đặt 2 Thẻ Đặc Biệt!");
                            player.hand.push(mainCard, sideCard); // Trả bài về tay
                            bf.main.defenderCard = null;
                            bf.side.defenderCard = null;
                            player.priorityCardsUsedThisRound = 0; // Reset bộ đếm
                            this.render();
                            return;
                        }

                        // Nếu mọi thứ hợp lệ, thay vì chuyển phase, chúng ta sẽ hiển thị nút xác nhận
                        if (!player.isAI) {
                            this.showConfirmButton(true);
                        } else {
                            // AI tự động xác nhận sau một khoảng trễ
                            setTimeout(
                                () => this.setPhase(PHASES.ATTACKER_CHOOSE_CARD),
                                1000
                            );
                        }
                    }

                    // Render lại game sau mỗi lần đặt thẻ
                    this.render();
                    // --- KẾT THÚC SỬA ĐỔI ---
                }
                handleAttackerDrop(card, zoneName) {
                    const player = this.getCurrentAttacker();
                    const bf = gameState.battlefield;

                    // Nếu người chơi đã đặt thẻ tấn công trước đó, trả thẻ cũ về tay
                    if (gameState.attackerCardChoice) {
                        // Xóa thẻ cũ khỏi bàn đấu
                        bf[gameState.attackerZoneChoice].attackerCard = null;
                        // Trả thẻ về tay
                        player.hand.push(gameState.attackerCardChoice);
                        // Hoàn lại lượt dùng thẻ ưu tiên nếu thẻ đó là ưu tiên
                        if (gameState.attackerCardChoice.isPriority) {
                            player.priorityUsedThisRound--;
                        }
                    }

                    // Đặt thẻ mới
                    player.hand = player.hand.filter((c) => c.id !== card.id);
                    if (card.isPriority) {
                        player.priorityUsedThisRound =
                            (player.priorityUsedThisRound || 0) + 1;
                    }
                    bf[zoneName].attackerCard = card;
                    gameState.attackerCardChoice = card;
                    gameState.attackerZoneChoice = zoneName;

                    this.showConfirmButton(true); // Hiển thị nút xác nhận
                    this.render(); // Cập nhật lại giao diện
                }
                async setPhase(newPhase) {
                    gameState.phase = newPhase;
                    console.log(`New Phase: ${newPhase}`);

                    // XÁC ĐỊNH NGƯỜI CHƠI TIẾP THEO SẼ HÀNH ĐỘNG
                    let nextPlayerToActId;
                    switch (newPhase) {
                        case PHASES.DEFENDER_PLACE_CARDS:
                        case PHASES.CHECK_DRAW:
                        case PHASES.DEFENDER_SWAP_CHOICE:
                            nextPlayerToActId = gameState.currentDefenderId;
                            break;
                        case PHASES.ATTACKER_CHOOSE_CARD:
                        case PHASES.ATTACKER_SWAP_CHOICE:
                            nextPlayerToActId = gameState.currentAttackerId;
                            break;
                    }


                    if (nextPlayerToActId !== undefined) {
                        await this.showTurnHandoff(nextPlayerToActId);
                    }

                    this.render(); // Render lại sau khi có thể đã đổi người chơi
                    switch (newPhase) {
                        case PHASES.START_TURN:
                            this.startTurn();
                            break;
                        case PHASES.ROLE_SELECTION:
                            this.handleRoleSelection();
                            break;
                        case PHASES.CHECK_DRAW:
                            const defenderForDraw = this.getCurrentDefender();
                            const hasPriorityCard = defenderForDraw.hand.some(
                                (c) => c.isPriority
                            );
                            const hasEnoughCards = defenderForDraw.hand.length >= 2;

                            // --- SỬA LOGIC TẠI ĐÂY ---
                            // Người chơi phải bốc bài nếu KHÔNG CÓ thẻ Ưu Tiên HOẶC có ÍT HƠN 2 LÁ BÀI
                            if (!hasPriorityCard || !hasEnoughCards) {
                                let reason = !hasPriorityCard ?
                                    "không có Thẻ Ưu Tiên" :
                                    "có ít hơn 2 lá bài";
                                this.log(
                                    `${defenderForDraw.name} ${reason}! Bắt buộc bốc bài.`
                                );
                                await this.sleep(1500);
                                this.handleDraw(defenderForDraw.id);
                            } else {
                                this.setPhase(PHASES.DEFENDER_PLACE_CARDS);
                            }
                            break;
                        case PHASES.DEFENDER_PLACE_CARDS:
                            this.log("Phòng Thủ: Kéo 2 lá bài vào 2 khu vực.");
                            if (this.getCurrentDefender().isAI)
                                await this.ai_placeDefenseCards();
                            break;
                        case PHASES.ATTACKER_CHOOSE_CARD:
                            // SỬA Ở ĐÂY: không gọi FINAL_DECISION nữa
                            // Việc chuyển phase sẽ do hàm handleAttackerDrop đảm nhiệm
                            this.log("Tấn Công: Kéo 1 lá bài vào khu vực muốn tấn công.");
                            if (this.getCurrentAttacker().isAI)
                                await this.ai_chooseAttackCard();
                            break;

                            // --- THÊM CÁC CASE MỚI ---
                        case PHASES.DEFENDER_SWAP_CHOICE:
                            await this.handleDefenderSwapChoice();
                            break;
                        case PHASES.ATTACKER_SWAP_CHOICE:
                            await this.handleAttackerSwapChoice();
                            break;

                        case PHASES.RESOLUTION:
                            this.resolveTurn();
                            break;
                    }
                    this.saveGameState();
                }
                // THÊM 2 HÀM MỚI NÀY VÀO TRONG CLASS GAME
                // THAY THẾ TOÀN BỘ HÀM NÀY
                async handleDefenderSwapChoice() {
                    this.log("Phòng thủ: Quyết định có tráo bài hay không...");
                    const defender = this.getCurrentDefender();

                    if (defender.isAI) {
                        await this.ai_finalDecisionDefender(); // Tái sử dụng logic AI cũ
                        this.setPhase(PHASES.ATTACKER_SWAP_CHOICE);
                    } else {
                        this.showConfirmationBar({
                            text: "Bạn có muốn tráo đổi 2 thẻ bài phòng thủ không?",
                            options: [{
                                    text: "Tráo đổi",
                                    value: true
                                },
                                {
                                    text: "Giữ nguyên",
                                    value: false
                                },
                            ],
                            onSelect: async (shouldSwap) => {
                                // THÊM MỚI LOGIC LƯU TRẠNG THÁI
                                if (shouldSwap) {
                                    [
                                        gameState.battlefield.main.defenderCard,
                                        gameState.battlefield.side.defenderCard,
                                    ] = [
                                        gameState.battlefield.side.defenderCard,
                                        gameState.battlefield.main.defenderCard,
                                    ];
                                    this.render();
                                    this.log("Bạn đã tráo bài phòng thủ!");
                                    // Lưu thông báo cho người chơi tiếp theo thấy
                                    gameState.lastTurnActionInfo = "Đối phương đã TRÁO BÀI phòng thủ.";
                                    await this.sleep(1500);
                                } else {
                                    // Xóa thông báo nếu không tráo
                                    gameState.lastTurnActionInfo = null;
                                }
                                this.setPhase(PHASES.ATTACKER_SWAP_CHOICE);
                            },
                        });
                    }
                }

                async handleAttackerSwapChoice() {
                    this.log("Tấn công: Quyết định có đổi khu vực tấn công không...");
                    const attacker = this.getCurrentAttacker();

                    if (attacker.isAI) {
                        await this.ai_finalDecisionAttacker();
                        this.log("Tất cả đã chốt. Xử lý kết quả!");
                        await this.sleep(1500);
                        this.setPhase(PHASES.RESOLUTION);
                    } else {
                        this.showConfirmationBar({
                            text: "Bạn có muốn đổi khu vực tấn công không?",
                            options: [{
                                    text: `Đổi sang Khu ${
            gameState.attackerZoneChoice === ZONES.MAIN
              ? "Phụ"
              : "Chính"
          }`,
                                    value: true,
                                },
                                {
                                    text: "Giữ Nguyên",
                                    value: false
                                },
                            ],
                            onSelect: async (shouldSwitch) => {
                                // THÊM MỚI LOGIC LƯU TRẠNG THÁI
                                if (shouldSwitch) {
                                    gameState.battlefield[
                                        gameState.attackerZoneChoice
                                    ].attackerCard = null;
                                    gameState.attackerZoneChoice =
                                        gameState.attackerZoneChoice === ZONES.MAIN ?
                                        ZONES.SIDE :
                                        ZONES.MAIN;
                                    gameState.battlefield[
                                        gameState.attackerZoneChoice
                                    ].attackerCard = gameState.attackerCardChoice;
                                    this.render();
                                    this.log("Bạn đã đổi khu vực tấn công!");
                                    // Lưu thông báo cho người chơi tiếp theo thấy
                                    gameState.lastTurnActionInfo = "Đối phương đã ĐỔI KHU VỰC tấn công.";
                                    await this.sleep(1500);
                                } else {
                                    // Xóa thông báo nếu không đổi
                                    gameState.lastTurnActionInfo = null;
                                }
                                this.log("Tất cả đã chốt. Xử lý kết quả!");
                                await this.sleep(1500);
                                this.setPhase(PHASES.RESOLUTION);
                            },
                        });
                    }
                }
                async ai_chooseAttackCard() {
                    await this.sleep(1000);
                    const ai = this.getCurrentAttacker();
                    let usableCards = ai.hand.filter(
                        (c) => !(c.isPriority && ai.priorityCardsUsedThisRound >= 2)
                    );
                    gameState.attackerCardChoice =
                        usableCards[Math.floor(Math.random() * usableCards.length)];
                    ai.hand = ai.hand.filter(
                        (c) => c.id !== gameState.attackerCardChoice.id
                    );
                    this.log("Đối thủ đã chọn bài...");
                    await this.sleep(1000);
                    gameState.attackerZoneChoice =
                        Math.random() < 0.5 ? ZONES.MAIN : ZONES.SIDE;
                    gameState.battlefield[gameState.attackerZoneChoice].attackerCard =
                        gameState.attackerCardChoice;
                    this.log(
                        `Đối thủ tấn công Khu ${
              gameState.attackerZoneChoice === ZONES.MAIN ? "Chính" : "Phụ"
            }.`
                    );
                    await this.sleep(1000);
                    this.setPhase(PHASES.DEFENDER_SWAP_CHOICE);
                }
                startRound() {
                    gameState.round++;
                    if (gameState.round > 5) {
                        this.endGame();
                        return;
                    }
                    gameState.turn = 1;
                    this.updateGameInfo();
                    gameState.players.forEach((p) => (p.priorityUsedThisRound = 0));
                    this.setPhase(PHASES.START_TURN);
                }
                async startTurn() {
                    this.resetBattlefield();
                    if (gameState.turn === 1) {
                        this.setPhase(PHASES.ROLE_SELECTION);
                    } else {
                        [gameState.currentAttackerId, gameState.currentDefenderId] = [
                            gameState.currentDefenderId,
                            gameState.currentAttackerId,
                        ];
                        this.log(
                            `Ván 2, đổi vai! ${this.getCurrentAttacker().name} Tấn Công.`
                        );
                        await this.sleep(2000);
                        this.setPhase(PHASES.CHECK_DRAW);
                    }
                }
                async handleRoleSelection() {
                    let chooserId;
                    if (gameState.round === 1) {
                        chooserId = 0;
                    } else {
                        const p0 = gameState.players[0],
                            p1 = gameState.players[1];
                        if (p0.score < p1.score) chooserId = 0;
                        else if (p1.score < p0.score) chooserId = 1;
                        else chooserId = gameState.lastTurnWinnerId === 0 ? 1 : 0;
                    }
                    await this.showTurnHandoff(chooserId);

                    const chooser = gameState.players[chooserId];

                    if (chooser.isAI) {
                        const choice =
                            Math.random() < 0.5 ? ROLES.ATTACKER : ROLES.DEFENDER;
                        this.log(
                            `AI (${chooser.name}) được chọn vai và đã chọn ${choice}.`
                        );
                        await this.sleep(1500);
                        this.setRoles(chooser.id, choice);
                    } else {
                        // Logic cho người chơi không đổi
                        this.showConfirmationBar({
                            text: `${chooser.name} được quyền chọn vai trò:`, // Dùng tên động
                            options: [{
                                    text: ROLES.ATTACKER,
                                    value: ROLES.ATTACKER
                                },
                                {
                                    text: ROLES.DEFENDER,
                                    value: ROLES.DEFENDER
                                },
                            ],
                            onSelect: (choice) => this.setRoles(chooser.id, choice),
                            isRoleSelection: true,
                        });
                    }
                }
                setRoles(chooserId, choice) {
                    if (choice === ROLES.ATTACKER) {
                        gameState.currentAttackerId = chooserId;
                        gameState.currentDefenderId = chooserId === 0 ? 1 : 0;
                    } else {
                        gameState.currentDefenderId = chooserId;
                        gameState.currentAttackerId = chooserId === 0 ? 1 : 0;
                    }
                    this.setPhase(PHASES.CHECK_DRAW);
                }
                // Dán để THAY THẾ TOÀN BỘ hàm resolveTurn() cũ
                async resolveTurn() {
                    this.log("Lật bài!");
                    await this.sleep(1000);
                    this.renderBattlefield(true);
                    await this.sleep(1500);

                    const attacker = this.getCurrentAttacker();
                    const defender = this.getCurrentDefender();
                    const attackZone = gameState.attackerZoneChoice;

                    // BƯỚC 1: XỬ LÝ KHU PHỤ
                    const sideZoneCard = gameState.battlefield.side.defenderCard;
                    let pointIncreaseInfo = null;

                    if (attackZone !== ZONES.SIDE && sideZoneCard) {
                        if (sideZoneCard.isBasic) {
                            gameState.cardBasePoints[sideZoneCard.type]++;
                            pointIncreaseInfo = {
                                cardType: sideZoneCard.type,
                                newPoints: gameState.cardBasePoints[sideZoneCard.type],
                            };
                            this.log(
                                `Thẻ ${
                  sideZoneCard.type
                } được bảo toàn. +1 điểm cơ bản! (Hiện tại: ${
                  gameState.cardBasePoints[sideZoneCard.type]
                })`
                            );
                            this.render();
                            await this.sleep(1500);
                            if (sideZoneCard.isPriority) {
                                gameState.commonDeck.push(sideZoneCard);
                                this.log(
                                    `Thẻ Ưu Tiên ở Khu Phụ của ${defender.name} bị loại bỏ.`
                                );
                            } else {
                                defender.hand.push(sideZoneCard);
                                this.log(`Thẻ ở Khu Phụ của ${defender.name} được trả về tay.`);
                            }
                        } else {
                            defender.hand.push(sideZoneCard);
                            this.log(`Thẻ ở Khu Phụ của ${defender.name} được trả về tay.`);
                        }
                        await this.sleep(1000);
                    }

                    // BƯỚC 2: XÁC ĐỊNH KẾT QUẢ ĐỐI ĐẦU
                    const defendingCard = gameState.battlefield[attackZone].defenderCard;
                    const attackingCard = gameState.attackerCardChoice;
                    let clashResult;
                    // (logic xác định kết quả giữ nguyên)
                    if (attackingCard.isSpecial || defendingCard.isSpecial) {
                        if (
                            attackingCard.type === SPECIAL_CARDS.WIN &&
                            defendingCard.type === SPECIAL_CARDS.WIN
                        )
                            clashResult = "defender";
                        else if (
                            attackingCard.type === SPECIAL_CARDS.LOSE &&
                            defendingCard.type === SPECIAL_CARDS.LOSE
                        )
                            clashResult = "defender";
                        else if (
                            attackingCard.type === SPECIAL_CARDS.WIN &&
                            defendingCard.type === SPECIAL_CARDS.LOSE
                        )
                            clashResult = "draw";
                        else if (
                            attackingCard.type === SPECIAL_CARDS.LOSE &&
                            defendingCard.type === SPECIAL_CARDS.WIN
                        )
                            clashResult = "draw";
                        else if (attackingCard.type === SPECIAL_CARDS.WIN)
                            clashResult = "attacker";
                        else if (defendingCard.type === SPECIAL_CARDS.WIN)
                            clashResult = "defender";
                        else if (attackingCard.type === SPECIAL_CARDS.LOSE)
                            clashResult = "defender";
                        else if (defendingCard.type === SPECIAL_CARDS.LOSE)
                            clashResult = "attacker";
                    } else {
                        const winMap = {
                            [CARD_TYPES.BUA]: CARD_TYPES.KEO,
                            [CARD_TYPES.KEO]: CARD_TYPES.BAO,
                            [CARD_TYPES.BAO]: CARD_TYPES.BUA,
                        };
                        if (attackingCard.type === defendingCard.type) clashResult = "draw";
                        else if (winMap[attackingCard.type] === defendingCard.type)
                            clashResult = "attacker";
                        else clashResult = "defender";
                    }

                    // BƯỚC 3, 4, 5 KẾT HỢP: TÍNH VÀ PHÂN BỔ ĐIỂM
                    let attackerScoreChange = 0;
                    let defenderScoreChange = 0;
                    const zoneMultiplier = attackZone === ZONES.MAIN ? 2 : 1;
                    const bonusBasePoint = 5;

                    const attackerBasePoints = attackingCard.isSpecial ?
                        5 :
                        gameState.cardBasePoints[attackingCard.type];
                    let attackerMultiplier = attackingCard.isPriority ?
                        attackZone === ZONES.MAIN ?
                        3 :
                        2 :
                        zoneMultiplier;
                    const attackerGiaoTranh = attackerBasePoints * attackerMultiplier;

                    const defenderBasePoints = defendingCard.isSpecial ?
                        5 :
                        gameState.cardBasePoints[defendingCard.type];
                    let defenderMultiplier = defendingCard.isPriority ?
                        attackZone === ZONES.MAIN ?
                        3 :
                        2 :
                        zoneMultiplier;
                    const defenderGiaoTranh = defenderBasePoints * defenderMultiplier;

                    const attackerFulfilledPurpose =
                        attackingCard.isSpecial &&
                        ((attackingCard.type === SPECIAL_CARDS.WIN &&
                                clashResult === "attacker") ||
                            (attackingCard.type === SPECIAL_CARDS.LOSE &&
                                clashResult === "defender"));

                    const defenderFulfilledPurpose =
                        defendingCard.isSpecial &&
                        ((defendingCard.type === SPECIAL_CARDS.WIN &&
                                clashResult === "defender") ||
                            (defendingCard.type === SPECIAL_CARDS.LOSE &&
                                clashResult === "attacker"));

                    if (attackerFulfilledPurpose) {
                        attackerScoreChange = bonusBasePoint * zoneMultiplier;
                        this.log(`${attacker.name} hoàn thành mục đích thẻ Đặc Biệt!`);
                    } else {
                        if (clashResult === "attacker")
                            attackerScoreChange = attackerGiaoTranh;
                        else if (clashResult === "defender")
                            attackerScoreChange = -attackerGiaoTranh;
                    }

                    if (defenderFulfilledPurpose) {
                        defenderScoreChange = bonusBasePoint * zoneMultiplier;
                        this.log(`${defender.name} hoàn thành mục đích thẻ Đặc Biệt!`);
                    } else {
                        if (clashResult === "defender")
                            defenderScoreChange = defenderGiaoTranh;
                        else if (clashResult === "attacker")
                            defenderScoreChange = -defenderGiaoTranh;
                    }

                    // ================ DÒNG QUAN TRỌNG ĐÃ SỬA ĐỔI ================
                    this.recordHistory(
                        clashResult,
                        pointIncreaseInfo,
                        attackerScoreChange,
                        defenderScoreChange,
                        attackerGiaoTranh,
                        defenderGiaoTranh
                    );
                    // =============================================================

                    if (clashResult === "attacker")
                        this.log(`${attacker.name} thắng cuộc đối đầu!`);
                    else if (clashResult === "defender")
                        this.log(`${defender.name} thắng cuộc đối đầu!`);
                    else this.log("Cuộc đối đầu kết thúc với kết quả Hòa!");

                    await this.sleep(1500);

                    attacker.score += attackerScoreChange;
                    defender.score += defenderScoreChange;
                    this.render({
                        updateBattlefield: false
                    }); // SỬA ĐỔI: Cập nhật điểm nhưng không render lại bàn đấu
                    this.showScoreChange(attacker.id, attackerScoreChange);
                    this.showScoreChange(defender.id, defenderScoreChange);
                    this.saveGameState();
                    await this.sleep(1500);

                    // (Phần dọn dẹp bàn đấu còn lại giữ nguyên)
                    if (attackingCard.isBasic) {
                        attackingCard.isPriority = false;
                        gameState.commonDeck.push(attackingCard);
                    } else if (attackingCard.isSpecial) {
                        attacker.specialCardsUsed[attackingCard.type] = true;
                    }
                    if (defendingCard.isBasic) {
                        defendingCard.isPriority = false;
                        gameState.commonDeck.push(defendingCard);
                    } else if (defendingCard.isSpecial) {
                        defender.specialCardsUsed[defendingCard.type] = true;
                    }
                    const mainZoneCard = gameState.battlefield.main.defenderCard;
                    if (attackZone !== ZONES.MAIN && mainZoneCard) {
                        if (mainZoneCard.isBasic) {
                            mainZoneCard.isPriority = false;
                            gameState.commonDeck.push(mainZoneCard);
                        } else if (mainZoneCard.isSpecial) {
                            defender.specialCardsUsed[mainZoneCard.type] = true;
                        }
                        this.log(`Thẻ ở Khu Chính của ${defender.name} bị loại bỏ.`);
                        await this.sleep(1000);
                    }
                    if (attackingCard.isPriority) attacker.priorityCardsUsedThisRound++;

                    if (clashResult === "attacker")
                        gameState.lastTurnWinnerId = attacker.id;
                    else if (clashResult === "defender")
                        gameState.lastTurnWinnerId = defender.id;
                    else gameState.lastTurnWinnerId = this.getCurrentDefender().id;
                    this.render();
                    await this.sleep(1500);
                    if (gameState.turn === 1) {
                        gameState.turn = 2;
                        this.setPhase(PHASES.START_TURN);
                    } else {
                        this.log(`Kết thúc Vòng ${gameState.round}.`);
                        await this.sleep(2000);
                        this.startRound();
                    }
                }

                // THAY THẾ TOÀN BỘ hàm handleDraw()
                async handleDraw(playerId) {
                    const player = this.getPlayer(playerId);
                    const opponent = this.getPlayer(playerId === 0 ? 1 : 0);

                    if (gameState.commonDeck.length < 3) {
                        this.log("Bộ bài chung không đủ để bốc!");
                        this.setPhase(PHASES.DEFENDER_PLACE_CARDS);
                        return;
                    }

                    // TRƯỜNG HỢP 1: Ít điểm hơn, được chọn bài
                    if (player.score < opponent.score) {
                        this.log(
                            `${player.name} đang bị dẫn trước và được quyền chọn 1 lá bài!`
                        );
                        await this.sleep(1500);

                        if (player.isAI) {
                            await this.ai_selectAndDrawCards(player);
                        } else {
                            this.showCardSelectionFromDeckModal(player);
                        }
                    }
                    // TRƯỜNG HỢP 2: Bằng hoặc nhiều điểm hơn, bốc ngẫu nhiên
                    else {
                        this.log(`${player.name} sẽ bốc 3 lá bài ngẫu nhiên.`);
                        await this.sleep(1500);

                        const drawnCards = [];
                        for (let i = 0; i < 3; i++) {
                            if (gameState.commonDeck.length === 0) break;
                            const cardIndex = Math.floor(
                                Math.random() * gameState.commonDeck.length
                            );
                            const card = gameState.commonDeck.splice(cardIndex, 1)[0];
                            card.isPriority = false;
                            drawnCards.push(card);
                        }
                        // === SỬA ĐỔI QUAN TRỌNG: Thêm 'true' để báo hiệu đây là bốc ngẫu nhiên ===
                        this.continueToPrioritySelection(player, drawnCards, true);
                    }
                }
                // THAY THẾ TOÀN BỘ hàm continueToPrioritySelection()
                async continueToPrioritySelection(player, drawnCards, isRandomDraw = false) {
                    const oldPriorityCount = player.hand.filter((c) => c.isPriority).length;
                    const neededPriorityCount = Math.max(0, 3 - oldPriorityCount);

                    if (neededPriorityCount <= 0 || drawnCards.length === 0) {
                        player.hand.push(...drawnCards);
                        this.log(`${player.name} đã bốc ${drawnCards.length} lá Thường mới.`);
                        await this.sleep(1500);
                        this.handlePostDraw(player);
                        return;
                    }

                    if (player.isAI) {
                        this.ai_handlePrioritySelection(player, drawnCards, neededPriorityCount);
                    } else if (isRandomDraw) {
                        // === LOGIC MỚI: Tự động gán ưu tiên khi bốc ngẫu nhiên ===
                        this.log(`Tự động chỉ định ${neededPriorityCount} Thẻ Ưu Tiên mới.`);
                        await this.sleep(1500);

                        // Gán ưu tiên cho các lá bài đầu tiên trong danh sách bốc được
                        for (let i = 0; i < neededPriorityCount; i++) {
                            if (drawnCards[i]) {
                                drawnCards[i].isPriority = true;
                            }
                        }
                        player.hand.push(...drawnCards);
                        this.handlePostDraw(player);
                    } else {
                        // Giữ nguyên logic cũ: cho người chơi chọn khi có lợi thế
                        this.log(`Bạn cần chỉ định ${neededPriorityCount} Thẻ Ưu Tiên mới.`);
                        await this.sleep(1500);
                        this.showPrioritySelectionModal(player, drawnCards, neededPriorityCount);
                    }
                }
                showCardSelectionFromDeckModal(player) {
                    const overlay = document.createElement("div");
                    overlay.className = "modal-overlay";

                    // Tạo nội dung cho modal
                    let cardsHTML = '<div class="card-selection-grid">';
                    gameState.commonDeck.forEach((card) => {
                        const cardEl = this.createCardElement(card);
                        // Gắn dữ liệu card ID vào element để xử lý click
                        cardEl.dataset.cardId = card.id;
                        cardsHTML += cardEl.outerHTML;
                    });
                    cardsHTML += "</div>";

                    const modal = document.createElement("div");
                    modal.className = "modal-content";
                    modal.innerHTML = `
                <h2>Lợi Thế Kẻ Yếu</h2>
                <p>Bạn đang bị dẫn trước. Hãy chọn 1 lá bài từ bộ bài chung:</p>
                ${cardsHTML}
            `;

                    overlay.appendChild(modal);
                    DOMElements.dynamicContainer.appendChild(overlay);

                    // Thêm sự kiện click cho từng lá bài trong modal
                    modal.querySelectorAll(".card").forEach((cardEl) => {
                        cardEl.onclick = () => {
                            const chosenCardId = cardEl.dataset.cardId;
                            const chosenCard = gameState.commonDeck.find(
                                (c) => c.id === chosenCardId
                            );

                            // Xóa lá bài đã chọn khỏi bộ bài chung
                            gameState.commonDeck = gameState.commonDeck.filter(
                                (c) => c.id !== chosenCardId
                            );

                            // Bắt đầu quá trình bốc bài với lá đã chọn
                            const drawnCards = [chosenCard];

                            // ======================= PHẦN THÊM MỚI =======================
                            // BỐC THÊM 2 LÁ NGẪU NHIÊN từ phần còn lại của bộ bài chung
                            this.log("Bốc thêm 2 lá bài ngẫu nhiên...");
                            for (let i = 0; i < 2; i++) {
                                // Kiểm tra xem bộ bài chung còn bài không
                                if (gameState.commonDeck.length > 0) {
                                    const cardIndex = Math.floor(
                                        Math.random() * gameState.commonDeck.length
                                    );
                                    const randomCard = gameState.commonDeck.splice(
                                        cardIndex,
                                        1
                                    )[0];
                                    drawnCards.push(randomCard);
                                }
                            }
                            // ===================== KẾT THÚC PHẦN THÊM MỚI =====================

                            // Reset isPriority cho cả 3 lá vừa bốc
                            drawnCards.forEach((c) => (c.isPriority = false));

                            overlay.remove(); // Đóng modal
                            this.log(
                                `${player.name} đã chọn ${chosenCard.type} và bốc thêm 2 lá.`
                            );

                            // Chuyển sang bước tiếp theo: chọn thẻ ưu tiên
                            this.continueToPrioritySelection(player, drawnCards); // <<< Bây giờ hàm này sẽ được gọi với đủ 3 lá bài
                        };
                    });
                }
                async ai_selectAndDrawCards(player) {
                    this.log(
                        `AI (${player.name}) đang tính toán để chọn lá bài tốt nhất...`
                    );
                    await this.sleep(2000);

                    let bestCard = null;
                    let maxPoints = -1;

                    // Chiến lược đơn giản: Tìm lá bài có điểm cơ bản cao nhất
                    gameState.commonDeck.forEach((card) => {
                        const points = gameState.cardBasePoints[card.type] || 0;
                        if (points > maxPoints) {
                            maxPoints = points;
                            bestCard = card;
                        }
                    });

                    // Nếu không tìm thấy lá nào có điểm (toàn thẻ đặc biệt), chọn ngẫu nhiên
                    if (!bestCard) {
                        bestCard =
                            gameState.commonDeck[
                                Math.floor(Math.random() * gameState.commonDeck.length)
                            ];
                    }

                    this.log(`AI đã chọn xong!`);
                    await this.sleep(1500);

                    // Xóa lá bài đã chọn khỏi bộ bài chung
                    gameState.commonDeck = gameState.commonDeck.filter(
                        (c) => c.id !== bestCard.id
                    );

                    // Bắt đầu bốc bài với lá đã chọn
                    const drawnCards = [bestCard];

                    // Bốc thêm 2 lá ngẫu nhiên
                    for (let i = 0; i < 2; i++) {
                        if (gameState.commonDeck.length > 0) {
                            const cardIndex = Math.floor(
                                Math.random() * gameState.commonDeck.length
                            );
                            const randomCard = gameState.commonDeck.splice(cardIndex, 1)[0];
                            drawnCards.push(randomCard);
                        }
                    }

                    drawnCards.forEach((c) => (c.isPriority = false));

                    // Chuyển sang bước tiếp theo: chọn thẻ ưu tiên
                    this.continueToPrioritySelection(player, drawnCards);
                }
                // Dán để THAY THẾ TOÀN BỘ hàm recordHistory() cũ
                recordHistory(
                    clashResult,
                    pointIncreaseInfo = null,
                    attackerScoreChange,
                    defenderScoreChange,
                    attackerClashPoints,
                    defenderClashPoints
                ) {
                    const attacker = this.getCurrentAttacker();
                    const defender = this.getCurrentDefender();
                    const attackingCard = {
                        ...gameState.attackerCardChoice
                    }; // Clone để thêm dữ liệu
                    const defendingCard = {
                        ...gameState.battlefield[gameState.attackerZoneChoice].defenderCard,
                    }; // Clone

                    let winnerId = null;
                    if (clashResult === "attacker") winnerId = attacker.id;
                    if (clashResult === "defender") winnerId = defender.id;

                    // Gán điểm giao tranh vào lá bài để hiển thị
                    attackingCard.clashPoints = attackerClashPoints;
                    defendingCard.clashPoints = defenderClashPoints;

                    // Xác định thẻ của người chơi (player) và đối thủ (opponent)
                    const playerIsAttacker = this.getPlayer(0).id === attacker.id;

                    gameState.detailedHistory.push({
                        round: gameState.round,
                        turn: gameState.turn,
                        winnerId: winnerId,
                        pointIncreaseInfo: pointIncreaseInfo,
                        attackerScoreChange,
                        defenderScoreChange,
                        player: {
                            id: 0,
                            role: playerIsAttacker ? "Tấn Công" : "Phòng Thủ",
                            card: playerIsAttacker ? attackingCard : defendingCard,
                        },
                        opponent: {
                            id: 1,
                            role: !playerIsAttacker ? "Tấn Công" : "Phòng Thủ",
                            card: !playerIsAttacker ? attackingCard : defendingCard,
                        },
                    });
                }
                // Dán để THAY THẾ TOÀN BỘ hàm showDetailedHistoryModal() cũ
                showDetailedHistoryModal() {
                    const createMiniCardHTML = (card, role, scoreChange) => {
                        if (!card) return '<div class="mini-card"></div>';

                        const roleTag =
                            role === "Tấn Công" ?
                            '<div class="mini-card__tag tag--attacker">Tấn Công</div>' :
                            '<div class="mini-card__tag tag--defender">Phòng Thủ</div>';

                        // Tag hiển thị điểm cộng/trừ
                        let scoreChangeTag = "";
                        if (scoreChange !== 0) {
                            const changeClass = scoreChange > 0 ? "win" : "loss";
                            const sign = scoreChange > 0 ? "+" : "";
                            scoreChangeTag = `<div class="mini-card__tag tag--score-change ${changeClass}">${sign}${scoreChange}</div>`;
                        }

                        return `
      <div class="mini-card">
          <div class="mini-card__symbol">${SYMBOLS[card.type] || "?"}</div>
          <div class="mini-card__points">${card.clashPoints || "?"} Điểm</div>
          <div class="mini-card__tags">
              ${roleTag}
              ${scoreChangeTag}
          </div>
      </div>
    `;
                    };

                    let contentHTML = '<ul class="detailed-history-list">';
                    if (gameState.detailedHistory.length === 0) {
                        contentHTML += "<li>Chưa có lịch sử.</li>";
                    } else {
                        [...gameState.detailedHistory].reverse().forEach((turn) => {
                            let resultText, resultClass;
                            if (turn.winnerId === null) {
                                resultText = "Hòa";
                                resultClass = "draw-text";
                            } else if (turn.winnerId === 0) {
                                resultText = "Thắng";
                                resultClass = "win-text";
                            } else {
                                resultText = "Thua";
                                resultClass = "loss-text";
                            }

                            // Lấy đúng điểm cộng/trừ cho mỗi người
                            const playerScoreChange =
                                turn.player.role === "Tấn Công" ?
                                turn.attackerScoreChange :
                                turn.defenderScoreChange;
                            const opponentScoreChange =
                                turn.opponent.role === "Tấn Công" ?
                                turn.attackerScoreChange :
                                turn.defenderScoreChange;

                            const playerCardHTML = createMiniCardHTML(
                                turn.player.card,
                                turn.player.role,
                                playerScoreChange
                            );
                            const opponentCardHTML = createMiniCardHTML(
                                turn.opponent.card,
                                turn.opponent.role,
                                opponentScoreChange
                            );

                            // Tạo các tag chung cho lượt đấu
                            let turnTagsHTML = `<div class="history-item__tags">
        <div class="mini-card__tag ${resultClass}">${resultText}</div>`;
                            if (turn.pointIncreaseInfo) {
                                turnTagsHTML += `
          <div class="mini-card__tag tag--points-up">
            ${SYMBOLS[turn.pointIncreaseInfo.cardType]} +1
          </div>
        `;
                            }
                            turnTagsHTML += `</div>`;

                            contentHTML += `
        <li>
            <div class="history-item">
                <div class="history-item__header">
                    <strong>Vòng ${turn.round} - Ván ${turn.turn}</strong>
                </div>
                <div class="history-item__clash">
                    ${playerCardHTML}
                    <div class="history-item__vs">VS</div>
                    ${opponentCardHTML}
                </div>
                ${turnTagsHTML}
            </div>
        </li>`;
                        });
                    }
                    contentHTML += "</ul>";

                    this.showInfoModal({
                        title: "Lịch Sử Đối Đầu",
                        content: contentHTML,
                        modalClass: "detailed-history-modal",
                    });
                }
                handlePostDraw(player) {
                    let basicCards = player.hand.filter((c) => c.isBasic);
                    while (basicCards.length > 6) {
                        const normalCardIndex = player.hand.findIndex(
                            (c) => c.isBasic && !c.isPriority
                        );
                        if (normalCardIndex > -1) {
                            const removedCard = player.hand.splice(normalCardIndex, 1)[0];

                            gameState.commonDeck.push(removedCard);
                            this.log(
                                `Tay bài vượt quá 6. Đã tự động bỏ lá ${removedCard.type} Thường.`
                            );
                        } else {
                            const priorityCardIndex = player.hand.findIndex(
                                (c) => c.isPriority
                            );
                            const removedCard = player.hand.splice(priorityCardIndex, 1)[0];
                            removedCard.isPriority = false;
                            gameState.commonDeck.push(removedCard);
                            this.log(
                                `Tay bài vượt quá 6. Đã tự động bỏ lá ${removedCard.type} Ưu Tiên.`
                            );
                        }
                        basicCards = player.hand.filter((c) => c.isBasic);
                    }
                    this.log("Rút bài hoàn tất. Tiếp tục trận đấu.");
                    this.setPhase(PHASES.DEFENDER_PLACE_CARDS);
                }
                ai_handlePrioritySelection(player, drawnCards, neededCount) {
                    for (let i = 0; i < neededCount; i++) {
                        const randomIndex = Math.floor(Math.random() * drawnCards.length);
                        const selectedCard = drawnCards.splice(randomIndex, 1)[0];
                        selectedCard.isPriority = true;
                        player.hand.push(selectedCard);
                    }
                    player.hand.push(...drawnCards);
                    this.log(`AI đã chỉ định ${neededCount} Thẻ Ưu Tiên mới.`);
                    this.handlePostDraw(player);
                }
                resetBattlefield() {
                    gameState.battlefield = {
                        main: {
                            defenderCard: null,
                            attackerCard: null
                        },
                        side: {
                            defenderCard: null,
                            attackerCard: null
                        },
                    };
                    gameState.attackerCardChoice = null;
                    gameState.attackerZoneChoice = null;
                    DOMElements.board.opponentMainSlot.innerHTML = "";
                    DOMElements.board.opponentSideSlot.innerHTML = "";
                    DOMElements.board.playerMainSlot.innerHTML = "";
                    DOMElements.board.playerSideSlot.innerHTML = "";
                }
                endGame() {
                    localStorage.removeItem('savedGame');
                    gameState.phase = PHASES.GAME_OVER;
                    const p0 = gameState.players[0],
                        p1 = gameState.players[1];
                    let text;
                    if (p0.score > p1.score) text = "Bạn đã chiến thắng!";
                    else if (p1.score > p0.score) text = "Bạn đã thua!";
                    else text = "Hòa điểm!";
                    this.showConfirmationBar({
                        text: `KẾT THÚC TRẬN ĐẤU. ${text}<br>Tỷ số: ${p0.score} - ${p1.score}`,
                        options: [{
                            text: "Chơi Lại",
                            value: "restart"
                        }],
                        onSelect: () => window.location.reload(),
                        isRoleSelection: true,
                    });
                }
                showScoreChange(playerId, change) {
                    if (change === 0) return;
                    const player = this.getPlayer(playerId);

                    // =========================================================
                    // SỬA ĐỔI CỐT LÕI:
                    // Thay vì dựa vào player.isAI, chúng ta so sánh với activePlayerId
                    // để biết người chơi đó đang ở trên hay ở dưới màn hình.
                    const isPlayerInBottomArea = player.id === this.activePlayerId;
                    const scoreEl = isPlayerInBottomArea ?
                        DOMElements.player.score :
                        DOMElements.opponent.score;
                    // =========================================================

                    const rect = scoreEl.getBoundingClientRect();
                    const changeEl = document.createElement("div");
                    changeEl.className = "score-change";
                    changeEl.textContent = (change > 0 ? "+" : "") + change;
                    changeEl.style.color =
                        change > 0 ? "var(--win-color)" : "var(--loss-color)";
                    changeEl.style.left = `${rect.left + rect.width / 2}px`;
                    changeEl.style.top = `${rect.top + rect.height / 2}px`;
                    DOMElements.dynamicContainer.appendChild(changeEl);
                    setTimeout(() => changeEl.remove(), 1500);
                }
                // THAY THẾ TOÀN BỘ HÀM NÀY
                async ai_finalDecisionDefender() {
                    if (Math.random() < 0.4) {
                        const bf = gameState.battlefield;
                        [bf.main.defenderCard, bf.side.defenderCard] = [
                            bf.side.defenderCard,
                            bf.main.defenderCard,
                        ];
                        this.render();
                        this.log("Đối thủ Phòng Thủ đã tráo đổi bài!");

                        gameState.lastTurnActionInfo = "Đối phương đã TRÁO BÀI phòng thủ.";
                        await this.sleep(1500);
                    } else {
                        this.log("Đối thủ Phòng Thủ quyết định giữ nguyên vị trí.");

                        gameState.lastTurnActionInfo = null;
                        await this.sleep(1500);
                    }
                }
                async ai_finalDecisionAttacker() {
                    if (Math.random() < 0.3) {
                        gameState.battlefield[gameState.attackerZoneChoice].attackerCard = null;
                        gameState.attackerZoneChoice =
                            gameState.attackerZoneChoice === ZONES.MAIN ?
                            ZONES.SIDE :
                            ZONES.MAIN;
                        gameState.battlefield[gameState.attackerZoneChoice].attackerCard =
                            gameState.attackerCardChoice;
                        this.render();
                        this.log("Đối Thủ Tấn Công đã đổi khu vực!");

                        gameState.lastTurnActionInfo = "Đối phương đã ĐỔI KHU VỰC tấn công.";
                        await this.sleep(1500);
                    } else {
                        this.log("Đối thủ Tấn Công quyết định giữ nguyên mục tiêu.");

                        gameState.lastTurnActionInfo = null;
                        await this.sleep(1500);
                    }
                }
                async ai_placeDefenseCards() {
                    await this.sleep(1000);
                    const ai = this.getCurrentDefender();

                    // --- SỬA TOÀN BỘ LOGIC CHỌN BÀI CỦA AI ---
                    let card1 = null,
                        card2 = null;

                    // Lấy ra tất cả các cặp bài có thể có từ tay của AI
                    let allPairs = [];
                    for (let i = 0; i < ai.hand.length; i++) {
                        for (let j = i + 1; j < ai.hand.length; j++) {
                            allPairs.push([ai.hand[i], ai.hand[j]]);
                        }
                    }

                    // Lọc ra các cặp hợp lệ (có ít nhất 1 thẻ Ưu Tiên và không chứa 2 thẻ Đặc Biệt)
                    const validPairs = allPairs.filter((pair) => {
                        const hasPriority = pair[0].isPriority || pair[1].isPriority;
                        const notTwoSpecials = !(pair[0].isSpecial && pair[1].isSpecial);
                        return hasPriority && notTwoSpecials;
                    });

                    if (validPairs.length > 0) {
                        // Nếu có cặp hợp lệ, chọn ngẫu nhiên một cặp
                        const chosenPair =
                            validPairs[Math.floor(Math.random() * validPairs.length)];
                        card1 = chosenPair[0];
                        card2 = chosenPair[1];
                    } else {
                        // Trường hợp rất hiếm: không có cặp nào hợp lệ, báo lỗi và dừng (cần xử lý thêm nếu muốn game tiếp tục)
                        // Logic CHECK_DRAW mới sẽ gần như loại bỏ hoàn toàn trường hợp này.
                        this.log(
                            `LỖI: AI ${ai.name} không tìm thấy cặp bài phòng thủ hợp lệ!`
                        );
                        return;
                    }

                    // Phân ngẫu nhiên 2 lá bài vào 2 khu vực
                    if (Math.random() < 0.5) {
                        gameState.battlefield.main.defenderCard = card1;
                        gameState.battlefield.side.defenderCard = card2;
                    } else {
                        gameState.battlefield.main.defenderCard = card2;
                        gameState.battlefield.side.defenderCard = card1;
                    }
                    let priorityOnBoard = 0;
                    if (gameState.battlefield.main.defenderCard?.isPriority)
                        priorityOnBoard++;
                    if (gameState.battlefield.side.defenderCard?.isPriority)
                        priorityOnBoard++;
                    ai.priorityCardsUsedThisRound = priorityOnBoard;
                    ai.hand = ai.hand.filter(
                        (c) => c.id !== card1.id && c.id !== card2.id
                    );
                    this.log("Đối thủ đã đặt bài.");
                    await this.sleep(1000);
                    this.setPhase(PHASES.ATTACKER_CHOOSE_CARD);
                }
            }

            // THAY THẾ TOÀN BỘ KHỐI LOGIC KHỞI ĐỘNG GAME BẰNG KHỐI MỚI NÀY

            const game = new Game();
            const modeModal = document.getElementById('game-mode-modal');
            const nameModal = document.getElementById('player-name-modal');

            // Hàm hiển thị modal nhập tên
            function showNameModal(mode) {
                const inputsContainer = document.getElementById('player-name-inputs');
                inputsContainer.innerHTML = ''; // Xóa input cũ

                if (mode === 'pvai') {
                    inputsContainer.innerHTML = `
            <input type="text" id="player1-name-input" placeholder="Tên của bạn" style="padding: 0.5rem; font-size: 1rem; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-surface-2); color: var(--text-primary);">
        `;
                } else { // pvp
                    inputsContainer.innerHTML = `
            <input type="text" id="player1-name-input" placeholder="Tên Người Chơi 1" style="padding: 0.5rem; font-size: 1rem; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-surface-2); color: var(--text-primary);">
            <input type="text" id="player2-name-input" placeholder="Tên Người Chơi 2" style="padding: 0.5rem; font-size: 1rem; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-surface-2); color: var(--text-primary);">
        `;
                }

                modeModal.style.display = 'none';
                nameModal.style.display = 'flex';

                document.getElementById('start-game-btn').onclick = () => {
                    // Xóa game đã lưu khi bắt đầu game mới
                    localStorage.removeItem('savedGame');

                    const name1 = document.getElementById('player1-name-input').value.trim() || (mode === 'pvai' ? 'Bạn' : 'Người Chơi 1');
                    let name2;
                    if (mode === 'pvp') {
                        name2 = document.getElementById('player2-name-input').value.trim() || 'Người Chơi 2';
                    } else {
                        name2 = 'Đối Thủ';
                    }

                    nameModal.style.display = 'none';
                    game.init(mode, name1, name2);
                };
            }

            // Hàm kiểm tra và khởi tạo giao diện ban đầu
            function initializeUI() {
                const savedGame = localStorage.getItem('savedGame');
                if (savedGame) {
                    const state = JSON.parse(savedGame);
                    const continueSection = document.getElementById('continue-game-section');
                    const continueBtn = document.getElementById('continue-btn');

                    continueBtn.innerHTML = `Tiếp Tục (Vòng ${state.round})<br><span style="font-size:0.9rem; font-weight: 400;">${state.players[0].name}: ${state.players[0].score} - ${state.players[1].name}: ${state.players[1].score}</span>`;

                    continueSection.style.display = 'block';

                    continueBtn.onclick = () => {
                        modeModal.style.display = 'none';
                        game.resumeGame(state);
                    };
                }

                document.getElementById('pvai-btn').onclick = () => showNameModal('pvai');
                document.getElementById('pvp-btn').onclick = () => showNameModal('pvp');
            }

            // Chạy hàm khởi tạo khi trang được tải
            initializeUI();
        </script>
</body>

</html>
