<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>T·ª≠ Chi·∫øn Song Khu O·∫≥n T√π T√¨</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet" />
    <style>
        /* ============================================= */
        /* 1. THI·∫æT K·∫æ H·ªÜ TH·ªêNG & BI·∫æN M√ÄU M·ªöI           */
        /* ============================================= */
        :root {
            /* B·∫£ng m√†u m·ªõi - Phong c√°ch Material Dark */
            --bg-primary: #12121c;
            /* N·ªÅn ch√≠nh s√¢u h∆°n */
            --bg-surface-1: #1e1e2d;
            /* N·ªÅn cho c√°c khu v·ª±c */
            --bg-surface-2: #2a2a3c;
            /* N·ªÅn n·ªïi b·∫≠t h∆°n, cho th·∫ª b√†i */
            --text-primary: #e0e0e0;
            /* Ch·ªØ ch√≠nh, kh√¥ng qu√° tr·∫Øng */
            --text-secondary: #a0a0b0;
            /* Ch·ªØ ph·ª•, x√°m h∆°n */
            --accent-primary: #4a90e2;
            /* Xanh d∆∞∆°ng l√†m ƒëi·ªÉm nh·∫•n */
            --accent-primary-hover: #357abd;
            --border-color: rgba(255, 255, 255, 0.1);
            --win-color: #4caf50;
            --loss-color: #f44336;
            --draw-color: #9e9e9e;
            --priority-glow: 0 0 10px 2px #ffc107;
            --special-glow: 0 0 10px 2px #03a9f4;
            --font-main: "Inter", sans-serif;
            --border-radius-md: 12px;
            --border-radius-lg: 16px;
            font-size: 16px;
        }

        /* ============================================= */
        /* 2. THI·∫æT L·∫¨P C∆† B·∫¢N & B·ªê C·ª§C CHUNG           */
        /* ============================================= */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100dvh;
            overflow: hidden;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: var(--font-main);
            user-select: none;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 480px;
            /* TƒÉng nh·∫π max-width */
            height: 100dvh;
            margin: 0 auto;
            position: relative;
            padding: 0.5rem;
            gap: 0.75rem;
        }

        /* ============================================= */
        /* 3. C√ÅC KHU V·ª∞C CH√çNH (HEADER, PLAYER, BOARD) */
        /* ============================================= */
        #game-header {
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background-color: var(--bg-surface-1);
            border-radius: var(--border-radius-md);
            border: 1px solid var(--border-color);
        }

        #turn-info {
            font-weight: 700;
            font-size: 1rem;
            color: var(--accent-primary);
        }

        #history-trigger {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        #history-dots {
            display: flex;
            gap: 0.3rem;
        }

        .history-dot {
            width: 0.8rem;
            height: 0.8rem;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .history-dot.win {
            background: var(--win-color);
        }

        .history-dot.loss {
            background: var(--loss-color);
        }

        .history-dot.draw {
            background: var(--draw-color);
        }

        .player-area {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem 1rem;
            background-color: var(--bg-surface-1);
            border-radius: var(--border-radius-md);
            border: 1px solid var(--border-color);
            /* TH√äM D√íNG N√ÄY ƒë·ªÉ ƒë·∫©y b·ªô ƒë·∫øm sang ph·∫£i */
            justify-content: space-between;
        }

        .player-name {
            font-weight: 700;
            font-size: 1.1rem;
            /* TH√äM C√ÅC D√íNG N√ÄY ƒë·ªÉ t·∫°o style m·∫∑c ƒë·ªãnh */
            padding: 0.15rem 0.5rem;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        /* TH√äM CLASS M·ªöI: Style cho vai tr√≤ T·∫•n C√¥ng */
        /* B·ªé C√ÅC ƒê·ªäNH NGHƒ®A .player-name.role-attacker v√† .player-name.role-defender */

        /* THAY TH·∫æ B·∫∞NG C√ÅC ƒê·ªäNH NGHƒ®A M·ªöI CHO .player-info */
        .player-info.role-attacker {
            background-color: var(--loss-color);
            /* M√†u ƒë·ªè */
            border-color: var(--loss-color);
        }

        .player-info.role-defender {
            background-color: var(--accent-primary);
            /* M√†u xanh d∆∞∆°ng */
            border-color: var(--accent-primary);
        }

        /* ƒê·∫£m b·∫£o ch·ªØ v√† ƒëi·ªÉm b√™n trong c√≥ m√†u t∆∞∆°ng ph·∫£n khi n·ªÅn thay ƒë·ªïi */
        .player-info.role-attacker .player-name,
        .player-info.role-attacker .player-score,
        .player-info.role-defender .player-name,
        .player-info.role-defender .player-score {
            color: white;
        }

        /* B·ªè n·ªÅn tr·∫Øng m·∫∑c ƒë·ªãnh c·ªßa player-name ƒë·ªÉ kh√¥ng che m·∫•t m√†u vai tr√≤ */
        .player-name {
            font-weight: 700;
            font-size: 1.1rem;
            padding: 0;
            /* B·ªè padding c≈© */
            border-radius: 6px;
            transition: all 0.3s ease;
            background-color: transparent;
            /* ƒê·∫∑t n·ªÅn trong su·ªët */
        }

        /* S·ª¨A L·∫†I player-role ƒê·ªÇ D√ôNG CHO B·ªò ƒê·∫æM */
        .player-role {
            font-size: 0.9rem;
            /* TƒÉng k√≠ch th∆∞·ªõc ch·ªØ m·ªôt ch√∫t */
            font-weight: 700;
            padding: 0.25rem 0.6rem;
            border-radius: 8px;
            background-color: #ffc107;
            /* M√†u v√†ng ƒë·∫≠m */
            color: black;
            /* Ch·ªØ ƒëen */
        }

        .player-score {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--accent-primary);
        }

        /* B·ªë c·ª•c tay b√†i - linh ho·∫°t v√† r·ªông r√£i h∆°n */
        .hand {
            min-height: 6.5rem;
            /* ƒê·∫£m b·∫£o c√≥ kh√¥ng gian cho th·∫ª b√†i */
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* B·∫£ng ƒë·∫•u - trung t√¢m c·ªßa tr√≤ ch∆°i */
        #board {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            /* S·ª≠a th√†nh 3 h√†ng ƒë·ªÉ ch·ª©a action-bar */
            grid-template-rows: 6rem 3rem 6rem;
            /* Thay 1fr b·∫±ng auto */
            align-items: center;
            /* CƒÉn gi·ªØa c√°c h√†ng theo chi·ªÅu d·ªçc */
            gap: 0.75rem;
            place-content: center;
            padding: 0.75rem;
            background-color: var(--bg-surface-1);
            border-radius: var(--border-radius-lg);
            border: 1px solid var(--border-color);
            justify-content: center;
            align-content: center;
            justify-items: center;
            align-items: center;
        }

        /* Style cho Action Bar m·ªõi */
        #action-bar {
            grid-column: 1 / -1;
            /* Tr·∫£i d√†i h·∫øt 2 c·ªôt */
            width: 100%;
            height: auto;
            /* Chi·ªÅu cao t·ª± ƒë·ªông */
            min-height: 20px;
            /* Chi·ªÅu cao t·ªëi thi·ªÉu */
            border: none;
            background: transparent;
            padding: 0.25rem;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            gap: 1rem;
            /* TH√äM: Kho·∫£ng c√°ch gi·ªØa c√°c n√∫t */
        }

        /* TH√äM M·ªöI: ƒê·ªãnh nghƒ©a ri√™ng ƒë·ªÉ thu nh·ªè n√∫t trong action-bar */
        #action-bar .btn {
            padding: 0.5rem 1.25rem;
            font-size: 0.9rem;
        }

        .action-bar__text {
            font-size: 1rem;
            font-weight: 500;
            animation: fade-in 0.3s ease;
        }

        /* Lo·∫°i b·ªè Game Log c≈© */
        #game-log {
            display: none !important;
        }

        .card-slot {
            width: 4.2rem;
            /* S·ª¨A L·∫†I: B·∫±ng chi·ªÅu r·ªông th·∫ª b√†i */
            height: 6rem;
            /* S·ª¨A L·∫†I: B·∫±ng chi·ªÅu cao th·∫ª b√†i */
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: var(--border-radius-md);
            border: 1px dashed var(--border-color);
            position: relative;
            /* C·∫ßn cho vi·ªác ƒë·∫∑t t√™n khu v·ª±c ·ªü b∆∞·ªõc 3 */
            transition: all 0.3s ease;
        }

        /* Th√™m l·∫°i hi·ªáu ·ª©ng drop-hover cho t·ª´ng √¥ */
        .card-slot.drop-hover {
            border-style: solid;
            border-color: var(--accent-primary);
            box-shadow: 0 0 15px rgba(74, 144, 226, 0.5);
        }

        .card-slot::before {
            position: absolute;
            bottom: 0.25rem;
            /* ƒê∆∞a xu·ªëng d∆∞·ªõi */
            left: 50%;
            transform: translateX(-50%);
            font-size: 1rem;
            /* Cho to h∆°n m·ªôt ch√∫t */
            font-weight: 900;
            /* ƒê·∫≠m h∆°n cho n·ªïi b·∫≠t */
            z-index: 10;
            /* QUAN TR·ªåNG: ƒê·ªÉ n·ªïi l√™n tr√™n l√° b√†i */
            pointer-events: none;
            /* ƒê·ªÉ kh√¥ng c·∫£n tr·ªü vi·ªác k√©o th·∫£ */
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.7);
            /* Th√™m b√≥ng cho d·ªÖ ƒë·ªçc */
        }

        /* T√¥ m√†u V√ÄNG cho c·∫£ 2 nh√£n */
        .card-slot[data-zone="main"]::before {
            content: "x2";
            color: var(--priority-glow-color, #ffc107);
        }

        .card-slot[data-zone="side"]::before {
            content: "x1";
            color: var(--priority-glow-color, #ffc107);
        }

        #player-hand .card.touch-peek {
            transform: translateY(-1.2rem) scale(1.1);
            z-index: 100 !important;
        }

        /* ============================================= */
        /* 4. THI·∫æT K·∫æ TH·∫∫ B√ÄI (CARD) M·ªöI               */
        /* ============================================= */
        .card {
            width: 4.2rem;
            height: 6rem;
            border-radius: var(--border-radius-md);
            background-color: var(--bg-surface-2);
            position: relative;
            transition: transform 0.3s ease, opacity 0.3s ease,
                left 0.4s ease-in-out;
            transform-style: preserve-3d;
            flex-shrink: 0;
            border: 2px solid var(--border-color);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .hand .card {
            position: absolute;
            cursor: grab;
        }

        #player-hand .card {
            bottom: 0;
            /* Ghim ch·∫∑t l√° b√†i v√†o c·∫°nh d∆∞·ªõi khu v·ª±c tay b√†i */
        }

        #opponent-hand .card {
            top: 0;
            /* Ghim ch·∫∑t l√° b√†i v√†o c·∫°nh tr√™n khu v·ª±c tay b√†i */
        }

        .hand .card:active {
            cursor: grabbing;
        }

        /* === FIX: CH·ªà CHO PH√âP HOVER B√ÄI C·ª¶A NG∆Ø·ªúI CH∆†I === */
        #player-hand .card:hover {
            transform: translateY(-1.2rem) scale(1.1);
            z-index: 100 !important;
        }

        .card.dragging {
            opacity: 0.8;
            transform: scale(1.15);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        .card.priority {
            border-color: #ffc107;
            box-shadow: var(--priority-glow);
        }

        .card.special {
            border-color: #03a9f4;
            box-shadow: var(--special-glow);
        }

        .card.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            border-radius: 10px;
            /* Match inner radius */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            overflow: hidden;
            padding: 0.4rem;
        }

        .card-front {
            background: linear-gradient(135deg, var(--bg-surface-2), #3c3c4d);
        }

        .card-back {
            background: linear-gradient(45deg, #4a90e2, #357abd);
            font-size: 2.5rem;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.8);
            transform: rotateY(180deg);
            justify-content: center;
        }

        .card-header,
        .card-footer {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-name {
            font-size: 0.6rem;
            font-weight: 500;
        }

        .card-priority-tag {
            font-size: 0.6rem;
            font-weight: 700;
            color: #ffc107;
        }

        .card-symbol {
            font-size: 2.2rem;
            line-height: 1;
            font-weight: 900;
            margin-top: -0.5rem;
            /* Tinh ch·ªânh v·ªã tr√≠ */
        }

        .card-value {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--accent-primary);
        }

        /* ============================================= */
        /* 5. C√ÅC PH·∫¶N T·ª¨ ƒê·ªòNG & POPUP                  */
        /* ============================================= */

        /* L·ªõp ph·ªß cho t·∫•t c·∫£ modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 200;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
            animation: fade-in 0.3s ease;
        }

        @keyframes fade-in {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .modal-content {
            background: var(--bg-surface-1);
            border-radius: var(--border-radius-lg);
            padding: 1.5rem;
            width: 100%;
            max-width: 400px;
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            gap: 1rem;
            animation: slide-up-fade 0.4s ease-out;
        }

        @keyframes slide-up-fade {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-content h2 {
            font-size: 1.4rem;
            color: var(--accent-primary);
            text-align: center;
        }

        .modal-content p {
            font-size: 1rem;
            color: var(--text-primary);
            line-height: 1.5;
            text-align: center;
        }

        .modal-options {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .btn {
            background: var(--accent-primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--border-radius-md);
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: var(--accent-primary-hover);
        }

        .btn-secondary {
            background: var(--bg-surface-2);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-surface-1);
        }

        /* Game Log - Tinh t·∫ø h∆°n */
        #game-log {
            position: fixed;
            bottom: 30%;
            left: 50%;
            transform: translateX(-50%);
            width: auto;
            max-width: 90%;
            padding: 0.75rem 1.5rem;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            border-radius: var(--border-radius-lg);
            text-align: center;
            font-size: 1rem;
            font-weight: 500;
            z-index: 150;
            animation: fade-in-out-log 4s forwards ease-in-out;
            pointer-events: none;
        }

        @keyframes fade-in-out-log {

            0%,
            100% {
                opacity: 0;
                transform: translate(-50%, 20px);
            }

            15%,
            85% {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        /* Score change animation */
        .score-change {
            position: fixed;
            font-weight: 900;
            font-size: 2rem;
            animation: score-fade-up 1.5s ease-out forwards;
            z-index: 200;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        @keyframes score-fade-up {
            from {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }

            to {
                opacity: 0;
                transform: translate(-50%, -200%) scale(0.8);
            }
        }

        /* CSS cho modal l·ªãch s·ª≠ chi ti·∫øt */
        .detailed-history-content {
            max-height: 60dvh;
            overflow-y: auto;
            text-align: left;
            padding-right: 0.5rem;
            /* Kho·∫£ng tr·ªëng cho thanh cu·ªôn */
        }

        .detailed-history-list {
            list-style: none;
        }

        .detailed-history-list li {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .detailed-history-list li:last-child {
            border-bottom: none;
        }

        .detailed-history-list strong {
            color: var(--accent-primary);
        }

        .detailed-history-list .win-text {
            color: var(--win-color);
            font-weight: 700;
        }

        .detailed-history-list .loss-text {
            color: var(--loss-color);
            font-weight: 700;
        }

        .detailed-history-list .draw-text {
            color: var(--draw-color);
            font-weight: 700;
        }

        /* Th√™m v√†o cu·ªëi ph·∫ßn CSS c·ªßa b·∫°n */
        #confirm-placement-btn {
            position: absolute;
            bottom: 8rem;
            /* V·ªã tr√≠ ph√≠a tr√™n tay b√†i c·ªßa ng∆∞·ªùi ch∆°i */
            left: 50%;
            transform: translateX(-50%);
            z-index: 150;
            width: 200px;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
            /* V√¥ hi·ªáu h√≥a khi ·∫©n */
        }

        #confirm-placement-btn.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(-10px);
            /* Hi·ªáu ·ª©ng tr·ªìi l√™n */
            pointer-events: auto;
            /* K√≠ch ho·∫°t l·∫°i khi hi·ªán */
        }

        /* Th√™m v√†o cu·ªëi ph·∫ßn CSS c·ªßa b·∫°n */
        .card-tooltip {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--bg-surface-1);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md);
            z-index: 100;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            animation: fade-in 0.2s ease;
        }

        .card-tooltip button {
            background: none;
            border: none;
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            cursor: pointer;
            font-size: 0.9rem;
            text-align: left;
            transition: background-color 0.2s ease;
            border-bottom: 1px solid var(--border-color);
        }

        .card-tooltip button:last-child {
            border-bottom: none;
        }

        .card-tooltip button:hover {
            background-color: var(--bg-surface-2);
        }

        .card-selection-grid {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            padding: 1rem;
            max-height: 40vh;
            overflow-y: auto;
            background-color: var(--bg-primary);
            border-radius: var(--border-radius-md);
        }

        .card-selection-grid .card {
            position: static;
            /* Ghi ƒë√® position: absolute ƒë·ªÉ hi·ªÉn th·ªã ƒë√∫ng trong grid */
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .card-selection-grid .card:hover {
            transform: scale(1.05) translateY(-5px);
            z-index: 10;
        }

        /* ============================================= */
        /* 6. T·ªêI ∆ØU GIAO DI·ªÜN L·ªäCH S·ª¨ ƒê·∫§U (FIX)       */
        /* ============================================= */
        .detailed-history-content {
            /* T·ªëi ∆∞u cu·ªôn tr√™n mobile */
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
        }

        /* T√πy ch·ªânh thanh cu·ªôn cho ƒë·∫πp h∆°n */
        .detailed-history-content::-webkit-scrollbar {
            width: 6px;
        }

        .detailed-history-content::-webkit-scrollbar-track {
            background: var(--bg-primary);
            border-radius: 3px;
        }

        .detailed-history-content::-webkit-scrollbar-thumb {
            background-color: var(--bg-surface-2);
            border-radius: 3px;
        }

        .detailed-history-content::-webkit-scrollbar-thumb:hover {
            background-color: var(--accent-primary);
        }

        /* Giao di·ªán m·ªõi cho m·ªói d√≤ng l·ªãch s·ª≠ */
        .history-item {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .history-item__header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        .history-item__clash {
            display: flex;
            justify-content: space-around;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.2);
            padding: 0.75rem;
            border-radius: var(--border-radius-md);
        }

        .history-item__vs {
            font-size: 1.5rem;
            font-weight: 900;
            color: var(--text-secondary);
        }

        /* Thi·∫øt k·∫ø cho th·∫ª b√†i mini trong l·ªãch s·ª≠ */
        .mini-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            width: 80px;
            /* C·ªë ƒë·ªãnh chi·ªÅu r·ªông */
        }

        .mini-card__symbol {
            font-size: 2rem;
        }

        .mini-card__name {
            font-weight: 500;
            font-size: 0.8rem;
        }

        .mini-card__tags {
            display: flex;
            flex-wrap: wrap;
            /* Cho ph√©p tag xu·ªëng d√≤ng n·∫øu c·∫ßn */
            justify-content: center;
            /* CƒÉn gi·ªØa c√°c tag */
            gap: 0.25rem;
        }

        .mini-card__tag {
            font-size: 0.65rem;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 4px;
            color: black;
        }

        .tag--attacker {
            background-color: var(--loss-color);
            color: white;
        }

        .tag--defender {
            background-color: var(--accent-primary);
            color: white;
        }

        .tag--priority {
            background-color: #ffc107;
        }

        .tag--special {
            background-color: #03a9f4;
        }

        /* Ghi ch√∫ tƒÉng ƒëi·ªÉm */
        .point-increase-note {
            text-align: center;
            font-size: 0.85rem;
            font-style: italic;
            color: var(--text-secondary);
            background-color: var(--bg-primary);
            padding: 0.4rem;
            border-radius: 8px;
            margin-top: 0.25rem;
        }

        .point-increase-note strong {
            color: var(--win-color);
        }

        .player-req {
            font-size: 0.8rem;
            font-weight: 800;
            padding: 0.2rem 0.5rem;
            border-radius: 8px;
            background: transparent;
            border: 1px dashed #000000;
            color: #ffffff;
            margin-left: 0.4rem;
            white-space: nowrap;
        }

        .card-selection-grid .card.selected {
            border-color: #ffc107;
            box-shadow: var(--priority-glow);
            transform: scale(1.05) translateY(-5px);
        }

        /* ================================================== */
        /* === CSS B·ªî SUNG CHO L·ªäCH S·ª¨ M·ªöI (06/2024)      === */
        /* ================================================== */

        .mini-card__points {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--accent-primary);
            margin: 0.25rem 0;
        }

        .tag--score-change.win {
            background-color: var(--win-color);
            color: white;
        }

        .tag--score-change.loss {
            background-color: var(--loss-color);
            color: white;
        }

        /* Container cho c√°c tag chung c·ªßa l∆∞·ª£t ƒë·∫•u */
        .history-item__tags {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        /* Tag cho vi·ªác tƒÉng ƒëi·ªÉm c∆° b·∫£n */
        .tag--points-up {
            background-color: #ffc107;
            color: black;
        }

        .draw-text {
            color: var(--draw-color);
            background-color: var(--bg-surface-2);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 700;
        }

        .win-text {
            color: white;
            background-color: var(--win-color);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 700;
        }

        .loss-text {
            color: white;
            background-color: var(--loss-color);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 700;
        }

        /* X√≥a b·ªè ph·∫ßn ghi ch√∫ c≈© ƒë·ªÉ thay b·∫±ng tag */
        .point-increase-note {
            display: none;
        }

        /* ================================================== */
        /* === CSS B·ªî SUNG CHO CH·∫æ ƒê·ªò PVP (M·ªöI)           === */
        /* ================================================== */

        /* Style cho m√†n h√¨nh ch·ªù chuy·ªÉn l∆∞·ª£t */
        #turn-handoff-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-primary);
            z-index: 9999;
            display: none;
            /* M·∫∑c ƒë·ªãnh ·∫©n ƒëi */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 2rem;
            animation: fade-in 0.3s ease;
        }

        #turn-handoff-overlay h1 {
            font-size: 2rem;
            color: var(--accent-primary);
            margin-bottom: 1rem;
        }

        #turn-handoff-overlay p {
            font-size: 1.1rem;
            margin-bottom: 2rem;
            max-width: 400px;
        }
    </style>
</head>

<body>

    <div id="turn-handoff-overlay">
        <h1 id="handoff-player-name">L∆∞·ª£t c·ªßa Ng∆∞·ªùi Ch∆°i X</h1>

        <p id="handoff-last-action" style="display: none; font-style: italic; color: var(--text-secondary); border: 1px solid var(--border-color); padding: 0.75rem; border-radius: 8px; margin-bottom: 1.5rem; max-width: 400px;"></p>

        <p>H√£y ƒë·∫£m b·∫£o ƒë·ªëi th·ªß kh√¥ng nh√¨n v√†o m√†n h√¨nh. <br />Khi b·∫°n ƒë√£ s·∫µn s√†ng, h√£y nh·∫•n n√∫t b√™n d∆∞·ªõi.</p>
        <button id="handoff-start-turn-btn" class="btn">B·∫Øt ƒê·∫ßu L∆∞·ª£t</button>
    </div>
    <div id="player-name-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2>Nh·∫≠p T√™n Ng∆∞·ªùi Ch∆°i</h2>
            <div id="player-name-inputs" style="display: flex; flex-direction: column; gap: 1rem;">
            </div>
            <div class="modal-options">
                <button id="start-game-btn" class="btn">B·∫Øt ƒê·∫ßu</button>
            </div>
        </div>
    </div>

    <div id="game-mode-modal" class="modal-overlay">
        <div class="modal-content">
            <div id="continue-game-section" style="display: none; margin-bottom: 1rem; text-align: center;">
                <p style="margin-bottom: 0.5rem; color: var(--text-secondary);">B·∫°n c√≥ m·ªôt m√†n ch∆°i ƒëang dang d·ªü:</p>
                <button id="continue-btn" class="btn"></button>
                <hr style="border-color: var(--border-color); margin: 1rem 0;">
            </div>
            <h2>Ch·ªçn Ch·∫ø ƒê·ªô Ch∆°i</h2>
            <p>B·∫°n mu·ªën ch∆°i theo ch·∫ø ƒë·ªô n√†o?</p>
            <div class="modal-options">
                <button id="pvai-btn" class="btn">ü§ñ Ch∆°i v·ªõi M√°y</button>
                <button id="pvp-btn" class="btn btn-secondary">üßë‚Äçü§ù‚Äçüßë Ch∆°i 2 Ng∆∞·ªùi</button>
            </div>
        </div>
    </div>
    <div id="game-container">
        <div id="game-container">
            <!-- KHU V·ª∞C ƒê·ªêI TH·ª¶ -->
            <div id="opponent-area" class="player-area">
                <div id="opponent-hand" class="hand"></div>
                <div class="player-info">
                    <div style="display: flex; align-items: center; gap: 0.75rem">
                        <div id="opponent-score" class="player-score">0</div>
                        <div id="opponent-priority-count" class="player-role">0/2</div>
                    </div>
                    <div class="player-details">
                        <div id="opponent-name" class="player-name">ƒê·ªëi Th·ªß</div>
                    </div>
                </div>
            </div>

            <!-- B·∫¢NG ƒê·∫§U TRUNG T√ÇM -->
            <div id="board">
                <div id="opponent-side-slot" class="card-slot" data-zone="side"></div>
                <div id="opponent-main-slot" class="card-slot" data-zone="main"></div>

                <div id="action-bar" class="card-slot"></div>

                <div id="player-side-slot" class="card-slot" data-zone="side"></div>
                <div id="player-main-slot" class="card-slot" data-zone="main"></div>
            </div>

            <!-- KHU V·ª∞C NG∆Ø·ªúI CH∆†I -->
            <div id="player-area" class="player-area">
                <div class="player-info">
                    <div class="player-details">
                        <div id="player-name" class="player-name">B·∫°n</div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.75rem">
                        <div id="player-priority-count" class="player-role">0/2</div>
                        <div id="player-score" class="player-score">0</div>
                    </div>
                </div>
                <div id="player-hand" class="hand"></div>
            </div>

            <!-- HEADER GAME - ƒê·∫∑t ·ªü cu·ªëi ƒë·ªÉ c√≥ z-index cao h∆°n theo lu·ªìng DOM t·ª± nhi√™n -->
            <div id="game-header">
                <div id="turn-info">V√≤ng 1 - V√°n 1</div>
                <div id="history-trigger">
                    <div id="history-dots">
                        <!-- C√°c ch·∫•m l·ªãch s·ª≠ s·∫Ω ƒë∆∞·ª£c JS render ·ªü ƒë√¢y -->
                    </div>
                    <span style="font-size: 0.8rem; color: var(--text-secondary)">Xem</span>
                </div>
            </div>
            <button id="confirm-placement-btn" class="btn" style="display: none">
                X√°c Nh·∫≠n
            </button>
        </div>
        <!-- Container cho c√°c ph·∫ßn t·ª≠ ƒë·ªông nh∆∞ modal, th√¥ng b√°o -->
        <div id="dynamic-elements-container"></div>

        <script>
            /* ================================================================== */
            /* S·ª¨A ƒê·ªîI DOM ELEMENTS ƒê·ªÇ TR·ªé ƒê·∫æN C√ÅC ID V√Ä CLASS M·ªöI               */
            /* ================================================================== */
            const DOMElements = {
                player: {
                    hand: document.getElementById("player-hand"),
                    score: document.getElementById("player-score"),
                    role: document.getElementById("player-role"),
                    priorityCount: document.getElementById("player-priority-count"),
                },
                opponent: {
                    hand: document.getElementById("opponent-hand"),
                    score: document.getElementById("opponent-score"),
                    role: document.getElementById("opponent-role"),
                    priorityCount: document.getElementById("opponent-priority-count"),
                },
                board: {
                    // ƒê·ªïi t√™n t·ª´ battlefield
                    mainLane: document.getElementById("main-lane"),
                    sideLane: document.getElementById("side-lane"),
                    opponentMainSlot: document.getElementById("opponent-main-slot"),
                    opponentSideSlot: document.getElementById("opponent-side-slot"),
                    playerMainSlot: document.getElementById("player-main-slot"), // ƒê·ªïi t√™n
                    playerSideSlot: document.getElementById("player-side-slot"), // ƒê·ªïi t√™n
                },
                header: {
                    // Th√™m m·ª•c m·ªõi
                    turnInfo: document.getElementById("turn-info"),
                    historyTrigger: document.getElementById("history-trigger"),
                    historyDots: document.getElementById("history-dots"),
                },
                dynamicContainer: document.getElementById("dynamic-elements-container"),
            };

            // Gi·ªØ t√™n bi·∫øn c≈© trong logic game ƒë·ªÉ tr√°nh ph·∫£i s·ª≠a nhi·ªÅu
            // Ch·ªâ c·∫ßn √°nh x·∫° l·∫°i ·ªü ƒë√¢y
            DOMElements.battlefield = {
                ...DOMElements.board,
                mainZone: DOMElements.board.mainLane, // √Ånh x·∫° t√™n c≈©
                sideZone: DOMElements.board.sideLane, // √Ånh x·∫° t√™n c≈©
                attackerMainSlot: DOMElements.board.playerMainSlot, // M·∫∑c ƒë·ªãnh attacker l√† player
                attackerSideSlot: DOMElements.board.playerSideSlot, // M·∫∑c ƒë·ªãnh attacker l√† player
            };

            /* ================================================================== */
            /* PH·∫¶N LOGIC GAME (JAVASCRIPT) - Ch·ªâ s·ª≠a nh·ªØng ph·∫ßn li√™n quan ƒë·∫øn    */
            /* render v√† DOM, gi·ªØ nguy√™n c·ªët l√µi game.                            */
            /* ================================================================== */

            const CARD_TYPES = {
                BUA: "B√∫a",
                KEO: "K√©o",
                BAO: "Bao"
            };
            const SPECIAL_CARDS = {
                WIN: "Lu√¥n Th·∫Øng",
                LOSE: "Lu√¥n Thua"
            };
            const ROLES = {
                ATTACKER: "T·∫•n C√¥ng",
                DEFENDER: "Ph√≤ng Th·ªß"
            };
            // THAY TH·∫æ KH·ªêI H·∫∞NG S·ªê PHASES
            const PHASES = {
                START_TURN: "START_TURN",
                CHECK_DRAW: "CHECK_DRAW",
                ROLE_SELECTION: "ROLE_SELECTION",
                DEFENDER_PLACE_CARDS: "DEFENDER_PLACE_CARDS",
                ATTACKER_CHOOSE_CARD: "ATTACKER_CHOOSE_CARD",
                // --- TH√äM 2 GIAI ƒêO·∫†N M·ªöI, X√ìA FINAL_DECISION ---
                DEFENDER_SWAP_CHOICE: "DEFENDER_SWAP_CHOICE",
                ATTACKER_SWAP_CHOICE: "ATTACKER_SWAP_CHOICE",
                RESOLUTION: "RESOLUTION",
                GAME_OVER: "GAME_OVER",
            };
            const ZONES = {
                MAIN: "main",
                SIDE: "side"
            };
            const SYMBOLS = {
                B√∫a: "‚úä",
                K√©o: "‚úåÔ∏è",
                Bao: "‚úã",
                "Lu√¥n Th·∫Øng": "üëë",
                "Lu√¥n Thua": "üè≥Ô∏è",
            };
            let gameState = {};
            let dragState = {
                isDragging: false,
                draggedElement: null,
                cardData: null,
                offsetX: 0,
                offsetY: 0,
            };

            class Game {
                constructor() {
                    this.gameMode = null; // Th√™m bi·∫øn m·ªõi ƒë·ªÉ l∆∞u ch·∫ø ƒë·ªô ch∆°i
                    this.activePlayerId = 0; // Th√™m bi·∫øn m·ªõi ƒë·ªÉ bi·∫øt ai ƒëang ch∆°i ·ªü d∆∞·ªõi
                }
                init(mode, name1, name2) {
                    this.gameMode = mode;
                    console.log(`Game started in ${this.gameMode} mode.`);

                    gameState = {
                        round: 0,
                        turn: 0,
                        phase: null,
                        players: [{
                                id: 0,
                                name: name1,
                                score: 0,
                                isAI: false, // Lu√¥n l√† ng∆∞·ªùi
                                hand: [],
                                specialCardsUsed: {
                                    [SPECIAL_CARDS.WIN]: false,
                                    [SPECIAL_CARDS.LOSE]: false,
                                },
                                priorityUsedThisRound: 0,
                            },
                            {
                                id: 1,
                                name: name2,
                                score: 0,
                                // S·ª¨A ƒê·ªîI QUAN TR·ªåNG:
                                isAI: this.gameMode === 'pvai', // Ch·ªâ l√† AI n·∫øu ch·∫ø ƒë·ªô l√† pvai
                                hand: [],
                                specialCardsUsed: {
                                    [SPECIAL_CARDS.WIN]: false,
                                    [SPECIAL_CARDS.LOSE]: false,
                                },
                                priorityUsedThisRound: 0,
                            },
                        ],
                        cardBasePoints: {
                            [CARD_TYPES.BUA]: 1,
                            [CARD_TYPES.KEO]: 1,
                            [CARD_TYPES.BAO]: 1,
                        },
                        commonDeck: [],
                        battlefield: {
                            main: {
                                defenderCard: null,
                                attackerCard: null
                            },
                            side: {
                                defenderCard: null,
                                attackerCard: null
                            },
                        },
                        currentAttackerId: null,
                        currentDefenderId: null,
                        attackerCardChoice: null,
                        attackerZoneChoice: null,
                        detailedHistory: [],
                        lastTurnWinnerId: null,
                    };

                    [0, 1].forEach((playerId) => {
                        const player = gameState.players[playerId];
                        Object.values(CARD_TYPES).forEach((type) => {
                            player.hand.push(this.createCard(type, true));
                            player.hand.push(this.createCard(type, false));
                        });
                        player.hand.push(this.createCard(SPECIAL_CARDS.WIN, false, true));
                        player.hand.push(this.createCard(SPECIAL_CARDS.LOSE, false, true));
                    });
                    if (this.gameMode === 'pvai') {
                        gameState.players[0].name = "B·∫°n";
                        gameState.players[1].name = "ƒê·ªëi Th·ªß";
                    }
                    DOMElements.header.historyTrigger.onclick = () =>
                        this.showDetailedHistoryModal();
                    this.startRound();
                    document.getElementById("confirm-placement-btn").onclick = () =>
                        this.confirmAction();
                    this.saveGameState();
                }
                // TH√äM 3 H√ÄM M·ªöI N√ÄY V√ÄO B·∫§T K·ª≤ ƒê√ÇU TRONG CLASS GAME

                saveGameState() {
                    if (!gameState || gameState.phase === PHASES.GAME_OVER) return;

                    // Quan tr·ªçng: L∆∞u c·∫£ c√°c thu·ªôc t√≠nh c·ªßa class Game
                    const stateToSave = {
                        ...gameState,
                        gameMode: this.gameMode,
                        activePlayerId: this.activePlayerId
                    };
                    localStorage.setItem('savedGame', JSON.stringify(stateToSave));
                    console.log("Game state saved.");
                }

                resumeGame(savedState) {
                    // T·∫£i l·∫°i to√†n b·ªô tr·∫°ng th√°i
                    gameState = savedState;
                    this.gameMode = savedState.gameMode;
                    this.activePlayerId = savedState.activePlayerId;

                    // G·∫Øn l·∫°i c√°c s·ª± ki·ªán
                    DOMElements.header.historyTrigger.onclick = () => this.showDetailedHistoryModal();
                    document.getElementById("confirm-placement-btn").onclick = () => this.confirmAction();

                    console.log("Game resumed from phase:", gameState.phase);

                    // Render l·∫°i giao di·ªán v√† k√≠ch ho·∫°t l·∫°i logic c·ªßa phase hi·ªán t·∫°i
                    this.render();
                    this.reEngagePhase(gameState.phase);
                }

                reEngagePhase(phase) {
                    // H√†m n√†y k√≠ch ho·∫°t l·∫°i c√°c l·ªùi nh·∫Øc ho·∫∑c n√∫t b·∫•m c·ªßa phase hi·ªán t·∫°i
                    // m√† kh√¥ng ch·∫°y l·∫°i to√†n b·ªô logic ph·ª©c t·∫°p c·ªßa setPhase.
                    const defender = this.getCurrentDefender();
                    const attacker = this.getCurrentAttacker();

                    switch (phase) {
                        case PHASES.ROLE_SELECTION:
                            this.handleRoleSelection();
                            break;
                        case PHASES.DEFENDER_PLACE_CARDS:
                            if (!defender.isAI) {
                                this.log("Ph√≤ng Th·ªß: K√©o 2 l√° b√†i v√†o 2 khu v·ª±c.");
                                if (gameState.battlefield.main.defenderCard && gameState.battlefield.side.defenderCard) {
                                    this.showConfirmButton(true);
                                }
                            } else {
                                this.setPhase(phase); // AI c·∫ßn ch·∫°y l·∫°i logic
                            }
                            break;
                        case PHASES.ATTACKER_CHOOSE_CARD:
                            if (!attacker.isAI) {
                                this.log("T·∫•n C√¥ng: K√©o 1 l√° b√†i v√†o khu v·ª±c mu·ªën t·∫•n c√¥ng.");
                                if (gameState.attackerCardChoice) {
                                    this.showConfirmButton(true);
                                }
                            } else {
                                this.setPhase(phase); // AI c·∫ßn ch·∫°y l·∫°i logic
                            }
                            break;
                        case PHASES.DEFENDER_SWAP_CHOICE:
                            this.handleDefenderSwapChoice();
                            break;
                        case PHASES.ATTACKER_SWAP_CHOICE:
                            this.handleAttackerSwapChoice();
                            break;
                        default:
                            // C√°c phase kh√°c s·∫Ω t·ª± ƒë·ªông ti·∫øp di·ªÖn ho·∫∑c kh√¥ng c·∫ßn t∆∞∆°ng t√°c
                            break;
                    }
                }
                // THAY TH·∫æ TO√ÄN B·ªò H√ÄM N√ÄY
                async showTurnHandoff(nextPlayerId) {
                    // Ch·ªâ hi·ªÉn th·ªã m√†n h√¨nh n√†y ·ªü ch·∫ø ƒë·ªô PvP v√† khi l∆∞·ª£t ch∆°i th·ª±c s·ª± thay ƒë·ªïi
                    if (this.gameMode !== 'pvp' || this.activePlayerId === nextPlayerId) {
                        // X√≥a th√¥ng tin c≈© n·∫øu kh√¥ng hi·ªÉn th·ªã m√†n h√¨nh ch·ªù
                        if (gameState.lastTurnActionInfo) {
                            gameState.lastTurnActionInfo = null;
                        }
                        return;
                    }

                    const handoffScreen = document.getElementById('turn-handoff-overlay');
                    const playerNameEl = document.getElementById('handoff-player-name');
                    const startBtn = document.getElementById('handoff-start-turn-btn');

                    const lastActionEl = document.getElementById('handoff-last-action');

                    this.activePlayerId = nextPlayerId;
                    const nextPlayer = this.getPlayer(nextPlayerId);
                    playerNameEl.textContent = `L∆∞·ª£t c·ªßa ${nextPlayer.name}`;


                    if (gameState.lastTurnActionInfo) {
                        lastActionEl.textContent = `Ghi ch√∫: ${gameState.lastTurnActionInfo}`;
                        lastActionEl.style.display = 'block';
                    } else {
                        lastActionEl.style.display = 'none';
                    }

                    gameState.lastTurnActionInfo = null;

                    return new Promise(resolve => {
                        const onStartClick = () => {
                            handoffScreen.style.display = 'none';
                            this.render();
                            startBtn.removeEventListener('click', onStartClick);
                            resolve();
                        };
                        handoffScreen.style.display = 'flex';
                        startBtn.addEventListener('click', onStartClick);
                    });
                }

                showPrioritySelectionModal(player, drawnCards, neededCount) {
                    const overlay = document.createElement("div");
                    overlay.className = "modal-overlay";

                    let selectedCards = [];

                    let cardsHTML = '<div class="card-selection-grid">';
                    drawnCards.forEach((card, index) => {
                        const cardEl = this.createCardElement(card);
                        // G·∫Øn d·ªØ li·ªáu index v√†o element ƒë·ªÉ x·ª≠ l√Ω click
                        cardEl.dataset.cardIndex = index;
                        cardsHTML += cardEl.outerHTML;
                    });
                    cardsHTML += "</div>";

                    const modal = document.createElement("div");
                    modal.className = "modal-content";
                    modal.innerHTML = `
                <h2>Ch·ªâ ƒê·ªãnh Th·∫ª ∆Øu Ti√™n</h2>
                <p>B·∫°n c·∫ßn ch·ªçn <strong>${neededCount}</strong> l√° b√†i ƒë·ªÉ tr·ªü th√†nh Th·∫ª ∆Øu Ti√™n.</p>
                ${cardsHTML}
                <div class="modal-options">
                    <button id="confirm-priority-btn" class="btn" disabled>X√°c Nh·∫≠n</button>
                </div>
            `;

                    overlay.appendChild(modal);
                    DOMElements.dynamicContainer.appendChild(overlay);

                    const confirmBtn = modal.querySelector("#confirm-priority-btn");
                    const cardElements = modal.querySelectorAll(".card");

                    cardElements.forEach((cardEl) => {
                        cardEl.onclick = () => {
                            const cardIndex = parseInt(cardEl.dataset.cardIndex);
                            const cardData = drawnCards[cardIndex];

                            const selectedIndex = selectedCards.findIndex(
                                (c) => c.id === cardData.id
                            );

                            if (selectedIndex > -1) {
                                // N·∫øu ƒë√£ ch·ªçn, b·ªè ch·ªçn
                                selectedCards.splice(selectedIndex, 1);
                                cardEl.classList.remove("selected");
                            } else {
                                // N·∫øu ch∆∞a ch·ªçn, ki·ªÉm tra n·∫øu c√≥ th·ªÉ ch·ªçn th√™m
                                if (selectedCards.length < neededCount) {
                                    selectedCards.push(cardData);
                                    cardEl.classList.add("selected");
                                }
                            }

                            // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t x√°c nh·∫≠n
                            if (selectedCards.length === neededCount) {
                                confirmBtn.disabled = false;
                            } else {
                                confirmBtn.disabled = true;
                            }
                        };
                    });

                    confirmBtn.onclick = () => {
                        // ƒê√°nh d·∫•u c√°c l√° b√†i ƒë√£ ch·ªçn l√† ∆∞u ti√™n
                        selectedCards.forEach((selectedCard) => {
                            const cardInDrawn = drawnCards.find(
                                (c) => c.id === selectedCard.id
                            );
                            if (cardInDrawn) {
                                cardInDrawn.isPriority = true;
                            }
                        });

                        // Th√™m t·∫•t c·∫£ c√°c l√° b√†i ƒë√£ b·ªëc v√†o tay ng∆∞·ªùi ch∆°i
                        player.hand.push(...drawnCards);

                        this.log(`B·∫°n ƒë√£ ch·ªâ ƒë·ªãnh ${neededCount} Th·∫ª ∆Øu Ti√™n m·ªõi.`);
                        overlay.remove(); // ƒê√≥ng modal

                        // G·ªçi h√†m x·ª≠ l√Ω ti·∫øp theo
                        this.handlePostDraw(player);
                    };
                }
                render(options = {
                    updateBattlefield: true
                }) {
                    const player = this.getPlayer(this.activePlayerId);
                    const opponent = this.getPlayer(this.activePlayerId === 0 ? 1 : 0);

                    const playerInfoEl = document.getElementById("player-area").querySelector(".player-info");
                    const opponentInfoEl = document.getElementById("opponent-area").querySelector(".player-info");

                    // C·∫≠p nh·∫≠t t√™n
                    document.getElementById("player-name").textContent = player.name;
                    document.getElementById("opponent-name").textContent = opponent.name;

                    // C·∫≠p nh·∫≠t ƒëi·ªÉm v√† c√°c th√¥ng s·ªë kh√°c
                    DOMElements.player.score.textContent = player.score;
                    DOMElements.opponent.score.textContent = opponent.score;

                    const playerPriorityEl = DOMElements.player.priorityCount;
                    const opponentPriorityEl = DOMElements.opponent.priorityCount;

                    // Lu√¥n hi·ªÉn th·ªã b·ªô ƒë·∫øm c·ªßa ng∆∞·ªùi ch∆°i ƒëang active (·ªü d∆∞·ªõi)
                    playerPriorityEl.textContent = `${player.priorityUsedThisRound || 0}/2`;
                    playerPriorityEl.style.visibility = 'visible';

                    // Lu√¥n ·∫©n b·ªô ƒë·∫øm c·ªßa ƒë·ªëi ph∆∞∆°ng (·ªü tr√™n)
                    // D√πng visibility ƒë·ªÉ ·∫©n nh∆∞ng v·∫´n gi·ªØ nguy√™n b·ªë c·ª•c
                    opponentPriorityEl.textContent = `${opponent.priorityUsedThisRound || 0}/2`; // V·∫´n c·∫≠p nh·∫≠t s·ªë li·ªáu ·∫©n
                    opponentPriorityEl.style.visibility = 'hidden';

                    // Logic hi·ªÉn th·ªã vai tr√≤ (T·∫•n C√¥ng/Ph√≤ng Th·ªß)
                    const setupRoleClass = (infoEl, p) => {
                        infoEl.classList.remove("role-attacker", "role-defender");
                        if (p.id === gameState.currentAttackerId) {
                            infoEl.classList.add("role-attacker");
                        } else if (p.id === gameState.currentDefenderId) {
                            infoEl.classList.add("role-defender");
                        }
                    };
                    setupRoleClass(playerInfoEl, player);
                    setupRoleClass(opponentInfoEl, opponent);

                    const ensureReqBadge = (who) => {
                        const wrap =
                            who === 0 ?
                            document.getElementById("player-priority-count").parentElement :
                            document.getElementById("opponent-priority-count")
                            .parentElement;
                        let req = wrap.querySelector(".player-req");
                        const isDefender = who === gameState.currentDefenderId;
                        const showPhases = [PHASES.CHECK_DRAW, PHASES.DEFENDER_PLACE_CARDS];
                        const shouldShow =
                            isDefender && showPhases.includes(gameState.phase);
                        if (!req) {
                            req = document.createElement("span");
                            req.className = "player-req";
                            req.textContent = "C·∫ßn ‚â•1 ∆ØT";
                            wrap.appendChild(req);
                        }
                        req.style.display = shouldShow ? "inline-block" : "none";
                    };
                    const updateReqBadge = (p, priorityCountElement) => {
                        const wrapper = priorityCountElement.parentElement;
                        let reqBadge = wrapper.querySelector(".player-req");

                        // ƒêi·ªÅu ki·ªán ƒë·ªÉ hi·ªÉn th·ªã: ng∆∞·ªùi ch∆°i n√†y ph·∫£i l√† Ph√≤ng Th·ªß V√Ä ƒëang ·ªü ƒë√∫ng giai ƒëo·∫°n
                        const isDefender = p.id === gameState.currentDefenderId;
                        const correctPhase = [PHASES.CHECK_DRAW, PHASES.DEFENDER_PLACE_CARDS].includes(gameState.phase);
                        const shouldShow = isDefender && correctPhase;

                        if (!reqBadge) {
                            reqBadge = document.createElement("span");
                            reqBadge.className = "player-req";
                            reqBadge.textContent = "C·∫ßn ‚â•1 ∆ØT";
                            // Th√™m v√†o tr∆∞·ªõc b·ªô ƒë·∫øm ƒë·ªÉ giao di·ªán ƒë·∫πp h∆°n
                            wrapper.insertBefore(reqBadge, priorityCountElement);
                        }

                        reqBadge.style.display = shouldShow ? "inline-block" : "none";
                    };

                    // √Åp d·ª•ng logic cho c·∫£ ng∆∞·ªùi ch∆°i ƒëang active (·ªü d∆∞·ªõi) v√† ƒë·ªëi th·ªß (·ªü tr√™n)
                    updateReqBadge(player, DOMElements.player.priorityCount);
                    updateReqBadge(opponent, DOMElements.opponent.priorityCount);

                    // Render tay b√†i
                    this.renderHandLayout(player, DOMElements.player.hand);
                    this.renderHandLayout(opponent, DOMElements.opponent.hand, true); // Tay ƒë·ªëi th·ªß lu√¥n √∫p

                    if (options.updateBattlefield) {
                        this.renderBattlefield();
                    }
                    this.updateGameInfo();
                    this.renderHistoryBar();
                }
                // D√°n h√†m M·ªöI n√†y v√†o trong class Game
                updateActionBar(content = "") {
                    const actionBar = document.getElementById("action-bar");
                    if (!actionBar) return;

                    // X√≥a n·ªôi dung c≈© v√† listener (n·∫øu c√≥)
                    actionBar.innerHTML = "";

                    if (typeof content === 'string' && content) {
                        // N·∫øu l√† text, ch·ªâ c·∫ßn hi·ªÉn th·ªã text
                        actionBar.innerHTML = `<p class="action-bar__text">${content}</p>`;
                    } else if (typeof content === 'object' && content) {
                        // N·∫øu l√† object (d√†nh cho n√∫t)
                        const fragment = document.createDocumentFragment();
                        content.options.forEach((opt, index) => {
                            const btn = document.createElement("button");
                            btn.className = index === 0 ? "btn" : "btn btn-secondary";
                            btn.textContent = opt.text;
                            btn.onclick = () => {
                                this.updateActionBar(); // X√≥a n√∫t sau khi b·∫•m
                                content.onSelect(opt.value);
                            };
                            fragment.appendChild(btn);
                        });
                        actionBar.appendChild(fragment);
                    }
                }
                renderHandLayout(player, container, isOpponent = false) {
                    container.innerHTML = "";
                    const cards = player.hand;

                    // --- B·∫ÆT ƒê·∫¶U PH·∫¶N TH√äM M·ªöI ---
                    // 1. T·∫°o m·ªôt h√†m nh·ªè ƒë·ªÉ x√°c ƒë·ªãnh "ƒë·ªô ∆∞u ti√™n" s·∫Øp x·∫øp c·ªßa th·∫ª
                    const getCardSortWeight = (card) => {
                        if (card.isPriority) return 1; // ∆Øu ti√™n x·∫øp ƒë·∫ßu ti√™n
                        if (card.isSpecial) return 3; // ƒê·∫∑c bi·ªát x·∫øp cu·ªëi c√πng
                        return 2; // Th∆∞·ªùng (kh√¥ng ∆∞u ti√™n, kh√¥ng ƒë·∫∑c bi·ªát) x·∫øp ·ªü gi·ªØa
                    };

                    // 2. S·∫Øp x·∫øp m·∫£ng th·∫ª d·ª±a tr√™n tr·ªçng s·ªë ƒë√£ ƒë·ªãnh nghƒ©a
                    const sortedCards = [...cards].sort(
                        (a, b) => getCardSortWeight(a) - getCardSortWeight(b)
                    );
                    // --- K·∫æT TH√öC PH·∫¶N TH√äM M·ªöI ---

                    // S·ª¨A L·∫†I C√ÅC D√íNG D∆Ø·ªöI ƒê√ÇY ƒê·ªÇ D√ôNG M·∫¢NG ƒê√É S·∫ÆP X·∫æP
                    const cardCount = sortedCards.length; // D√πng sortedCards
                    if (cardCount === 0) return;

                    const rootFontSize = parseFloat(
                        getComputedStyle(document.documentElement).fontSize
                    );
                    const cardWidthRem = 4.2;
                    const overlapRem = 2.8;
                    const cardWidthPx = cardWidthRem * rootFontSize;
                    const overlapPx = overlapRem * rootFontSize;
                    const totalWidth =
                        cardWidthPx +
                        (cardCount > 1 ? (cardCount - 1) * (cardWidthPx - overlapPx) : 0);
                    const startX = (container.offsetWidth - totalWidth) / 2;

                    sortedCards.forEach((card, i) => {
                        // D√πng sortedCards
                        const cardEl = this.createCardElement(card, isOpponent);
                        cardEl.dataset.cardId = card.id;
                        cardEl.style.left = `${startX + i * (cardWidthPx - overlapPx)}px`;
                        cardEl.style.zIndex = i;
                        if (!isOpponent) {
                            let isDraggable =
                                (gameState.phase === PHASES.DEFENDER_PLACE_CARDS &&
                                    player.id === gameState.currentDefenderId) ||
                                (gameState.phase === PHASES.ATTACKER_CHOOSE_CARD &&
                                    player.id === gameState.currentAttackerId);
                            let touchTimeout;

                            // S·ª± ki·ªán khi b·∫Øt ƒë·∫ßu ch·∫°m v√†o l√° b√†i
                            const handleTouchStart = (e) => {
                                // ƒê·∫∑t m·ªôt b·ªô ƒë·∫øm th·ªùi gian ng·∫Øn. N·∫øu ng∆∞·ªùi d√πng gi·ªØ tay ƒë·ªß l√¢u, l√° b√†i s·∫Ω ph√≥ng to.
                                touchTimeout = setTimeout(() => {
                                    // Lo·∫°i b·ªè hi·ªáu ·ª©ng n√†y tr√™n c√°c l√° b√†i kh√°c
                                    document.querySelectorAll('#player-hand .card.touch-peek').forEach(c => c.classList.remove('touch-peek'));
                                    // Th√™m hi·ªáu ·ª©ng cho l√° b√†i ƒëang ch·∫°m
                                    cardEl.classList.add('touch-peek');
                                }, 150); // 150ms l√† m·ªôt kho·∫£ng th·ªùi gian h·ª£p l√Ω
                            };

                            // S·ª± ki·ªán khi nh·∫•c ng√≥n tay ra
                            const handleTouchEnd = (e) => {
                                // X√≥a b·ªô ƒë·∫øm th·ªùi gian ƒë·ªÉ ngƒÉn vi·ªác ph√≥ng to n·∫øu nh·∫•c tay ra qu√° nhanh
                                clearTimeout(touchTimeout);
                                // Lo·∫°i b·ªè hi·ªáu ·ª©ng ph√≥ng to
                                setTimeout(() => {
                                    cardEl.classList.remove('touch-peek');
                                }, 200); // Gi·ªØ hi·ªáu ·ª©ng th√™m 1 ch√∫t cho m∆∞·ª£t
                            };

                            // --- FIX: LOGIC V√î HI·ªÜU H√ìA TH·∫∫ (CHO C·∫¢ 2 VAI TR√í) ---
                            const bf = gameState.battlefield;
                            // √Åp d·ª•ng gi·ªõi h·∫°n 2 th·∫ª ∆∞u ti√™n cho c·∫£ T·∫•n C√¥ng v√† Ph√≤ng Th·ªß
                            if (card.isPriority && (player.priorityUsedThisRound || 0) >= 2) {
                                isDraggable = false;
                            }

                            // Logic ri√™ng cho ng∆∞·ªùi Ph√≤ng Th·ªß: N·∫øu ƒë√£ ƒë·∫∑t 1 th·∫ª th∆∞·ªùng, th·∫ª ti·∫øp theo ph·∫£i l√† ∆∞u ti√™n
                            if (
                                isDraggable &&
                                gameState.phase === PHASES.DEFENDER_PLACE_CARDS
                            ) {
                                const mainCard = bf.main.defenderCard;
                                const sideCard = bf.side.defenderCard;
                                const oneNormalCardPlaced =
                                    (mainCard && !sideCard && !mainCard.isPriority) ||
                                    (sideCard && !mainCard && !sideCard.isPriority);

                                if (oneNormalCardPlaced && !card.isPriority) {
                                    isDraggable = false;
                                }
                            }
                            // --- K·∫æT TH√öC FIX ---

                            if (isDraggable) {
                                // G·∫Øn s·ª± ki·ªán k√©o-th·∫£
                                cardEl.addEventListener("mousedown", (e) => this.dragStart(e, card, cardEl));
                                cardEl.addEventListener("touchstart", (e) => {
                                    // Khi k√©o-th·∫£ tr√™n di ƒë·ªông, x√≥a b·ªô ƒë·∫øm xem b√†i ƒë·ªÉ tr√°nh xung ƒë·ªôt
                                    clearTimeout(touchTimeout);
                                    this.dragStart(e, card, cardEl)
                                }, {
                                    passive: false
                                });
                                cardEl.addEventListener("touchstart", handleTouchStart, {
                                    passive: true
                                });
                                cardEl.addEventListener("touchend", handleTouchEnd);

                            } else {
                                cardEl.classList.add("disabled");
                            }
                        }
                        container.appendChild(cardEl);
                    });
                }
                showConfirmButton(visible) {
                    if (visible) {
                        this.updateActionBar({
                            options: [{
                                text: "X√°c Nh·∫≠n",
                                value: 'confirm'
                            }],
                            onSelect: () => this.confirmAction()
                        });
                    } else {
                        // X√≥a n√∫t x√°c nh·∫≠n v√† ƒë·ªÉ l·∫°i th√¥ng b√°o g·∫ßn nh·∫•t n·∫øu c√≥
                        const currentText = document.querySelector('.action-bar__text');
                        if (!currentText) {
                            this.updateActionBar(); // Ch·ªâ x√≥a n·∫øu kh√¥ng c√≥ text
                        }
                    }
                }

                // H√†m x·ª≠ l√Ω khi nh·∫•n n√∫t x√°c nh·∫≠n
                confirmAction() {
                    this.showConfirmButton(false);
                    if (gameState.phase === PHASES.DEFENDER_PLACE_CARDS) {
                        this.log("B·∫°n ƒë√£ x√°c nh·∫≠n v·ªã tr√≠ c√°c l√° b√†i.");
                        this.removeCardInteractions(); // V√¥ hi·ªáu h√≥a t∆∞∆°ng t√°c v·ªõi th·∫ª th·ªß
                        this.setPhase(PHASES.ATTACKER_CHOOSE_CARD);
                    } else if (gameState.phase === PHASES.ATTACKER_CHOOSE_CARD) {
                        this.log("B·∫°n ƒë√£ x√°c nh·∫≠n t·∫•n c√¥ng.");
                        this.setPhase(PHASES.DEFENDER_SWAP_CHOICE);
                    }
                }
                // H√ÄM T·∫†O TH·∫∫ B√ÄI ƒê√É ƒê∆Ø·ª¢C C·∫¨P NH·∫¨T CHO GIAO DI·ªÜN M·ªöI
                createCardElement(
                    card,
                    hide = false,
                    zoneName = null,
                    isDefenderCard = false
                ) {
                    const cardEl = document.createElement("div");
                    cardEl.className = "card";
                    if (hide) cardEl.classList.add("flipped");
                    if (card.isSpecial && !hide) cardEl.classList.add("special");
                    if (card.isPriority && !hide) cardEl.classList.add("priority");

                    const priorityTag = card.isPriority ?
                        '<span class="card-priority-tag">∆ØT</span>' :
                        "";

                    let displayPoints = "";
                    if (card.isBasic || card.isSpecial) {
                        let basePoints = card.isSpecial ?
                            5 :
                            gameState.cardBasePoints[card.type];
                        if (zoneName) {
                            // --- S·ª¨A LOGIC T√çNH ƒêI·ªÇM T·∫†I ƒê√ÇY ---
                            let finalMultiplier;
                            if (card.isPriority) {
                                // B·ªé ƒëi·ªÅu ki·ªán && isDefenderCard
                                // B·∫•t k·ª≥ th·∫ª ∆Øu Ti√™n n√†o c≈©ng ƒë∆∞·ª£c nh√¢n ƒëi·ªÉm cao h∆°n
                                finalMultiplier = zoneName === ZONES.MAIN ? 3 : 2;
                            } else {
                                // Th·∫ª th∆∞·ªùng th√¨ nh√¢n ƒëi·ªÉm b√¨nh th∆∞·ªùng
                                finalMultiplier = zoneName === ZONES.MAIN ? 2 : 1;
                            }
                            displayPoints = basePoints * finalMultiplier;
                            // --- K·∫æT TH√öC PH·∫¶N S·ª¨A ---
                        } else {
                            displayPoints = basePoints;
                        }
                    }
                    const pointHTML = `<span class="card-value">${displayPoints}</span>`;

                    cardEl.innerHTML = `
            <div class="card-face card-front">
                <div class="card-header">
                  <span class="card-name">${card.type}</span>
                  ${priorityTag}
                </div>
                <span class="card-symbol">${SYMBOLS[card.type] || "?"}</span>
                <div class="card-footer">
                  ${pointHTML}
                </div>
            </div>
            <div class="card-face card-back">‚òÖ</div>
          `;
                    return cardEl;
                }
                showCardTooltip(card, zoneName, cardEl) {
                    // X√≥a tooltip c≈© n·∫øu c√≥
                    this.removeTooltip();

                    const tooltip = document.createElement("div");
                    tooltip.id = "card-tooltip";
                    tooltip.className = "card-tooltip";

                    tooltip.innerHTML = `
        <button data-action="return">‚Ü©Ô∏è Tr·∫£ v·ªÅ tay</button>
        <button data-action="swap">üîÑÔ∏è Chuy·ªÉn v·ªã tr√≠</button>
    `;

                    // G·∫Øn tooltip v√†o ch√≠nh th·∫ª b√†i
                    cardEl.style.position = "relative"; // C·∫ßn thi·∫øt ƒë·ªÉ ƒë·ªãnh v·ªã tooltip
                    cardEl.appendChild(tooltip);

                    tooltip.querySelector('[data-action="return"]').onclick = (e) => {
                        e.stopPropagation();
                        this.returnCardToHand(card, zoneName);
                    };

                    tooltip.querySelector('[data-action="swap"]').onclick = (e) => {
                        e.stopPropagation();
                        this.swapDefenderCards();
                    };

                    // Th√™m s·ª± ki·ªán ƒë·ªÉ x√≥a tooltip khi click ra ngo√†i
                    setTimeout(() => {
                        document.addEventListener("click", this.removeTooltip, {
                            once: true,
                        });
                    }, 0);
                }

                removeTooltip() {
                    const existingTooltip = document.getElementById("card-tooltip");
                    if (existingTooltip) {
                        existingTooltip.remove();
                    }
                    document.removeEventListener("click", this.removeTooltip);
                }

                returnCardToHand(card, zoneName) {
                    const player = this.getCurrentDefender();

                    // X√≥a th·∫ª kh·ªèi b√†n ƒë·∫•u
                    gameState.battlefield[zoneName].defenderCard = null;

                    // Tr·∫£ th·∫ª v·ªÅ tay
                    player.hand.push(card);

                    // C·∫≠p nh·∫≠t l·∫°i b·ªô ƒë·∫øm ∆∞u ti√™n
                    let priorityOnBoard = 0;
                    if (gameState.battlefield.main.defenderCard?.isPriority)
                        priorityOnBoard++;
                    if (gameState.battlefield.side.defenderCard?.isPriority)
                        priorityOnBoard++;
                    player.priorityCardsUsedThisRound = priorityOnBoard;

                    // ·∫®n n√∫t x√°c nh·∫≠n v√¨ ch∆∞a ƒë·∫∑t ƒë·ªß b√†i
                    this.showConfirmButton(false);

                    this.removeTooltip();
                    this.render();
                }

                swapDefenderCards() {
                    const bf = gameState.battlefield;
                    // Ho√°n ƒë·ªïi 2 l√° b√†i
                    [bf.main.defenderCard, bf.side.defenderCard] = [
                        bf.side.defenderCard,
                        bf.main.defenderCard,
                    ];

                    this.removeTooltip();
                    this.render();
                }

                // H√†m ti·ªán √≠ch ƒë·ªÉ x√≥a h·∫øt c√°c event listener tr√™n th·∫ª
                removeCardInteractions() {
                    const playerSlots = [
                        DOMElements.board.playerMainSlot,
                        DOMElements.board.playerSideSlot,
                    ];
                    playerSlots.forEach((slot) => {
                        const cardEl = slot.querySelector(".card");
                        if (cardEl) {
                            // Thay th·∫ø node b·∫±ng b·∫£n clone c·ªßa n√≥ ƒë·ªÉ x√≥a h·∫øt listener
                            cardEl.parentNode.replaceChild(cardEl.cloneNode(true), cardEl);
                        }
                    });
                }
                // THAY TH·∫æ TO√ÄN B·ªò h√†m renderBattlefield() b·∫±ng phi√™n b·∫£n m·ªõi n√†y
                renderBattlefield(flip = false) {
                    const bf = gameState.battlefield;

                    // X√≥a s·∫°ch c√°c slot tr∆∞·ªõc khi render
                    const clearSlot = (slot) => (slot.innerHTML = "");
                    [
                        DOMElements.board.opponentMainSlot,
                        DOMElements.board.opponentSideSlot,
                        DOMElements.board.playerMainSlot,
                        DOMElements.board.playerSideSlot,
                    ].forEach(clearSlot);

                    // H√†m ph·ª• ƒë·ªÉ ƒë·∫∑t th·∫ª, logic kh√¥ng ƒë·ªïi
                    const placeCard = (card, slot, zoneName, isHidden, isDefender) => {
                        if (!card) return;

                        const cardEl = this.createCardElement(
                            card,
                            isHidden,
                            zoneName,
                            isDefender
                        );

                        // Logic th√™m tooltip cho ng∆∞·ªùi ph√≤ng th·ªß kh√¥ng ph·∫£i AI
                        const currentDefender = this.getCurrentDefender();
                        if (
                            currentDefender &&
                            !currentDefender.isAI &&
                            currentDefender.id === this.activePlayerId &&
                            isDefender &&
                            gameState.phase === PHASES.DEFENDER_PLACE_CARDS
                        ) {
                            cardEl.style.cursor = "pointer";
                            cardEl.onclick = (e) => {
                                e.stopPropagation();
                                this.showCardTooltip(card, zoneName, cardEl);
                            };
                        }
                        slot.appendChild(cardEl);
                    };

                    const defender = this.getCurrentDefender();
                    const attacker = this.getCurrentAttacker();

                    // N·∫øu ch∆∞a c√≥ vai tr√≤ th√¨ kh√¥ng render g√¨ c·∫£
                    if (!defender || !attacker) return;

                    // ======================================================================
                    // === THAY ƒê·ªîI C·ªêT L√ïI: LOGIC HI·ªÇN TH·ªä D·ª∞A TR√äN activePlayerId ===
                    // ======================================================================

                    // 1. X√°c ƒë·ªãnh v·ªã tr√≠ ƒë·∫∑t b√†i d·ª±a tr√™n ng∆∞·ªùi ch∆°i active
                    const defenderIsActive = defender.id === this.activePlayerId;
                    const attackerIsActive = attacker.id === this.activePlayerId;

                    const defenderMainSlot = defenderIsActive ? DOMElements.board.playerMainSlot : DOMElements.board.opponentMainSlot;
                    const defenderSideSlot = defenderIsActive ? DOMElements.board.playerSideSlot : DOMElements.board.opponentSideSlot;
                    const attackerMainSlot = attackerIsActive ? DOMElements.board.playerMainSlot : DOMElements.board.opponentMainSlot;
                    const attackerSideSlot = attackerIsActive ? DOMElements.board.playerSideSlot : DOMElements.board.opponentSideSlot;

                    // 2. X√°c ƒë·ªãnh khi n√†o c·∫ßn ·∫©n b√†i ph√≤ng th·ªß
                    // B√†i ph√≤ng th·ªß s·∫Ω b·ªã ·∫©n N·∫æU:
                    //   - Ch∆∞a ƒë·∫øn giai ƒëo·∫°n l·∫≠t b√†i (flip === false)
                    //   - V√Ä ng∆∞·ªùi ƒëang ch∆°i active KH√îNG PH·∫¢I l√† ng∆∞·ªùi ph√≤ng th·ªß.
                    const shouldHideDefenderCards = !flip && !defenderIsActive;

                    // ======================================================================
                    // === K·∫æT TH√öC THAY ƒê·ªîI C·ªêT L√ïI                                      ===
                    // ======================================================================

                    // Render th·∫ª c·ªßa ng∆∞·ªùi Ph√≤ng th·ªß
                    placeCard(
                        bf.main.defenderCard,
                        defenderMainSlot,
                        ZONES.MAIN,
                        shouldHideDefenderCards, // S·ª≠ d·ª•ng bi·∫øn logic m·ªõi
                        true // isDefender
                    );
                    placeCard(
                        bf.side.defenderCard,
                        defenderSideSlot,
                        ZONES.SIDE,
                        shouldHideDefenderCards, // S·ª≠ d·ª•ng bi·∫øn logic m·ªõi
                        true // isDefender
                    );

                    // Render th·∫ª c·ªßa ng∆∞·ªùi T·∫•n c√¥ng (lu√¥n hi·ªán)
                    placeCard(
                        bf.main.attackerCard,
                        attackerMainSlot,
                        ZONES.MAIN,
                        false, // Th·∫ª t·∫•n c√¥ng kh√¥ng bao gi·ªù ·∫©n
                        false // isDefender
                    );
                    placeCard(
                        bf.side.attackerCard,
                        attackerSideSlot,
                        ZONES.SIDE,
                        false, // Th·∫ª t·∫•n c√¥ng kh√¥ng bao gi·ªù ·∫©n
                        false // isDefender
                    );
                }
                showConfirmationBar({
                    text,
                    options,
                    onSelect,
                    isRoleSelection = false
                }) {
                    this.log(text); // Hi·ªÉn th·ªã text tr∆∞·ªõc
                    this.sleep(500).then(() => { // ƒê·ª£i 1 ch√∫t r·ªìi m·ªõi hi·ªán n√∫t
                        this.updateActionBar({
                            options,
                            onSelect: (value) => {
                                let finalValue = value;
                                if (!isRoleSelection && typeof value !== 'boolean') {
                                    finalValue = value === "true";
                                }
                                onSelect(finalValue);
                            }
                        });
                    });
                }
                showInfoModal({
                    title,
                    content,
                    modalClass = ""
                }) {
                    const overlay = document.createElement("div");
                    overlay.className = "modal-overlay";

                    const modal = document.createElement("div");
                    modal.className = `modal-content ${modalClass}`;

                    modal.innerHTML = `
                <h2>${title}</h2>
                <div class="detailed-history-content">${content}</div>
                <div class="modal-options">
                    <button class="btn">ƒê√≥ng</button>
                </div>
            `;
                    overlay.appendChild(modal);
                    DOMElements.dynamicContainer.appendChild(overlay);
                    modal.querySelector(".btn").onclick = () => overlay.remove();
                }

                // H√ÄM RENDER THANH L·ªäCH S·ª¨ ƒê√É ƒê∆Ø·ª¢C C·∫¨P NH·∫¨T
                renderHistoryBar() {
                    DOMElements.header.historyDots.innerHTML = "";
                    // Ch·ªâ hi·ªÉn th·ªã 10 l∆∞·ª£t g·∫ßn nh·∫•t cho g·ªçn
                    const recentHistory = gameState.detailedHistory.slice(-10);
                    recentHistory.forEach((turn) => {
                        const item = document.createElement("div");
                        item.className = "history-dot";
                        if (turn.winnerId === null) item.classList.add("draw");
                        else if (turn.winnerId === 0) item.classList.add("win");
                        else item.classList.add("loss");
                        DOMElements.header.historyDots.appendChild(item);
                    });
                }

                // C·∫¨P NH·∫¨T L·∫†I H√ÄM DRAG-DROP ƒê·ªÇ D√ôNG `data-zone`
                dragEnd(e) {
                    if (!dragState.isDragging) return;
                    document.removeEventListener("mousemove", game.dragging);
                    document.removeEventListener("touchmove", game.dragging);
                    document.removeEventListener("mouseup", game.dragEnd);
                    document.removeEventListener("touchend", game.dragEnd);

                    let droppedOnZone = null;
                    const pointer = e.changedTouches ? e.changedTouches[0] : e;

                    // S·ª¨A ·ªû ƒê√ÇY: L·∫∑p qua c√°c √¥ ng∆∞·ªùi ch∆°i c√≥ th·ªÉ th·∫£ v√†o
                    const dropTargets = [
                        DOMElements.board.playerMainSlot,
                        DOMElements.board.playerSideSlot,
                        // Th√™m 2 √¥ c·ªßa ƒë·ªëi th·ªß ƒë·ªÉ c√≥ hi·ªáu ·ª©ng hover, nh∆∞ng vi·ªác th·∫£ v√†o s·∫Ω do logic game quy·∫øt ƒë·ªãnh
                        DOMElements.board.opponentMainSlot,
                        DOMElements.board.opponentSideSlot,
                    ];

                    dropTargets.forEach((slotEl) => {
                        slotEl.classList.remove("drop-hover");
                        const slotRect = slotEl.getBoundingClientRect();
                        if (
                            pointer.clientX > slotRect.left &&
                            pointer.clientX < slotRect.right &&
                            pointer.clientY > slotRect.top &&
                            pointer.clientY < slotRect.bottom
                        ) {
                            // Ch·ªâ t√≠nh l√† th·∫£ h·ª£p l·ªá v√†o √¥ c·ªßa ng∆∞·ªùi ch∆°i
                            if (
                                slotEl === DOMElements.board.playerMainSlot ||
                                slotEl === DOMElements.board.playerSideSlot
                            ) {
                                droppedOnZone = slotEl.dataset.zone;
                            }
                        }
                    });

                    if (droppedOnZone) {
                        game.handleDrop(dragState.cardData, droppedOnZone);
                    } else {
                        // N·∫øu kh√¥ng th·∫£ v√†o √¥ h·ª£p l·ªá, ph·ª•c h·ªìi ƒë·ªô m·ªù cho l√° b√†i g·ªëc
                        const originalCard = document.querySelector(`#player-hand .card[data-card-id='${dragState.cardData.id}']`); // Gi·∫£ s·ª≠ b·∫°n c√≥ th·ªÉ th√™m data-card-id
                        // Ho·∫∑c c√°ch ƒë∆°n gi·∫£n h∆°n l√† render l·∫°i to√†n b·ªô
                        game.render();
                    }
                    dragState.draggedElement.remove();
                    dragState.isDragging = false;
                    dragState.draggedElement = null;
                    dragState.cardData = null;
                    game.render();
                }
                dragging(e) {
                    if (!dragState.isDragging) return;
                    e.preventDefault();
                    const pointer = e.touches ? e.touches[0] : e;
                    const x = pointer.clientX - dragState.offsetX;
                    const y = pointer.clientY - dragState.offsetY;
                    dragState.draggedElement.style.left = `${x}px`;
                    dragState.draggedElement.style.top = `${y}px`;

                    // S·ª¨A ·ªû ƒê√ÇY: L·∫∑p qua c√°c √¥ ng∆∞·ªùi ch∆°i c√≥ th·ªÉ th·∫£ v√†o ƒë·ªÉ hi·ªán hi·ªáu ·ª©ng
                    const dropTargets = [
                        DOMElements.board.playerMainSlot,
                        DOMElements.board.playerSideSlot,
                    ];

                    dropTargets.forEach((slotEl) => {
                        const zoneRect = slotEl.getBoundingClientRect();
                        if (
                            pointer.clientX > zoneRect.left &&
                            pointer.clientX < zoneRect.right &&
                            pointer.clientY > zoneRect.top &&
                            pointer.clientY < zoneRect.bottom
                        ) {
                            slotEl.classList.add("drop-hover");
                        } else {
                            slotEl.classList.remove("drop-hover");
                        }
                    });
                }
                // H√ÄM C·∫¨P NH·∫¨T TH√îNG TIN TR·∫¨N ƒê·∫§U
                updateGameInfo() {
                    DOMElements.header.turnInfo.textContent = `V√≤ng ${gameState.round} - V√°n ${gameState.turn}`;
                }

                // ========================================================= //
                // C√ÅC H√ÄM LOGIC KH√ÅC GI·ªÆ NGUY√äN HO·∫∂C CH·ªà THAY ƒê·ªîI NH·ªé
                // Ph·∫ßn c√≤n l·∫°i c·ªßa script c√≥ th·ªÉ copy t·ª´ file c≈© c·ªßa b·∫°n
                // ho·∫∑c d√πng b·∫£n ƒë·∫ßy ƒë·ªß ƒë√£ ƒë∆∞·ª£c ki·ªÉm tra d∆∞·ªõi ƒë√¢y.
                // ========================================================= //

                dragStart(e, card, cardEl) {
                    if (dragState.isDragging) return;
                    e.preventDefault();

                    const pointer = e.touches ? e.touches[0] : e;
                    const rect = cardEl.getBoundingClientRect();

                    dragState.isDragging = true;
                    dragState.draggedElement = cardEl.cloneNode(true);
                    document.body.appendChild(dragState.draggedElement);
                    dragState.cardData = card;

                    // --- PH·∫¶N S·ª¨A L·ªñI QUAN TR·ªåNG ---
                    // T√≠nh to√°n kho·∫£ng c√°ch t·ª´ ƒëi·ªÉm ch·∫°m ƒë·∫øn g√≥c tr√™n-tr√°i c·ªßa l√° b√†i
                    dragState.offsetX = pointer.clientX - rect.left;
                    dragState.offsetY = pointer.clientY - rect.top;
                    // --- K·∫æT TH√öC PH·∫¶N S·ª¨A ---

                    dragState.draggedElement.style.position = "fixed";
                    dragState.draggedElement.style.zIndex = 1000;
                    dragState.draggedElement.classList.add("dragging");
                    // Gi·∫£m ƒë·ªô m·ªù c·ªßa l√° b√†i g·ªëc ƒë·ªÉ r√µ r√†ng h∆°n
                    cardEl.style.opacity = "0.3";

                    // G·ªçi h√†m dragging ngay l·∫≠p t·ª©c ƒë·ªÉ l√° b√†i "nh·∫£y" ƒë·∫øn ƒë√∫ng v·ªã tr√≠ d∆∞·ªõi con tr·ªè
                    this.dragging(e);

                    document.addEventListener("mousemove", this.dragging);
                    document.addEventListener("touchmove", this.dragging, {
                        passive: false,
                    });
                    document.addEventListener("mouseup", this.dragEnd);
                    document.addEventListener("touchend", this.dragEnd);
                }
                handleDrop(card, zoneName) {
                    if (gameState.phase === PHASES.DEFENDER_PLACE_CARDS) {
                        this.handleDefenderPlacementDrop(card, zoneName);
                    } else if (gameState.phase === PHASES.ATTACKER_CHOOSE_CARD) {
                        this.handleAttackerDrop(card, zoneName);
                    }
                }
                createCard(type, isPriority = false, isSpecial = false) {
                    return {
                        id: `card_${Date.now()}_${Math.random()}`,
                        type: type,
                        isPriority: isPriority,
                        isSpecial: isSpecial,
                        isBasic: !isSpecial,
                    };
                }
                getPlayer(id) {
                    return gameState.players.find((p) => p.id === id);
                }
                getCurrentAttacker() {
                    return this.getPlayer(gameState.currentAttackerId);
                }
                getCurrentDefender() {
                    return this.getPlayer(gameState.currentDefenderId);
                }
                sleep(ms) {
                    return new Promise((resolve) => setTimeout(resolve, ms));
                }
                log(message) {
                    console.log(message);
                    this.updateActionBar(message); // D√πng action bar m·ªõi
                }

                handleDefenderPlacementDrop(card, zoneName) {
                    const bf = gameState.battlefield;
                    const player = this.getCurrentDefender();

                    // Kh√¥ng cho ƒë·∫∑t v√†o √¥ ƒë√£ c√≥ th·∫ª
                    if (bf[zoneName].defenderCard) return;

                    bf[zoneName].defenderCard = card;
                    player.hand = player.hand.filter((c) => c.id !== card.id);
                    if (card.isPriority) {
                        player.priorityUsedThisRound =
                            (player.priorityUsedThisRound || 0) + 1;
                    }

                    // Ki·ªÉm tra xem c·∫£ hai th·∫ª ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t ch∆∞a
                    if (bf.main.defenderCard && bf.side.defenderCard) {
                        const mainCard = bf.main.defenderCard;
                        const sideCard = bf.side.defenderCard;

                        // Ki·ªÉm tra lu·∫≠t: Ph·∫£i c√≥ √≠t nh·∫•t 1 th·∫ª ∆∞u ti√™n
                        if (!mainCard.isPriority && !sideCard.isPriority) {
                            this.log("L·ªói: Ph·∫£i ƒë·∫∑t √≠t nh·∫•t 1 Th·∫ª ∆Øu Ti√™n!");
                            player.hand.push(mainCard, sideCard); // Tr·∫£ b√†i v·ªÅ tay
                            bf.main.defenderCard = null;
                            bf.side.defenderCard = null;
                            player.priorityCardsUsedThisRound = 0; // Reset b·ªô ƒë·∫øm
                            this.render();
                            return;
                        }

                        // Ki·ªÉm tra lu·∫≠t: Kh√¥ng ƒë∆∞·ª£c ƒë·∫∑t 2 th·∫ª ƒë·∫∑c bi·ªát
                        if (mainCard.isSpecial && sideCard.isSpecial) {
                            this.log("L·ªói: Kh√¥ng ƒë∆∞·ª£c ƒë·∫∑t 2 Th·∫ª ƒê·∫∑c Bi·ªát!");
                            player.hand.push(mainCard, sideCard); // Tr·∫£ b√†i v·ªÅ tay
                            bf.main.defenderCard = null;
                            bf.side.defenderCard = null;
                            player.priorityCardsUsedThisRound = 0; // Reset b·ªô ƒë·∫øm
                            this.render();
                            return;
                        }

                        // N·∫øu m·ªçi th·ª© h·ª£p l·ªá, thay v√¨ chuy·ªÉn phase, ch√∫ng ta s·∫Ω hi·ªÉn th·ªã n√∫t x√°c nh·∫≠n
                        if (!player.isAI) {
                            this.showConfirmButton(true);
                        } else {
                            // AI t·ª± ƒë·ªông x√°c nh·∫≠n sau m·ªôt kho·∫£ng tr·ªÖ
                            setTimeout(
                                () => this.setPhase(PHASES.ATTACKER_CHOOSE_CARD),
                                1000
                            );
                        }
                    }

                    // Render l·∫°i game sau m·ªói l·∫ßn ƒë·∫∑t th·∫ª
                    this.render();
                    // --- K·∫æT TH√öC S·ª¨A ƒê·ªîI ---
                }
                handleAttackerDrop(card, zoneName) {
                    const player = this.getCurrentAttacker();
                    const bf = gameState.battlefield;

                    // N·∫øu ng∆∞·ªùi ch∆°i ƒë√£ ƒë·∫∑t th·∫ª t·∫•n c√¥ng tr∆∞·ªõc ƒë√≥, tr·∫£ th·∫ª c≈© v·ªÅ tay
                    if (gameState.attackerCardChoice) {
                        // X√≥a th·∫ª c≈© kh·ªèi b√†n ƒë·∫•u
                        bf[gameState.attackerZoneChoice].attackerCard = null;
                        // Tr·∫£ th·∫ª v·ªÅ tay
                        player.hand.push(gameState.attackerCardChoice);
                        // Ho√†n l·∫°i l∆∞·ª£t d√πng th·∫ª ∆∞u ti√™n n·∫øu th·∫ª ƒë√≥ l√† ∆∞u ti√™n
                        if (gameState.attackerCardChoice.isPriority) {
                            player.priorityUsedThisRound--;
                        }
                    }

                    // ƒê·∫∑t th·∫ª m·ªõi
                    player.hand = player.hand.filter((c) => c.id !== card.id);
                    if (card.isPriority) {
                        player.priorityUsedThisRound =
                            (player.priorityUsedThisRound || 0) + 1;
                    }
                    bf[zoneName].attackerCard = card;
                    gameState.attackerCardChoice = card;
                    gameState.attackerZoneChoice = zoneName;

                    this.showConfirmButton(true); // Hi·ªÉn th·ªã n√∫t x√°c nh·∫≠n
                    this.render(); // C·∫≠p nh·∫≠t l·∫°i giao di·ªán
                }
                async setPhase(newPhase) {
                    gameState.phase = newPhase;
                    console.log(`New Phase: ${newPhase}`);

                    // X√ÅC ƒê·ªäNH NG∆Ø·ªúI CH∆†I TI·∫æP THEO S·∫º H√ÄNH ƒê·ªòNG
                    let nextPlayerToActId;
                    switch (newPhase) {
                        case PHASES.DEFENDER_PLACE_CARDS:
                        case PHASES.CHECK_DRAW:
                        case PHASES.DEFENDER_SWAP_CHOICE:
                            nextPlayerToActId = gameState.currentDefenderId;
                            break;
                        case PHASES.ATTACKER_CHOOSE_CARD:
                        case PHASES.ATTACKER_SWAP_CHOICE:
                            nextPlayerToActId = gameState.currentAttackerId;
                            break;
                    }


                    if (nextPlayerToActId !== undefined) {
                        await this.showTurnHandoff(nextPlayerToActId);
                    }

                    this.render(); // Render l·∫°i sau khi c√≥ th·ªÉ ƒë√£ ƒë·ªïi ng∆∞·ªùi ch∆°i
                    switch (newPhase) {
                        case PHASES.START_TURN:
                            this.startTurn();
                            break;
                        case PHASES.ROLE_SELECTION:
                            this.handleRoleSelection();
                            break;
                        case PHASES.CHECK_DRAW:
                            const defenderForDraw = this.getCurrentDefender();
                            const hasPriorityCard = defenderForDraw.hand.some(
                                (c) => c.isPriority
                            );
                            const hasEnoughCards = defenderForDraw.hand.length >= 2;

                            // --- S·ª¨A LOGIC T·∫†I ƒê√ÇY ---
                            // Ng∆∞·ªùi ch∆°i ph·∫£i b·ªëc b√†i n·∫øu KH√îNG C√ì th·∫ª ∆Øu Ti√™n HO·∫∂C c√≥ √çT H∆†N 2 L√Å B√ÄI
                            if (!hasPriorityCard || !hasEnoughCards) {
                                let reason = !hasPriorityCard ?
                                    "kh√¥ng c√≥ Th·∫ª ∆Øu Ti√™n" :
                                    "c√≥ √≠t h∆°n 2 l√° b√†i";
                                this.log(
                                    `${defenderForDraw.name} ${reason}! B·∫Øt bu·ªôc b·ªëc b√†i.`
                                );
                                await this.sleep(1500);
                                this.handleDraw(defenderForDraw.id);
                            } else {
                                this.setPhase(PHASES.DEFENDER_PLACE_CARDS);
                            }
                            break;
                        case PHASES.DEFENDER_PLACE_CARDS:
                            this.log("Ph√≤ng Th·ªß: K√©o 2 l√° b√†i v√†o 2 khu v·ª±c.");
                            if (this.getCurrentDefender().isAI)
                                await this.ai_placeDefenseCards();
                            break;
                        case PHASES.ATTACKER_CHOOSE_CARD:
                            // S·ª¨A ·ªû ƒê√ÇY: kh√¥ng g·ªçi FINAL_DECISION n·ªØa
                            // Vi·ªác chuy·ªÉn phase s·∫Ω do h√†m handleAttackerDrop ƒë·∫£m nhi·ªám
                            this.log("T·∫•n C√¥ng: K√©o 1 l√° b√†i v√†o khu v·ª±c mu·ªën t·∫•n c√¥ng.");
                            if (this.getCurrentAttacker().isAI)
                                await this.ai_chooseAttackCard();
                            break;

                            // --- TH√äM C√ÅC CASE M·ªöI ---
                        case PHASES.DEFENDER_SWAP_CHOICE:
                            await this.handleDefenderSwapChoice();
                            break;
                        case PHASES.ATTACKER_SWAP_CHOICE:
                            await this.handleAttackerSwapChoice();
                            break;

                        case PHASES.RESOLUTION:
                            this.resolveTurn();
                            break;
                    }
                    this.saveGameState();
                }
                // TH√äM 2 H√ÄM M·ªöI N√ÄY V√ÄO TRONG CLASS GAME
                // THAY TH·∫æ TO√ÄN B·ªò H√ÄM N√ÄY
                async handleDefenderSwapChoice() {
                    this.log("Ph√≤ng th·ªß: Quy·∫øt ƒë·ªãnh c√≥ tr√°o b√†i hay kh√¥ng...");
                    const defender = this.getCurrentDefender();

                    if (defender.isAI) {
                        await this.ai_finalDecisionDefender(); // T√°i s·ª≠ d·ª•ng logic AI c≈©
                        this.setPhase(PHASES.ATTACKER_SWAP_CHOICE);
                    } else {
                        this.showConfirmationBar({
                            text: "B·∫°n c√≥ mu·ªën tr√°o ƒë·ªïi 2 th·∫ª b√†i ph√≤ng th·ªß kh√¥ng?",
                            options: [{
                                    text: "Tr√°o ƒë·ªïi",
                                    value: true
                                },
                                {
                                    text: "Gi·ªØ nguy√™n",
                                    value: false
                                },
                            ],
                            onSelect: async (shouldSwap) => {
                                // TH√äM M·ªöI LOGIC L∆ØU TR·∫†NG TH√ÅI
                                if (shouldSwap) {
                                    [
                                        gameState.battlefield.main.defenderCard,
                                        gameState.battlefield.side.defenderCard,
                                    ] = [
                                        gameState.battlefield.side.defenderCard,
                                        gameState.battlefield.main.defenderCard,
                                    ];
                                    this.render();
                                    this.log("B·∫°n ƒë√£ tr√°o b√†i ph√≤ng th·ªß!");
                                    // L∆∞u th√¥ng b√°o cho ng∆∞·ªùi ch∆°i ti·∫øp theo th·∫•y
                                    gameState.lastTurnActionInfo = "ƒê·ªëi ph∆∞∆°ng ƒë√£ TR√ÅO B√ÄI ph√≤ng th·ªß.";
                                    await this.sleep(1500);
                                } else {
                                    // X√≥a th√¥ng b√°o n·∫øu kh√¥ng tr√°o
                                    gameState.lastTurnActionInfo = null;
                                }
                                this.setPhase(PHASES.ATTACKER_SWAP_CHOICE);
                            },
                        });
                    }
                }

                async handleAttackerSwapChoice() {
                    this.log("T·∫•n c√¥ng: Quy·∫øt ƒë·ªãnh c√≥ ƒë·ªïi khu v·ª±c t·∫•n c√¥ng kh√¥ng...");
                    const attacker = this.getCurrentAttacker();

                    if (attacker.isAI) {
                        await this.ai_finalDecisionAttacker();
                        this.log("T·∫•t c·∫£ ƒë√£ ch·ªët. X·ª≠ l√Ω k·∫øt qu·∫£!");
                        await this.sleep(1500);
                        this.setPhase(PHASES.RESOLUTION);
                    } else {
                        this.showConfirmationBar({
                            text: "B·∫°n c√≥ mu·ªën ƒë·ªïi khu v·ª±c t·∫•n c√¥ng kh√¥ng?",
                            options: [{
                                    text: `ƒê·ªïi sang Khu ${
            gameState.attackerZoneChoice === ZONES.MAIN
              ? "Ph·ª•"
              : "Ch√≠nh"
          }`,
                                    value: true,
                                },
                                {
                                    text: "Gi·ªØ Nguy√™n",
                                    value: false
                                },
                            ],
                            onSelect: async (shouldSwitch) => {
                                // TH√äM M·ªöI LOGIC L∆ØU TR·∫†NG TH√ÅI
                                if (shouldSwitch) {
                                    gameState.battlefield[
                                        gameState.attackerZoneChoice
                                    ].attackerCard = null;
                                    gameState.attackerZoneChoice =
                                        gameState.attackerZoneChoice === ZONES.MAIN ?
                                        ZONES.SIDE :
                                        ZONES.MAIN;
                                    gameState.battlefield[
                                        gameState.attackerZoneChoice
                                    ].attackerCard = gameState.attackerCardChoice;
                                    this.render();
                                    this.log("B·∫°n ƒë√£ ƒë·ªïi khu v·ª±c t·∫•n c√¥ng!");
                                    // L∆∞u th√¥ng b√°o cho ng∆∞·ªùi ch∆°i ti·∫øp theo th·∫•y
                                    gameState.lastTurnActionInfo = "ƒê·ªëi ph∆∞∆°ng ƒë√£ ƒê·ªîI KHU V·ª∞C t·∫•n c√¥ng.";
                                    await this.sleep(1500);
                                } else {
                                    // X√≥a th√¥ng b√°o n·∫øu kh√¥ng ƒë·ªïi
                                    gameState.lastTurnActionInfo = null;
                                }
                                this.log("T·∫•t c·∫£ ƒë√£ ch·ªët. X·ª≠ l√Ω k·∫øt qu·∫£!");
                                await this.sleep(1500);
                                this.setPhase(PHASES.RESOLUTION);
                            },
                        });
                    }
                }
                async ai_chooseAttackCard() {
                    await this.sleep(1000);
                    const ai = this.getCurrentAttacker();
                    let usableCards = ai.hand.filter(
                        (c) => !(c.isPriority && ai.priorityCardsUsedThisRound >= 2)
                    );
                    gameState.attackerCardChoice =
                        usableCards[Math.floor(Math.random() * usableCards.length)];
                    ai.hand = ai.hand.filter(
                        (c) => c.id !== gameState.attackerCardChoice.id
                    );
                    this.log("ƒê·ªëi th·ªß ƒë√£ ch·ªçn b√†i...");
                    await this.sleep(1000);
                    gameState.attackerZoneChoice =
                        Math.random() < 0.5 ? ZONES.MAIN : ZONES.SIDE;
                    gameState.battlefield[gameState.attackerZoneChoice].attackerCard =
                        gameState.attackerCardChoice;
                    this.log(
                        `ƒê·ªëi th·ªß t·∫•n c√¥ng Khu ${
              gameState.attackerZoneChoice === ZONES.MAIN ? "Ch√≠nh" : "Ph·ª•"
            }.`
                    );
                    await this.sleep(1000);
                    this.setPhase(PHASES.DEFENDER_SWAP_CHOICE);
                }
                startRound() {
                    gameState.round++;
                    if (gameState.round > 5) {
                        this.endGame();
                        return;
                    }
                    gameState.turn = 1;
                    this.updateGameInfo();
                    gameState.players.forEach((p) => (p.priorityUsedThisRound = 0));
                    this.setPhase(PHASES.START_TURN);
                }
                async startTurn() {
                    this.resetBattlefield();
                    if (gameState.turn === 1) {
                        this.setPhase(PHASES.ROLE_SELECTION);
                    } else {
                        [gameState.currentAttackerId, gameState.currentDefenderId] = [
                            gameState.currentDefenderId,
                            gameState.currentAttackerId,
                        ];
                        this.log(
                            `V√°n 2, ƒë·ªïi vai! ${this.getCurrentAttacker().name} T·∫•n C√¥ng.`
                        );
                        await this.sleep(2000);
                        this.setPhase(PHASES.CHECK_DRAW);
                    }
                }
                async handleRoleSelection() {
                    let chooserId;
                    if (gameState.round === 1) {
                        chooserId = 0;
                    } else {
                        const p0 = gameState.players[0],
                            p1 = gameState.players[1];
                        if (p0.score < p1.score) chooserId = 0;
                        else if (p1.score < p0.score) chooserId = 1;
                        else chooserId = gameState.lastTurnWinnerId === 0 ? 1 : 0;
                    }
                    await this.showTurnHandoff(chooserId);

                    const chooser = gameState.players[chooserId];

                    if (chooser.isAI) {
                        const choice =
                            Math.random() < 0.5 ? ROLES.ATTACKER : ROLES.DEFENDER;
                        this.log(
                            `AI (${chooser.name}) ƒë∆∞·ª£c ch·ªçn vai v√† ƒë√£ ch·ªçn ${choice}.`
                        );
                        await this.sleep(1500);
                        this.setRoles(chooser.id, choice);
                    } else {
                        // Logic cho ng∆∞·ªùi ch∆°i kh√¥ng ƒë·ªïi
                        this.showConfirmationBar({
                            text: `${chooser.name} ƒë∆∞·ª£c quy·ªÅn ch·ªçn vai tr√≤:`, // D√πng t√™n ƒë·ªông
                            options: [{
                                    text: ROLES.ATTACKER,
                                    value: ROLES.ATTACKER
                                },
                                {
                                    text: ROLES.DEFENDER,
                                    value: ROLES.DEFENDER
                                },
                            ],
                            onSelect: (choice) => this.setRoles(chooser.id, choice),
                            isRoleSelection: true,
                        });
                    }
                }
                setRoles(chooserId, choice) {
                    if (choice === ROLES.ATTACKER) {
                        gameState.currentAttackerId = chooserId;
                        gameState.currentDefenderId = chooserId === 0 ? 1 : 0;
                    } else {
                        gameState.currentDefenderId = chooserId;
                        gameState.currentAttackerId = chooserId === 0 ? 1 : 0;
                    }
                    this.setPhase(PHASES.CHECK_DRAW);
                }
                // D√°n ƒë·ªÉ THAY TH·∫æ TO√ÄN B·ªò h√†m resolveTurn() c≈©
                async resolveTurn() {
                    this.log("L·∫≠t b√†i!");
                    await this.sleep(1000);
                    this.renderBattlefield(true);
                    await this.sleep(1500);

                    const attacker = this.getCurrentAttacker();
                    const defender = this.getCurrentDefender();
                    const attackZone = gameState.attackerZoneChoice;

                    // B∆Ø·ªöC 1: X·ª¨ L√ù KHU PH·ª§
                    const sideZoneCard = gameState.battlefield.side.defenderCard;
                    let pointIncreaseInfo = null;

                    if (attackZone !== ZONES.SIDE && sideZoneCard) {
                        if (sideZoneCard.isBasic) {
                            gameState.cardBasePoints[sideZoneCard.type]++;
                            pointIncreaseInfo = {
                                cardType: sideZoneCard.type,
                                newPoints: gameState.cardBasePoints[sideZoneCard.type],
                            };
                            this.log(
                                `Th·∫ª ${
                  sideZoneCard.type
                } ƒë∆∞·ª£c b·∫£o to√†n. +1 ƒëi·ªÉm c∆° b·∫£n! (Hi·ªán t·∫°i: ${
                  gameState.cardBasePoints[sideZoneCard.type]
                })`
                            );
                            this.render();
                            await this.sleep(1500);
                            if (sideZoneCard.isPriority) {
                                gameState.commonDeck.push(sideZoneCard);
                                this.log(
                                    `Th·∫ª ∆Øu Ti√™n ·ªü Khu Ph·ª• c·ªßa ${defender.name} b·ªã lo·∫°i b·ªè.`
                                );
                            } else {
                                defender.hand.push(sideZoneCard);
                                this.log(`Th·∫ª ·ªü Khu Ph·ª• c·ªßa ${defender.name} ƒë∆∞·ª£c tr·∫£ v·ªÅ tay.`);
                            }
                        } else {
                            defender.hand.push(sideZoneCard);
                            this.log(`Th·∫ª ·ªü Khu Ph·ª• c·ªßa ${defender.name} ƒë∆∞·ª£c tr·∫£ v·ªÅ tay.`);
                        }
                        await this.sleep(1000);
                    }

                    // B∆Ø·ªöC 2: X√ÅC ƒê·ªäNH K·∫æT QU·∫¢ ƒê·ªêI ƒê·∫¶U
                    const defendingCard = gameState.battlefield[attackZone].defenderCard;
                    const attackingCard = gameState.attackerCardChoice;
                    let clashResult;
                    // (logic x√°c ƒë·ªãnh k·∫øt qu·∫£ gi·ªØ nguy√™n)
                    if (attackingCard.isSpecial || defendingCard.isSpecial) {
                        if (
                            attackingCard.type === SPECIAL_CARDS.WIN &&
                            defendingCard.type === SPECIAL_CARDS.WIN
                        )
                            clashResult = "defender";
                        else if (
                            attackingCard.type === SPECIAL_CARDS.LOSE &&
                            defendingCard.type === SPECIAL_CARDS.LOSE
                        )
                            clashResult = "defender";
                        else if (
                            attackingCard.type === SPECIAL_CARDS.WIN &&
                            defendingCard.type === SPECIAL_CARDS.LOSE
                        )
                            clashResult = "draw";
                        else if (
                            attackingCard.type === SPECIAL_CARDS.LOSE &&
                            defendingCard.type === SPECIAL_CARDS.WIN
                        )
                            clashResult = "draw";
                        else if (attackingCard.type === SPECIAL_CARDS.WIN)
                            clashResult = "attacker";
                        else if (defendingCard.type === SPECIAL_CARDS.WIN)
                            clashResult = "defender";
                        else if (attackingCard.type === SPECIAL_CARDS.LOSE)
                            clashResult = "defender";
                        else if (defendingCard.type === SPECIAL_CARDS.LOSE)
                            clashResult = "attacker";
                    } else {
                        const winMap = {
                            [CARD_TYPES.BUA]: CARD_TYPES.KEO,
                            [CARD_TYPES.KEO]: CARD_TYPES.BAO,
                            [CARD_TYPES.BAO]: CARD_TYPES.BUA,
                        };
                        if (attackingCard.type === defendingCard.type) clashResult = "draw";
                        else if (winMap[attackingCard.type] === defendingCard.type)
                            clashResult = "attacker";
                        else clashResult = "defender";
                    }

                    // B∆Ø·ªöC 3, 4, 5 K·∫æT H·ª¢P: T√çNH V√Ä PH√ÇN B·ªî ƒêI·ªÇM
                    let attackerScoreChange = 0;
                    let defenderScoreChange = 0;
                    const zoneMultiplier = attackZone === ZONES.MAIN ? 2 : 1;
                    const bonusBasePoint = 5;

                    const attackerBasePoints = attackingCard.isSpecial ?
                        5 :
                        gameState.cardBasePoints[attackingCard.type];
                    let attackerMultiplier = attackingCard.isPriority ?
                        attackZone === ZONES.MAIN ?
                        3 :
                        2 :
                        zoneMultiplier;
                    const attackerGiaoTranh = attackerBasePoints * attackerMultiplier;

                    const defenderBasePoints = defendingCard.isSpecial ?
                        5 :
                        gameState.cardBasePoints[defendingCard.type];
                    let defenderMultiplier = defendingCard.isPriority ?
                        attackZone === ZONES.MAIN ?
                        3 :
                        2 :
                        zoneMultiplier;
                    const defenderGiaoTranh = defenderBasePoints * defenderMultiplier;

                    const attackerFulfilledPurpose =
                        attackingCard.isSpecial &&
                        ((attackingCard.type === SPECIAL_CARDS.WIN &&
                                clashResult === "attacker") ||
                            (attackingCard.type === SPECIAL_CARDS.LOSE &&
                                clashResult === "defender"));

                    const defenderFulfilledPurpose =
                        defendingCard.isSpecial &&
                        ((defendingCard.type === SPECIAL_CARDS.WIN &&
                                clashResult === "defender") ||
                            (defendingCard.type === SPECIAL_CARDS.LOSE &&
                                clashResult === "attacker"));

                    if (attackerFulfilledPurpose) {
                        attackerScoreChange = bonusBasePoint * zoneMultiplier;
                        this.log(`${attacker.name} ho√†n th√†nh m·ª•c ƒë√≠ch th·∫ª ƒê·∫∑c Bi·ªát!`);
                    } else {
                        if (clashResult === "attacker")
                            attackerScoreChange = attackerGiaoTranh;
                        else if (clashResult === "defender")
                            attackerScoreChange = -attackerGiaoTranh;
                    }

                    if (defenderFulfilledPurpose) {
                        defenderScoreChange = bonusBasePoint * zoneMultiplier;
                        this.log(`${defender.name} ho√†n th√†nh m·ª•c ƒë√≠ch th·∫ª ƒê·∫∑c Bi·ªát!`);
                    } else {
                        if (clashResult === "defender")
                            defenderScoreChange = defenderGiaoTranh;
                        else if (clashResult === "attacker")
                            defenderScoreChange = -defenderGiaoTranh;
                    }

                    // ================ D√íNG QUAN TR·ªåNG ƒê√É S·ª¨A ƒê·ªîI ================
                    this.recordHistory(
                        clashResult,
                        pointIncreaseInfo,
                        attackerScoreChange,
                        defenderScoreChange,
                        attackerGiaoTranh,
                        defenderGiaoTranh
                    );
                    // =============================================================

                    if (clashResult === "attacker")
                        this.log(`${attacker.name} th·∫Øng cu·ªôc ƒë·ªëi ƒë·∫ßu!`);
                    else if (clashResult === "defender")
                        this.log(`${defender.name} th·∫Øng cu·ªôc ƒë·ªëi ƒë·∫ßu!`);
                    else this.log("Cu·ªôc ƒë·ªëi ƒë·∫ßu k·∫øt th√∫c v·ªõi k·∫øt qu·∫£ H√≤a!");

                    await this.sleep(1500);

                    attacker.score += attackerScoreChange;
                    defender.score += defenderScoreChange;
                    this.render({
                        updateBattlefield: false
                    }); // S·ª¨A ƒê·ªîI: C·∫≠p nh·∫≠t ƒëi·ªÉm nh∆∞ng kh√¥ng render l·∫°i b√†n ƒë·∫•u
                    this.showScoreChange(attacker.id, attackerScoreChange);
                    this.showScoreChange(defender.id, defenderScoreChange);
                    this.saveGameState();
                    await this.sleep(1500);

                    // (Ph·∫ßn d·ªçn d·∫πp b√†n ƒë·∫•u c√≤n l·∫°i gi·ªØ nguy√™n)
                    if (attackingCard.isBasic) {
                        attackingCard.isPriority = false;
                        gameState.commonDeck.push(attackingCard);
                    } else if (attackingCard.isSpecial) {
                        attacker.specialCardsUsed[attackingCard.type] = true;
                    }
                    if (defendingCard.isBasic) {
                        defendingCard.isPriority = false;
                        gameState.commonDeck.push(defendingCard);
                    } else if (defendingCard.isSpecial) {
                        defender.specialCardsUsed[defendingCard.type] = true;
                    }
                    const mainZoneCard = gameState.battlefield.main.defenderCard;
                    if (attackZone !== ZONES.MAIN && mainZoneCard) {
                        if (mainZoneCard.isBasic) {
                            mainZoneCard.isPriority = false;
                            gameState.commonDeck.push(mainZoneCard);
                        } else if (mainZoneCard.isSpecial) {
                            defender.specialCardsUsed[mainZoneCard.type] = true;
                        }
                        this.log(`Th·∫ª ·ªü Khu Ch√≠nh c·ªßa ${defender.name} b·ªã lo·∫°i b·ªè.`);
                        await this.sleep(1000);
                    }
                    if (attackingCard.isPriority) attacker.priorityCardsUsedThisRound++;

                    if (clashResult === "attacker")
                        gameState.lastTurnWinnerId = attacker.id;
                    else if (clashResult === "defender")
                        gameState.lastTurnWinnerId = defender.id;
                    else gameState.lastTurnWinnerId = this.getCurrentDefender().id;
                    this.render();
                    await this.sleep(1500);
                    if (gameState.turn === 1) {
                        gameState.turn = 2;
                        this.setPhase(PHASES.START_TURN);
                    } else {
                        this.log(`K·∫øt th√∫c V√≤ng ${gameState.round}.`);
                        await this.sleep(2000);
                        this.startRound();
                    }
                }

                // THAY TH·∫æ TO√ÄN B·ªò h√†m handleDraw()
                async handleDraw(playerId) {
                    const player = this.getPlayer(playerId);
                    const opponent = this.getPlayer(playerId === 0 ? 1 : 0);

                    if (gameState.commonDeck.length < 3) {
                        this.log("B·ªô b√†i chung kh√¥ng ƒë·ªß ƒë·ªÉ b·ªëc!");
                        this.setPhase(PHASES.DEFENDER_PLACE_CARDS);
                        return;
                    }

                    // TR∆Ø·ªúNG H·ª¢P 1: √çt ƒëi·ªÉm h∆°n, ƒë∆∞·ª£c ch·ªçn b√†i
                    if (player.score < opponent.score) {
                        this.log(
                            `${player.name} ƒëang b·ªã d·∫´n tr∆∞·ªõc v√† ƒë∆∞·ª£c quy·ªÅn ch·ªçn 1 l√° b√†i!`
                        );
                        await this.sleep(1500);

                        if (player.isAI) {
                            await this.ai_selectAndDrawCards(player);
                        } else {
                            this.showCardSelectionFromDeckModal(player);
                        }
                    }
                    // TR∆Ø·ªúNG H·ª¢P 2: B·∫±ng ho·∫∑c nhi·ªÅu ƒëi·ªÉm h∆°n, b·ªëc ng·∫´u nhi√™n
                    else {
                        this.log(`${player.name} s·∫Ω b·ªëc 3 l√° b√†i ng·∫´u nhi√™n.`);
                        await this.sleep(1500);

                        const drawnCards = [];
                        for (let i = 0; i < 3; i++) {
                            if (gameState.commonDeck.length === 0) break;
                            const cardIndex = Math.floor(
                                Math.random() * gameState.commonDeck.length
                            );
                            const card = gameState.commonDeck.splice(cardIndex, 1)[0];
                            card.isPriority = false;
                            drawnCards.push(card);
                        }
                        // === S·ª¨A ƒê·ªîI QUAN TR·ªåNG: Th√™m 'true' ƒë·ªÉ b√°o hi·ªáu ƒë√¢y l√† b·ªëc ng·∫´u nhi√™n ===
                        this.continueToPrioritySelection(player, drawnCards, true);
                    }
                }
                // THAY TH·∫æ TO√ÄN B·ªò h√†m continueToPrioritySelection()
                async continueToPrioritySelection(player, drawnCards, isRandomDraw = false) {
                    const oldPriorityCount = player.hand.filter((c) => c.isPriority).length;
                    const neededPriorityCount = Math.max(0, 3 - oldPriorityCount);

                    if (neededPriorityCount <= 0 || drawnCards.length === 0) {
                        player.hand.push(...drawnCards);
                        this.log(`${player.name} ƒë√£ b·ªëc ${drawnCards.length} l√° Th∆∞·ªùng m·ªõi.`);
                        await this.sleep(1500);
                        this.handlePostDraw(player);
                        return;
                    }

                    if (player.isAI) {
                        this.ai_handlePrioritySelection(player, drawnCards, neededPriorityCount);
                    } else if (isRandomDraw) {
                        // === LOGIC M·ªöI: T·ª± ƒë·ªông g√°n ∆∞u ti√™n khi b·ªëc ng·∫´u nhi√™n ===
                        this.log(`T·ª± ƒë·ªông ch·ªâ ƒë·ªãnh ${neededPriorityCount} Th·∫ª ∆Øu Ti√™n m·ªõi.`);
                        await this.sleep(1500);

                        // G√°n ∆∞u ti√™n cho c√°c l√° b√†i ƒë·∫ßu ti√™n trong danh s√°ch b·ªëc ƒë∆∞·ª£c
                        for (let i = 0; i < neededPriorityCount; i++) {
                            if (drawnCards[i]) {
                                drawnCards[i].isPriority = true;
                            }
                        }
                        player.hand.push(...drawnCards);
                        this.handlePostDraw(player);
                    } else {
                        // Gi·ªØ nguy√™n logic c≈©: cho ng∆∞·ªùi ch∆°i ch·ªçn khi c√≥ l·ª£i th·∫ø
                        this.log(`B·∫°n c·∫ßn ch·ªâ ƒë·ªãnh ${neededPriorityCount} Th·∫ª ∆Øu Ti√™n m·ªõi.`);
                        await this.sleep(1500);
                        this.showPrioritySelectionModal(player, drawnCards, neededPriorityCount);
                    }
                }
                showCardSelectionFromDeckModal(player) {
                    const overlay = document.createElement("div");
                    overlay.className = "modal-overlay";

                    // T·∫°o n·ªôi dung cho modal
                    let cardsHTML = '<div class="card-selection-grid">';
                    gameState.commonDeck.forEach((card) => {
                        const cardEl = this.createCardElement(card);
                        // G·∫Øn d·ªØ li·ªáu card ID v√†o element ƒë·ªÉ x·ª≠ l√Ω click
                        cardEl.dataset.cardId = card.id;
                        cardsHTML += cardEl.outerHTML;
                    });
                    cardsHTML += "</div>";

                    const modal = document.createElement("div");
                    modal.className = "modal-content";
                    modal.innerHTML = `
                <h2>L·ª£i Th·∫ø K·∫ª Y·∫øu</h2>
                <p>B·∫°n ƒëang b·ªã d·∫´n tr∆∞·ªõc. H√£y ch·ªçn 1 l√° b√†i t·ª´ b·ªô b√†i chung:</p>
                ${cardsHTML}
            `;

                    overlay.appendChild(modal);
                    DOMElements.dynamicContainer.appendChild(overlay);

                    // Th√™m s·ª± ki·ªán click cho t·ª´ng l√° b√†i trong modal
                    modal.querySelectorAll(".card").forEach((cardEl) => {
                        cardEl.onclick = () => {
                            const chosenCardId = cardEl.dataset.cardId;
                            const chosenCard = gameState.commonDeck.find(
                                (c) => c.id === chosenCardId
                            );

                            // X√≥a l√° b√†i ƒë√£ ch·ªçn kh·ªèi b·ªô b√†i chung
                            gameState.commonDeck = gameState.commonDeck.filter(
                                (c) => c.id !== chosenCardId
                            );

                            // B·∫Øt ƒë·∫ßu qu√° tr√¨nh b·ªëc b√†i v·ªõi l√° ƒë√£ ch·ªçn
                            const drawnCards = [chosenCard];

                            // ======================= PH·∫¶N TH√äM M·ªöI =======================
                            // B·ªêC TH√äM 2 L√Å NG·∫™U NHI√äN t·ª´ ph·∫ßn c√≤n l·∫°i c·ªßa b·ªô b√†i chung
                            this.log("B·ªëc th√™m 2 l√° b√†i ng·∫´u nhi√™n...");
                            for (let i = 0; i < 2; i++) {
                                // Ki·ªÉm tra xem b·ªô b√†i chung c√≤n b√†i kh√¥ng
                                if (gameState.commonDeck.length > 0) {
                                    const cardIndex = Math.floor(
                                        Math.random() * gameState.commonDeck.length
                                    );
                                    const randomCard = gameState.commonDeck.splice(
                                        cardIndex,
                                        1
                                    )[0];
                                    drawnCards.push(randomCard);
                                }
                            }
                            // ===================== K·∫æT TH√öC PH·∫¶N TH√äM M·ªöI =====================

                            // Reset isPriority cho c·∫£ 3 l√° v·ª´a b·ªëc
                            drawnCards.forEach((c) => (c.isPriority = false));

                            overlay.remove(); // ƒê√≥ng modal
                            this.log(
                                `${player.name} ƒë√£ ch·ªçn ${chosenCard.type} v√† b·ªëc th√™m 2 l√°.`
                            );

                            // Chuy·ªÉn sang b∆∞·ªõc ti·∫øp theo: ch·ªçn th·∫ª ∆∞u ti√™n
                            this.continueToPrioritySelection(player, drawnCards); // <<< B√¢y gi·ªù h√†m n√†y s·∫Ω ƒë∆∞·ª£c g·ªçi v·ªõi ƒë·ªß 3 l√° b√†i
                        };
                    });
                }
                async ai_selectAndDrawCards(player) {
                    this.log(
                        `AI (${player.name}) ƒëang t√≠nh to√°n ƒë·ªÉ ch·ªçn l√° b√†i t·ªët nh·∫•t...`
                    );
                    await this.sleep(2000);

                    let bestCard = null;
                    let maxPoints = -1;

                    // Chi·∫øn l∆∞·ª£c ƒë∆°n gi·∫£n: T√¨m l√° b√†i c√≥ ƒëi·ªÉm c∆° b·∫£n cao nh·∫•t
                    gameState.commonDeck.forEach((card) => {
                        const points = gameState.cardBasePoints[card.type] || 0;
                        if (points > maxPoints) {
                            maxPoints = points;
                            bestCard = card;
                        }
                    });

                    // N·∫øu kh√¥ng t√¨m th·∫•y l√° n√†o c√≥ ƒëi·ªÉm (to√†n th·∫ª ƒë·∫∑c bi·ªát), ch·ªçn ng·∫´u nhi√™n
                    if (!bestCard) {
                        bestCard =
                            gameState.commonDeck[
                                Math.floor(Math.random() * gameState.commonDeck.length)
                            ];
                    }

                    this.log(`AI ƒë√£ ch·ªçn xong!`);
                    await this.sleep(1500);

                    // X√≥a l√° b√†i ƒë√£ ch·ªçn kh·ªèi b·ªô b√†i chung
                    gameState.commonDeck = gameState.commonDeck.filter(
                        (c) => c.id !== bestCard.id
                    );

                    // B·∫Øt ƒë·∫ßu b·ªëc b√†i v·ªõi l√° ƒë√£ ch·ªçn
                    const drawnCards = [bestCard];

                    // B·ªëc th√™m 2 l√° ng·∫´u nhi√™n
                    for (let i = 0; i < 2; i++) {
                        if (gameState.commonDeck.length > 0) {
                            const cardIndex = Math.floor(
                                Math.random() * gameState.commonDeck.length
                            );
                            const randomCard = gameState.commonDeck.splice(cardIndex, 1)[0];
                            drawnCards.push(randomCard);
                        }
                    }

                    drawnCards.forEach((c) => (c.isPriority = false));

                    // Chuy·ªÉn sang b∆∞·ªõc ti·∫øp theo: ch·ªçn th·∫ª ∆∞u ti√™n
                    this.continueToPrioritySelection(player, drawnCards);
                }
                // D√°n ƒë·ªÉ THAY TH·∫æ TO√ÄN B·ªò h√†m recordHistory() c≈©
                recordHistory(
                    clashResult,
                    pointIncreaseInfo = null,
                    attackerScoreChange,
                    defenderScoreChange,
                    attackerClashPoints,
                    defenderClashPoints
                ) {
                    const attacker = this.getCurrentAttacker();
                    const defender = this.getCurrentDefender();
                    const attackingCard = {
                        ...gameState.attackerCardChoice
                    }; // Clone ƒë·ªÉ th√™m d·ªØ li·ªáu
                    const defendingCard = {
                        ...gameState.battlefield[gameState.attackerZoneChoice].defenderCard,
                    }; // Clone

                    let winnerId = null;
                    if (clashResult === "attacker") winnerId = attacker.id;
                    if (clashResult === "defender") winnerId = defender.id;

                    // G√°n ƒëi·ªÉm giao tranh v√†o l√° b√†i ƒë·ªÉ hi·ªÉn th·ªã
                    attackingCard.clashPoints = attackerClashPoints;
                    defendingCard.clashPoints = defenderClashPoints;

                    // X√°c ƒë·ªãnh th·∫ª c·ªßa ng∆∞·ªùi ch∆°i (player) v√† ƒë·ªëi th·ªß (opponent)
                    const playerIsAttacker = this.getPlayer(0).id === attacker.id;

                    gameState.detailedHistory.push({
                        round: gameState.round,
                        turn: gameState.turn,
                        winnerId: winnerId,
                        pointIncreaseInfo: pointIncreaseInfo,
                        attackerScoreChange,
                        defenderScoreChange,
                        player: {
                            id: 0,
                            role: playerIsAttacker ? "T·∫•n C√¥ng" : "Ph√≤ng Th·ªß",
                            card: playerIsAttacker ? attackingCard : defendingCard,
                        },
                        opponent: {
                            id: 1,
                            role: !playerIsAttacker ? "T·∫•n C√¥ng" : "Ph√≤ng Th·ªß",
                            card: !playerIsAttacker ? attackingCard : defendingCard,
                        },
                    });
                }
                // D√°n ƒë·ªÉ THAY TH·∫æ TO√ÄN B·ªò h√†m showDetailedHistoryModal() c≈©
                showDetailedHistoryModal() {
                    const createMiniCardHTML = (card, role, scoreChange) => {
                        if (!card) return '<div class="mini-card"></div>';

                        const roleTag =
                            role === "T·∫•n C√¥ng" ?
                            '<div class="mini-card__tag tag--attacker">T·∫•n C√¥ng</div>' :
                            '<div class="mini-card__tag tag--defender">Ph√≤ng Th·ªß</div>';

                        // Tag hi·ªÉn th·ªã ƒëi·ªÉm c·ªông/tr·ª´
                        let scoreChangeTag = "";
                        if (scoreChange !== 0) {
                            const changeClass = scoreChange > 0 ? "win" : "loss";
                            const sign = scoreChange > 0 ? "+" : "";
                            scoreChangeTag = `<div class="mini-card__tag tag--score-change ${changeClass}">${sign}${scoreChange}</div>`;
                        }

                        return `
      <div class="mini-card">
          <div class="mini-card__symbol">${SYMBOLS[card.type] || "?"}</div>
          <div class="mini-card__points">${card.clashPoints || "?"} ƒêi·ªÉm</div>
          <div class="mini-card__tags">
              ${roleTag}
              ${scoreChangeTag}
          </div>
      </div>
    `;
                    };

                    let contentHTML = '<ul class="detailed-history-list">';
                    if (gameState.detailedHistory.length === 0) {
                        contentHTML += "<li>Ch∆∞a c√≥ l·ªãch s·ª≠.</li>";
                    } else {
                        [...gameState.detailedHistory].reverse().forEach((turn) => {
                            let resultText, resultClass;
                            if (turn.winnerId === null) {
                                resultText = "H√≤a";
                                resultClass = "draw-text";
                            } else if (turn.winnerId === 0) {
                                resultText = "Th·∫Øng";
                                resultClass = "win-text";
                            } else {
                                resultText = "Thua";
                                resultClass = "loss-text";
                            }

                            // L·∫•y ƒë√∫ng ƒëi·ªÉm c·ªông/tr·ª´ cho m·ªói ng∆∞·ªùi
                            const playerScoreChange =
                                turn.player.role === "T·∫•n C√¥ng" ?
                                turn.attackerScoreChange :
                                turn.defenderScoreChange;
                            const opponentScoreChange =
                                turn.opponent.role === "T·∫•n C√¥ng" ?
                                turn.attackerScoreChange :
                                turn.defenderScoreChange;

                            const playerCardHTML = createMiniCardHTML(
                                turn.player.card,
                                turn.player.role,
                                playerScoreChange
                            );
                            const opponentCardHTML = createMiniCardHTML(
                                turn.opponent.card,
                                turn.opponent.role,
                                opponentScoreChange
                            );

                            // T·∫°o c√°c tag chung cho l∆∞·ª£t ƒë·∫•u
                            let turnTagsHTML = `<div class="history-item__tags">
        <div class="mini-card__tag ${resultClass}">${resultText}</div>`;
                            if (turn.pointIncreaseInfo) {
                                turnTagsHTML += `
          <div class="mini-card__tag tag--points-up">
            ${SYMBOLS[turn.pointIncreaseInfo.cardType]} +1
          </div>
        `;
                            }
                            turnTagsHTML += `</div>`;

                            contentHTML += `
        <li>
            <div class="history-item">
                <div class="history-item__header">
                    <strong>V√≤ng ${turn.round} - V√°n ${turn.turn}</strong>
                </div>
                <div class="history-item__clash">
                    ${playerCardHTML}
                    <div class="history-item__vs">VS</div>
                    ${opponentCardHTML}
                </div>
                ${turnTagsHTML}
            </div>
        </li>`;
                        });
                    }
                    contentHTML += "</ul>";

                    this.showInfoModal({
                        title: "L·ªãch S·ª≠ ƒê·ªëi ƒê·∫ßu",
                        content: contentHTML,
                        modalClass: "detailed-history-modal",
                    });
                }
                handlePostDraw(player) {
                    let basicCards = player.hand.filter((c) => c.isBasic);
                    while (basicCards.length > 6) {
                        const normalCardIndex = player.hand.findIndex(
                            (c) => c.isBasic && !c.isPriority
                        );
                        if (normalCardIndex > -1) {
                            const removedCard = player.hand.splice(normalCardIndex, 1)[0];

                            gameState.commonDeck.push(removedCard);
                            this.log(
                                `Tay b√†i v∆∞·ª£t qu√° 6. ƒê√£ t·ª± ƒë·ªông b·ªè l√° ${removedCard.type} Th∆∞·ªùng.`
                            );
                        } else {
                            const priorityCardIndex = player.hand.findIndex(
                                (c) => c.isPriority
                            );
                            const removedCard = player.hand.splice(priorityCardIndex, 1)[0];
                            removedCard.isPriority = false;
                            gameState.commonDeck.push(removedCard);
                            this.log(
                                `Tay b√†i v∆∞·ª£t qu√° 6. ƒê√£ t·ª± ƒë·ªông b·ªè l√° ${removedCard.type} ∆Øu Ti√™n.`
                            );
                        }
                        basicCards = player.hand.filter((c) => c.isBasic);
                    }
                    this.log("R√∫t b√†i ho√†n t·∫•t. Ti·∫øp t·ª•c tr·∫≠n ƒë·∫•u.");
                    this.setPhase(PHASES.DEFENDER_PLACE_CARDS);
                }
                ai_handlePrioritySelection(player, drawnCards, neededCount) {
                    for (let i = 0; i < neededCount; i++) {
                        const randomIndex = Math.floor(Math.random() * drawnCards.length);
                        const selectedCard = drawnCards.splice(randomIndex, 1)[0];
                        selectedCard.isPriority = true;
                        player.hand.push(selectedCard);
                    }
                    player.hand.push(...drawnCards);
                    this.log(`AI ƒë√£ ch·ªâ ƒë·ªãnh ${neededCount} Th·∫ª ∆Øu Ti√™n m·ªõi.`);
                    this.handlePostDraw(player);
                }
                resetBattlefield() {
                    gameState.battlefield = {
                        main: {
                            defenderCard: null,
                            attackerCard: null
                        },
                        side: {
                            defenderCard: null,
                            attackerCard: null
                        },
                    };
                    gameState.attackerCardChoice = null;
                    gameState.attackerZoneChoice = null;
                    DOMElements.board.opponentMainSlot.innerHTML = "";
                    DOMElements.board.opponentSideSlot.innerHTML = "";
                    DOMElements.board.playerMainSlot.innerHTML = "";
                    DOMElements.board.playerSideSlot.innerHTML = "";
                }
                endGame() {
                    localStorage.removeItem('savedGame');
                    gameState.phase = PHASES.GAME_OVER;
                    const p0 = gameState.players[0],
                        p1 = gameState.players[1];
                    let text;
                    if (p0.score > p1.score) text = "B·∫°n ƒë√£ chi·∫øn th·∫Øng!";
                    else if (p1.score > p0.score) text = "B·∫°n ƒë√£ thua!";
                    else text = "H√≤a ƒëi·ªÉm!";
                    this.showConfirmationBar({
                        text: `K·∫æT TH√öC TR·∫¨N ƒê·∫§U. ${text}<br>T·ª∑ s·ªë: ${p0.score} - ${p1.score}`,
                        options: [{
                            text: "Ch∆°i L·∫°i",
                            value: "restart"
                        }],
                        onSelect: () => window.location.reload(),
                        isRoleSelection: true,
                    });
                }
                showScoreChange(playerId, change) {
                    if (change === 0) return;
                    const player = this.getPlayer(playerId);

                    // =========================================================
                    // S·ª¨A ƒê·ªîI C·ªêT L√ïI:
                    // Thay v√¨ d·ª±a v√†o player.isAI, ch√∫ng ta so s√°nh v·ªõi activePlayerId
                    // ƒë·ªÉ bi·∫øt ng∆∞·ªùi ch∆°i ƒë√≥ ƒëang ·ªü tr√™n hay ·ªü d∆∞·ªõi m√†n h√¨nh.
                    const isPlayerInBottomArea = player.id === this.activePlayerId;
                    const scoreEl = isPlayerInBottomArea ?
                        DOMElements.player.score :
                        DOMElements.opponent.score;
                    // =========================================================

                    const rect = scoreEl.getBoundingClientRect();
                    const changeEl = document.createElement("div");
                    changeEl.className = "score-change";
                    changeEl.textContent = (change > 0 ? "+" : "") + change;
                    changeEl.style.color =
                        change > 0 ? "var(--win-color)" : "var(--loss-color)";
                    changeEl.style.left = `${rect.left + rect.width / 2}px`;
                    changeEl.style.top = `${rect.top + rect.height / 2}px`;
                    DOMElements.dynamicContainer.appendChild(changeEl);
                    setTimeout(() => changeEl.remove(), 1500);
                }
                // THAY TH·∫æ TO√ÄN B·ªò H√ÄM N√ÄY
                async ai_finalDecisionDefender() {
                    if (Math.random() < 0.4) {
                        const bf = gameState.battlefield;
                        [bf.main.defenderCard, bf.side.defenderCard] = [
                            bf.side.defenderCard,
                            bf.main.defenderCard,
                        ];
                        this.render();
                        this.log("ƒê·ªëi th·ªß Ph√≤ng Th·ªß ƒë√£ tr√°o ƒë·ªïi b√†i!");

                        gameState.lastTurnActionInfo = "ƒê·ªëi ph∆∞∆°ng ƒë√£ TR√ÅO B√ÄI ph√≤ng th·ªß.";
                        await this.sleep(1500);
                    } else {
                        this.log("ƒê·ªëi th·ªß Ph√≤ng Th·ªß quy·∫øt ƒë·ªãnh gi·ªØ nguy√™n v·ªã tr√≠.");

                        gameState.lastTurnActionInfo = null;
                        await this.sleep(1500);
                    }
                }
                async ai_finalDecisionAttacker() {
                    if (Math.random() < 0.3) {
                        gameState.battlefield[gameState.attackerZoneChoice].attackerCard = null;
                        gameState.attackerZoneChoice =
                            gameState.attackerZoneChoice === ZONES.MAIN ?
                            ZONES.SIDE :
                            ZONES.MAIN;
                        gameState.battlefield[gameState.attackerZoneChoice].attackerCard =
                            gameState.attackerCardChoice;
                        this.render();
                        this.log("ƒê·ªëi Th·ªß T·∫•n C√¥ng ƒë√£ ƒë·ªïi khu v·ª±c!");

                        gameState.lastTurnActionInfo = "ƒê·ªëi ph∆∞∆°ng ƒë√£ ƒê·ªîI KHU V·ª∞C t·∫•n c√¥ng.";
                        await this.sleep(1500);
                    } else {
                        this.log("ƒê·ªëi th·ªß T·∫•n C√¥ng quy·∫øt ƒë·ªãnh gi·ªØ nguy√™n m·ª•c ti√™u.");

                        gameState.lastTurnActionInfo = null;
                        await this.sleep(1500);
                    }
                }
                async ai_placeDefenseCards() {
                    await this.sleep(1000);
                    const ai = this.getCurrentDefender();

                    // --- S·ª¨A TO√ÄN B·ªò LOGIC CH·ªåN B√ÄI C·ª¶A AI ---
                    let card1 = null,
                        card2 = null;

                    // L·∫•y ra t·∫•t c·∫£ c√°c c·∫∑p b√†i c√≥ th·ªÉ c√≥ t·ª´ tay c·ªßa AI
                    let allPairs = [];
                    for (let i = 0; i < ai.hand.length; i++) {
                        for (let j = i + 1; j < ai.hand.length; j++) {
                            allPairs.push([ai.hand[i], ai.hand[j]]);
                        }
                    }

                    // L·ªçc ra c√°c c·∫∑p h·ª£p l·ªá (c√≥ √≠t nh·∫•t 1 th·∫ª ∆Øu Ti√™n v√† kh√¥ng ch·ª©a 2 th·∫ª ƒê·∫∑c Bi·ªát)
                    const validPairs = allPairs.filter((pair) => {
                        const hasPriority = pair[0].isPriority || pair[1].isPriority;
                        const notTwoSpecials = !(pair[0].isSpecial && pair[1].isSpecial);
                        return hasPriority && notTwoSpecials;
                    });

                    if (validPairs.length > 0) {
                        // N·∫øu c√≥ c·∫∑p h·ª£p l·ªá, ch·ªçn ng·∫´u nhi√™n m·ªôt c·∫∑p
                        const chosenPair =
                            validPairs[Math.floor(Math.random() * validPairs.length)];
                        card1 = chosenPair[0];
                        card2 = chosenPair[1];
                    } else {
                        // Tr∆∞·ªùng h·ª£p r·∫•t hi·∫øm: kh√¥ng c√≥ c·∫∑p n√†o h·ª£p l·ªá, b√°o l·ªói v√† d·ª´ng (c·∫ßn x·ª≠ l√Ω th√™m n·∫øu mu·ªën game ti·∫øp t·ª•c)
                        // Logic CHECK_DRAW m·ªõi s·∫Ω g·∫ßn nh∆∞ lo·∫°i b·ªè ho√†n to√†n tr∆∞·ªùng h·ª£p n√†y.
                        this.log(
                            `L·ªñI: AI ${ai.name} kh√¥ng t√¨m th·∫•y c·∫∑p b√†i ph√≤ng th·ªß h·ª£p l·ªá!`
                        );
                        return;
                    }

                    // Ph√¢n ng·∫´u nhi√™n 2 l√° b√†i v√†o 2 khu v·ª±c
                    if (Math.random() < 0.5) {
                        gameState.battlefield.main.defenderCard = card1;
                        gameState.battlefield.side.defenderCard = card2;
                    } else {
                        gameState.battlefield.main.defenderCard = card2;
                        gameState.battlefield.side.defenderCard = card1;
                    }
                    let priorityOnBoard = 0;
                    if (gameState.battlefield.main.defenderCard?.isPriority)
                        priorityOnBoard++;
                    if (gameState.battlefield.side.defenderCard?.isPriority)
                        priorityOnBoard++;
                    ai.priorityCardsUsedThisRound = priorityOnBoard;
                    ai.hand = ai.hand.filter(
                        (c) => c.id !== card1.id && c.id !== card2.id
                    );
                    this.log("ƒê·ªëi th·ªß ƒë√£ ƒë·∫∑t b√†i.");
                    await this.sleep(1000);
                    this.setPhase(PHASES.ATTACKER_CHOOSE_CARD);
                }
            }

            // THAY TH·∫æ TO√ÄN B·ªò KH·ªêI LOGIC KH·ªûI ƒê·ªòNG GAME B·∫∞NG KH·ªêI M·ªöI N√ÄY

            const game = new Game();
            const modeModal = document.getElementById('game-mode-modal');
            const nameModal = document.getElementById('player-name-modal');

            // H√†m hi·ªÉn th·ªã modal nh·∫≠p t√™n
            function showNameModal(mode) {
                const inputsContainer = document.getElementById('player-name-inputs');
                inputsContainer.innerHTML = ''; // X√≥a input c≈©

                if (mode === 'pvai') {
                    inputsContainer.innerHTML = `
            <input type="text" id="player1-name-input" placeholder="T√™n c·ªßa b·∫°n" style="padding: 0.5rem; font-size: 1rem; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-surface-2); color: var(--text-primary);">
        `;
                } else { // pvp
                    inputsContainer.innerHTML = `
            <input type="text" id="player1-name-input" placeholder="T√™n Ng∆∞·ªùi Ch∆°i 1" style="padding: 0.5rem; font-size: 1rem; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-surface-2); color: var(--text-primary);">
            <input type="text" id="player2-name-input" placeholder="T√™n Ng∆∞·ªùi Ch∆°i 2" style="padding: 0.5rem; font-size: 1rem; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-surface-2); color: var(--text-primary);">
        `;
                }

                modeModal.style.display = 'none';
                nameModal.style.display = 'flex';

                document.getElementById('start-game-btn').onclick = () => {
                    // X√≥a game ƒë√£ l∆∞u khi b·∫Øt ƒë·∫ßu game m·ªõi
                    localStorage.removeItem('savedGame');

                    const name1 = document.getElementById('player1-name-input').value.trim() || (mode === 'pvai' ? 'B·∫°n' : 'Ng∆∞·ªùi Ch∆°i 1');
                    let name2;
                    if (mode === 'pvp') {
                        name2 = document.getElementById('player2-name-input').value.trim() || 'Ng∆∞·ªùi Ch∆°i 2';
                    } else {
                        name2 = 'ƒê·ªëi Th·ªß';
                    }

                    nameModal.style.display = 'none';
                    game.init(mode, name1, name2);
                };
            }

            // H√†m ki·ªÉm tra v√† kh·ªüi t·∫°o giao di·ªán ban ƒë·∫ßu
            function initializeUI() {
                const savedGame = localStorage.getItem('savedGame');
                if (savedGame) {
                    const state = JSON.parse(savedGame);
                    const continueSection = document.getElementById('continue-game-section');
                    const continueBtn = document.getElementById('continue-btn');

                    continueBtn.innerHTML = `Ti·∫øp T·ª•c (V√≤ng ${state.round})<br><span style="font-size:0.9rem; font-weight: 400;">${state.players[0].name}: ${state.players[0].score} - ${state.players[1].name}: ${state.players[1].score}</span>`;

                    continueSection.style.display = 'block';

                    continueBtn.onclick = () => {
                        modeModal.style.display = 'none';
                        game.resumeGame(state);
                    };
                }

                document.getElementById('pvai-btn').onclick = () => showNameModal('pvai');
                document.getElementById('pvp-btn').onclick = () => showNameModal('pvp');
            }

            // Ch·∫°y h√†m kh·ªüi t·∫°o khi trang ƒë∆∞·ª£c t·∫£i
            initializeUI();
        </script>
</body>

</html>
