<!doctype html>
<html lang="vi">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
        <title>SLAMizz</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700;900&display=swap"
            rel="stylesheet"
        />
        <style>
            /* Dán dòng này ngay dưới thẻ <style> hoặc trong :root */
            * {
                box-sizing: border-box;
            }
            :root {
                --grid-gap: clamp(2px, 0.5vmin, 4px);
                --cell-size: 40px;
                --font-size: calc(var(--cell-size) * 0.7);
                --primary-accent: #ffc700;
                --secondary-accent: #42a5f5;
                --dark-blue: #1d1a53;
                --light-text: #a8a2d2;
                --danger-color: #ef5350;
                --success-color: #66bb6a;
                --incorrect-color: #546e7a;
            }

            html {
                scroll-behavior: smooth;
            }
            body {
                font-family: "Montserrat", sans-serif;
                background: radial-gradient(circle at top right, #3a32a3 0%, #1d1a53 40%, #0f0d2a 100%);
                color: white;
                overflow: hidden;
                height: 100dvh;
                -webkit-tap-highlight-color: transparent;
            }

            .page {
                width: 100%;
                height: 100dvh;
                display: none;
                flex-direction: column;
                align-items: center;
                padding: 20px;
                box-sizing: border-box;
                opacity: 0;
                transition: opacity 0.5s ease;
                overflow-y: auto;
            }
            .page.active {
                display: flex;
                opacity: 1;
            }
            .page-title {
                font-size: 2rem;
                font-weight: 900;
                color: var(--primary-accent);
                margin-bottom: 2rem;
                text-align: center;
            }

            #lobby-page {
                justify-content: flex-start;
            }
            #puzzle-list {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                gap: 1rem;
                width: 100%;
                max-width: 1200px;
            }
            .puzzle-card,
            .new-puzzle-card {
                background: rgba(255, 255, 255, 0.05);
                border-radius: 16px;
                padding: 20px;
                border: 1px solid rgba(255, 255, 255, 0.1);
                box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
                backdrop-filter: blur(5px);
                transition:
                    transform 0.2s,
                    box-shadow 0.2s;
                cursor: pointer;
            }
            .puzzle-card:hover {
                transform: translateY(-5px);
                box-shadow: 0 8px 40px rgba(0, 0, 0, 0.2);
            }
            .puzzle-card-title {
                font-weight: 700;
                font-size: 1.2rem;
                color: var(--secondary-accent);
                margin-bottom: 0.5rem;
                word-break: break-word;
            }
            .puzzle-card-meta {
                font-size: 0.8rem;
                color: var(--light-text);
                margin-bottom: 1rem;
            }
            .puzzle-card-actions {
                display: flex;
                gap: 0.5rem;
                margin-top: 1.5rem;
            }
            .new-puzzle-card {
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                border-style: dashed;
            }
            .new-puzzle-card .plus-icon {
                font-size: 3rem;
                color: var(--primary-accent);
                font-weight: 300;
            }
            .new-puzzle-card .new-puzzle-text {
                font-size: 1.1rem;
                font-weight: 700;
                color: var(--primary-accent);
                margin-top: 0.5rem;
            }

            #creation-page {
                justify-content: flex-start;
                padding-bottom: 100px;
            }
            .word-card {
                background: rgba(255, 255, 255, 0.05);
                border-radius: 8px;
                padding: 20px;
                margin-bottom: 1rem;
                width: 100%;
                max-width: 500px;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }
            .card-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1rem;
            }
            .card-title {
                font-weight: 700;
                font-size: 1.1rem;
                color: var(--secondary-accent);
            }
            .remove-word-btn {
                background: none;
                border: none;
                color: #e57373;
                font-size: 1.5rem;
                cursor: pointer;
                padding: 0;
                line-height: 1;
            }
            .form-group-material {
                position: relative;
                margin-top: 10px;
            }
            .form-group-material input {
                width: 100%;
                background: transparent;
                border: none;
                border-bottom: 2px solid var(--light-text);
                color: white;
                padding: 8px 0;
                font-size: 1rem;
                outline: none;
                transition: border-color 0.3s;
            }
            .form-group-material label {
                position: absolute;
                top: 8px;
                left: 0;
                color: var(--light-text);
                pointer-events: none;
                transition: all 0.2s ease-out;
            }
            .form-group-material input:focus + label,
            .form-group-material input:not(:placeholder-shown) + label {
                top: -14px;
                font-size: 0.75rem;
                color: var(--primary-accent);
            }
            .form-group-material input:focus {
                border-bottom-color: var(--primary-accent);
            }

            #add-word-fab {
                position: fixed;
                bottom: 80px;
                right: 20px;
                width: 56px;
                height: 56px;
                background: linear-gradient(145deg, var(--primary-accent), #ffb300);
                border-radius: 50%;
                border: none;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
                color: var(--dark-blue);
                font-size: 2.25rem;
                font-weight: 300;
                cursor: pointer;
                z-index: 100;
            }
            .creation-footer {
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                padding: 15px;
                background: linear-gradient(to top, rgba(15, 13, 42, 1), rgba(15, 13, 42, 0));
                display: flex;
                justify-content: center;
                gap: 0.75rem;
                z-index: 50;
            }
            .action-btn {
                background: linear-gradient(145deg, #1e88e5, #1565c0);
                color: white;
                border: 1px solid #64b5f6;
                border-radius: 50px;
                padding: 10px 20px;
                font-size: 0.875rem;
                font-weight: 700;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                transition: all 0.2s ease-in-out;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 0.5rem;
                white-space: nowrap;
            }
            .action-btn.icon-btn {
                padding: 10px;
                width: 44px;
                height: 44px;
            }
            .action-btn svg {
                width: 1.5em;
                height: 1.5em;
            }
            .action-btn.primary {
                background: linear-gradient(145deg, var(--primary-accent), #ffb300);
                color: var(--dark-blue);
                border-color: #fff;
            }

            #game-page {
                justify-content: flex-start;
                padding: 10px 0;
                overflow: hidden;
            }
            #game-header {
                display: flex;
                width: 100%;
                justify-content: space-between;
                align-items: center;
                padding: 5px 15px;
                flex-shrink: 0;
            }
            #game-stats {
                display: flex;
                gap: 1rem;
                align-items: center;
                font-size: 1.1rem;
                font-weight: 700;
                color: var(--light-text);
                flex-grow: 1;
                justify-content: center;
            }
            #score-display {
                min-width: 0.2rem;
                text-align: center;
            }
            #word-timer {
                background-color: rgba(0, 0, 0, 0.3);
                padding: 2px 10px;
                border-radius: 4px;
                color: var(--primary-accent);
            }
            .game-area {
                width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                flex-grow: 1;
                min-height: 0;
            }

            #grid-wrapper {
                position: relative;
            }
            #grid-container {
                display: grid;
                gap: var(--grid-gap);
                perspective: 1000px;
                transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); /* Thêm dòng này */
            }
            #grid-container.word-zoomed {
                transform: scale(1.05);
            }
            #number-overlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none; /* Lớp phủ không chặn click */
                z-index: 100; /* Đảm bảo số nằm trên cùng */
            }
            .word-number-label {
                position: absolute;
                font-weight: 700;
                color: white;
                background-color: transparent;
                border: 1.5px solid white;
                border-radius: 0;
                font-size: calc(var(--cell-size) * 0.5);
                display: none;
                width: calc(var(--cell-size) * 0.75);
                height: calc(var(--cell-size) * 0.75);
                justify-content: center;
                align-items: center;
                opacity: 0;

                pointer-events: auto;
                cursor: pointer;
                transition: transform 0.2s;
            }
            .word-number-label.visible {
                display: flex;
                animation: label-fade-in 0.3s forwards;
            }
            .word-number-label.hiding-right {
                animation: slide-out-right 0.4s forwards ease-out;
            }
            .word-number-label.hiding-down {
                animation: slide-out-down 0.4s forwards ease-out;
            }

            .cell {
                width: var(--cell-size);
                height: var(--cell-size);
                position: relative;
            }
            .playable {
                width: 100%;
                height: 100%;
                transition:
                    opacity 0.3s ease,
                    transform 0.3s ease;
                cursor: pointer;
            }
            .cell-face {
                position: absolute;
                width: 100%;
                height: 100%;
                display: flex;
                justify-content: center;
                align-items: center;
                font-weight: 900;
                border-radius: 0;
                font-size: var(--font-size);
                transition:
                    background 0.3s,
                    color 0.3s,
                    border 0.3s,
                    transform 0.3s;
            }
            /* --- CSS MỚI CHO HIỆU ỨNG TRẢ LỜI SAI --- */
            @keyframes zoom-in-incorrect {
                from {
                    transform: scale(0.4);
                    opacity: 0;
                }
                to {
                    transform: scale(1);
                    opacity: 1;
                    background: var(--incorrect-color); /* Nền màu xám đậm */
                }
            }
            /* --- CSS MỚI CHO HIỆU ỨNG XÓA CHỮ (BACKSPACE) --- */
            @keyframes zoom-out-delete {
                from {
                    transform: scale(1);
                    opacity: 1;
                }
                to {
                    transform: scale(0.4);
                    opacity: 0;
                }
            }

            /* Class áp dụng khi xóa */
            .playable.anim-delete .cell-front {
                animation: zoom-out-delete 0.15s ease-in forwards;
                /* Giữ màu chữ hiện tại để nó mờ dần chứ không mất màu đột ngột */
                color: var(--dark-blue);
                box-shadow: inset 0 0 0 1px var(--secondary-accent);
            }

            /* Class áp dụng khi người dùng trả lời sai */
            .playable.is-locked .cell-front {
                background: var(--incorrect-color);
                /* Thêm viền trắng vào cùng với hiệu ứng đổ bóng cũ */
                box-shadow:
                    inset 0 0 10px rgba(0, 0, 0, 0.3),
                    inset 0 0 0 1.5px white;
                border-color: #546e7a;
            }
            #grid-wrapper.selection-active .playable {
                opacity: 0.4;
            }
            #grid-wrapper.selection-active .playable.selected-word {
                opacity: 1;
                /* transform: scale(1.03);  <-- Xóa dòng này */
                z-index: 10;
            }
            .cell-front {
                background: linear-gradient(145deg, #ffd700, #ffb300);
                box-shadow:
                    inset 0 -2px 4px rgba(0, 0, 0, 0.2),
                    0 2px 5px rgba(0, 0, 0, 0.3);
                box-shadow:
                    inset 0 -2px 4px rgba(0, 0, 0, 0.2),
                    0 2px 5px rgba(0, 0, 0, 0.3),
                    inset 0 0 0 1px #ffc700;
            }
            .cell-front .letter-pop-in {
                animation: letter-pop-in 0.3s ease-out forwards;
                display: inline-block;
            }
            .playable.is-locked .cell-front {
                background: var(--incorrect-color);
                /* Thêm viền trắng vào cùng với hiệu ứng đổ bóng cũ */
                box-shadow:
                    inset 0 0 10px rgba(0, 0, 0, 0.3),
                    inset 0 0 0 1.5px white;
                border-color: #546e7a;
            }

            .game-hud {
                width: 100%;
                display: flex;
                flex-direction: column;
                align-items: center;
                z-index: 200;
                flex-shrink: 0;
            }
            .keyboard-wrapper {
                width: 100%;
                background: var(--dark-blue);
                border-top: 1px solid var(--light-text);
                transform: translateY(100%);
                transition: transform 0.4s ease-out;
                padding-top: 10px;
            }
            .keyboard-wrapper.visible {
                transform: translateY(0);
            }
            #clue-area {
                width: 100%;
                max-width: 600px;
                color: var(--primary-accent);
                text-align: center;
                padding: 12px;
            }
            #clue-text {
                font-size: clamp(1rem, 4vw, 1.25rem);
                font-weight: 700;
                min-height: 1.25rem;
                transition: opacity 0.3s;
            }
            #clue-text.hidden {
                opacity: 0;
            }

            #slam-button-container {
                display: flex;
                justify-content: center;
                padding: 50px 0 0px 0; /* Tăng padding để tách biệt */
                width: 100%;
                z-index: 50; /* Thấp hơn bàn phím (200) để bị che khi bàn phím hiện */
                display: none;
            }
            #slam-btn {
                background: linear-gradient(145deg, var(--danger-color), #c62828);
                color: white;
                border: 2px solid #ff8a80;
                border-radius: 50px;
                padding: 8px 24px;
                font-size: 1rem;
                font-weight: 900;
                text-transform: uppercase;
                letter-spacing: 1.5px;
                box-shadow: 0 5px 15px rgba(239, 83, 80, 0.5);
                animation: pulse 2s infinite;
            }
            #slam-btn:disabled {
                background: #555 !important;
                cursor: not-allowed;
                animation: none;
                opacity: 0.5;
                box-shadow: none;
                border-color: #777;
            }
            @keyframes pulse {
                0% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.05);
                }
                100% {
                    transform: scale(1);
                }
            }

            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                backdrop-filter: blur(5px);
                z-index: 10000;
                display: none;
                justify-content: center;
                align-items: center;
                opacity: 0;
                transition: opacity 0.3s;
            }
            .modal-overlay.visible {
                display: flex;
                opacity: 1;
            }
            .modal-content {
                background: var(--dark-blue);
                padding: 30px;
                border-radius: 16px;
                text-align: center;
                border: 1px solid var(--secondary-accent);
                max-width: 90%;
            }
            .modal-content h2 {
                font-size: 1.5rem;
                margin-bottom: 1rem;
                color: var(--primary-accent);
            }
            .modal-content p {
                margin-bottom: 2rem;
            }
            .modal-actions {
                display: flex;
                justify-content: center;
                gap: 1rem;
            }

            #virtual-keyboard {
                width: 100%;
                padding: 5px;
                background: rgba(0, 0, 0, 0.2);
                user-select: none;
            }
            .keyboard-row {
                display: flex;
                justify-content: center;
                margin: 4px 0;
            }
            .key {
                height: 44px;
                margin: 0 2px;
                border-radius: 6px;
                border: none;
                background: linear-gradient(145deg, #5c6bc0, #3f51b5);
                color: white;
                font-weight: 700;
                box-shadow: 0 3px #1a237e;
                font-size: 1rem;
                flex-grow: 1;
                cursor: pointer;
                transition: all 0.1s ease;
                flex-grow: 1;
                flex-basis: 0; /* Bắt buộc chiều rộng cơ sở là 0, bỏ qua độ dài chữ */
                min-width: 0; /* Cho phép nút co nhỏ tối đa nếu cần */
                padding: 0; /* Xóa padding thừa để tránh vỡ layout trên màn hình nhỏ */
            }
            .key:active:not(:disabled) {
                background: #3f51b5;
                transform: translateY(2px);
                box-shadow: 0 1px #1a237e;
            }
            .key.special {
                flex-grow: 1.5;
                background: linear-gradient(145deg, #78909c, #546e7a);
                box-shadow: 0 3px #263238;
            }
            .key.enter {
                background: linear-gradient(145deg, var(--primary-accent), #ffb300);
                box-shadow: 0 3px #ff8f00;
                color: var(--dark-blue);
            }

            .key.enter.action-cancel {
                background: #546e7a !important; /* Màu xám xanh */
                box-shadow: 0 3px #263238 !important; /* Bóng đổ màu tối để giữ độ cao nút */
                color: white !important;
            }
            .key:disabled {
                background: var(--incorrect-color);
                cursor: not-allowed;
                opacity: 0.5;
                box-shadow: 0 3px #263238;
            }

            #toast-container {
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                z-index: 9999;
                width: 90%;
                max-width: 500px;
            }
            .toast {
                background-color: #333;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
                margin-bottom: 10px;
                text-align: center;
                opacity: 0;
                transform: translateY(-20px);
                animation: fadeInDown 0.5s forwards;
            }
            .toast.error {
                background-color: var(--danger-color);
            }
            .toast.success {
                background-color: var(--success-color);
            }
            .toast.exit {
                animation: fadeOutUp 0.5s forwards;
            }

            @keyframes fadeInDown {
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
            @keyframes fadeOutUp {
                to {
                    opacity: 0;
                    transform: translateY(-20px);
                }
            }
            @keyframes letter-pop-in {
                0% {
                    transform: scale(0.5);
                    opacity: 0;
                }
                100% {
                    transform: scale(1);
                    opacity: 1;
                }
            }
            @keyframes label-fade-in {
                from {
                    opacity: 0;
                }
                to {
                    opacity: 1;
                }
            }
            @keyframes slide-out-right {
                from {
                    opacity: 1;
                    transform: translate(-100%, -50%) scale(1);
                }
                to {
                    opacity: 0;
                    transform: translate(-50%, -50%) scale(0.5);
                }
            }
            @keyframes slide-out-down {
                from {
                    opacity: 1;
                    transform: translate(-50%, -100%) scale(1);
                }
                to {
                    opacity: 0;
                    transform: translate(-50%, -50%) scale(0.5);
                }
            }
            /* --- CSS MỚI CHO HIỆU ỨNG TRẢ LỜI ĐÚNG --- */
            @keyframes zoom-in-orange {
                from {
                    transform: scale(0.4);
                    opacity: 0;
                    background: white;
                    color: var(--dark-blue);
                }
                to {
                    transform: scale(1);
                    opacity: 1;
                    background: #f57c00; /* Kết thúc ở màu cam đậm */
                    color: white;
                }
            }

            @keyframes zoom-in-white {
                from {
                    transform: scale(0.4);
                    opacity: 0;
                    background: #f57c00; /* Bắt đầu từ màu cam đậm */
                    color: white;
                }
                to {
                    transform: scale(1);
                    opacity: 1;
                    background: white; /* Kết thúc ở màu trắng (đã giải) */
                    color: var(--dark-blue);
                }
            }
            .playable.is-solved .cell-front {
                background: white;
                color: var(--dark-blue);
                box-shadow: inset 0 0 0 1px var(--secondary-accent);
            }
            /* Class kích hoạt Giai đoạn 1: Zoom ra màu cam */
            /* Class kích hoạt Giai đoạn 1: Zoom ra màu cam */
            .anim-correct-phase1 .cell-front {
                animation: zoom-in-orange 0.25s ease-out forwards;
            }

            /* Quy tắc mới có độ ưu tiên cao hơn để đảm bảo viền trắng được áp dụng đồng nhất */
            .playable.anim-correct-phase1 .cell-front {
                box-shadow: inset 0 0 0 1.5px white;
            }

            /* Class kích hoạt Giai đoạn 2: Zoom về màu trắng */
            .anim-correct-phase2 .cell-front {
                animation: zoom-in-white 0.25s ease-out forwards;
                color: var(--dark-blue); /* Chữ màu xanh của trạng thái đã giải */
                box-shadow: inset 0 0 0 1.5px var(--secondary-accent);
            }
            /* --- CSS MỚI CHO HIỆU ỨNG NHẬP LIỆU --- */
            @keyframes zoom-in-typing {
                from {
                    transform: scale(0.4);
                    opacity: 0;
                    /* Dòng background đã được xóa đi từ đây */
                }
                to {
                    transform: scale(1);
                    opacity: 1;
                    background: white; /* Kết thúc ở màu trắng */
                }
            }

            /* Class áp dụng khi người dùng gõ chữ vào ô */
            /* Class áp dụng khi người dùng gõ chữ vào ô */
            .playable.anim-typing .cell-front {
                animation: zoom-in-typing 0.15s ease-out forwards;
                color: var(--dark-blue);
                box-shadow: inset 0 0 0 1px var(--secondary-accent);
            }
            /* --- CSS MỚI CHO HIỆU ỨNG CHỮ ZOOM KHI TRẢ LỜI ĐÚNG --- */
            @keyframes letter-zoom-back {
                from {
                    transform: scale(0.5);
                    opacity: 0;
                }
                to {
                    transform: scale(1);
                    opacity: 1;
                }
            }

            /* Class để kích hoạt animation cho chữ */
            .cell-front .letter-reveal-anim {
                display: inline-block; /* Bắt buộc để transform hoạt động */
                /* Tốc độ nhanh (0.2s), có hiệu ứng nảy (ease-back) */
                animation: letter-zoom-back 0.2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            }

            #creation-main-view {
                display: flex;
                flex-direction: column;
                width: 100%;
                max-width: 1200px;
                margin: 0 auto;
                gap: 1rem;
            }
            #creation-top-bar {
                display: flex;
                gap: 1rem;
                align-items: center;
            }
            .tab-button {
                padding: 8px 16px;
                border-radius: 8px;
                background: rgba(255, 255, 255, 0.1);
                cursor: pointer;
                border: 1px solid transparent;
            }
            .tab-button.active {
                color: var(--primary-accent);
                border-color: var(--primary-accent);
                font-weight: 700;
            }

            .creation-tab-content {
                display: none;
            }
            .creation-tab-content.active {
                display: block;
            }

            #editor-container {
                display: flex;
                width: 100%;
                height: calc(100dvh - 250px);
                gap: 1rem;
                flex-direction: column;
            }
            @media (min-width: 768px) {
                #editor-container {
                    flex-direction: row;
                }
            }

            #word-bank {
                background: rgba(255, 255, 255, 0.05);
                border-radius: 8px;
                padding: 10px;
                overflow-y: auto;
                flex-shrink: 0;
                width: 100%;
                height: 150px;
            }
            @media (min-width: 768px) {
                #word-bank {
                    width: 220px;
                    height: 100%;
                }
            }

            .bank-word {
                background: var(--secondary-accent);
                color: white;
                padding: 8px;
                margin-bottom: 8px;
                border-radius: 4px;
                font-weight: 700;
                cursor: grab;
                user-select: none;
                display: flex;
                justify-content: space-between;
                align-items: center;
                transition: background 0.2s;
                gap: 8px;
            }
            .word-direction-indicator {
                font-weight: 700;
                color: rgba(255, 255, 255, 0.7);
                width: 16px; /* Dành không gian cố định */
                text-align: center;
            }
            .bank-word:active {
                cursor: grabbing;
                background: #1e88e5;
            }

            .rotate-btn {
                background: rgba(255, 255, 255, 0.2);
                border: none;
                color: white;
                border-radius: 50%;
                width: 24px;
                height: 24px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            #editor-grid-wrapper {
                flex-grow: 1;
                overflow: auto;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 8px;
                padding: 5px;
            }
            #editor-grid {
                display: grid;
                grid-template-columns: repeat(50, 25px);
                grid-template-rows: repeat(50, 25px);
                gap: 1px;
                position: relative; /* <--- THÊM DÒNG NÀY */
            }
            .editor-cell {
                background-color: rgba(255, 255, 255, 0.08);
                width: 25px;
                height: 25px;
            }
            .editor-cell-letter {
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: 900;
                color: var(--primary-accent);
                background: white;
                color: var(--dark-blue);
            }

            /* Đây là style cho "bóng ma" của từ khi bạn kéo đi */
            .word-ghost {
                position: fixed;
                z-index: 9999;
                pointer-events: none;
                display: flex;
                background: var(--success-color);
                opacity: 0.8;
            }
            /* Style khi vị trí đặt không hợp lệ */
            .word-ghost.invalid {
                background: var(--danger-color);
            }
            .ghost-letter {
                width: 26px; /* Kích thước ô + khoảng cách */
                height: 26px;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-weight: 900;
            }
            /* Dán đoạn này vào cuối thẻ <style> */
            .placement-preview {
                position: absolute;
                z-index: 100; /* Nằm dưới bóng ma kéo, trên lưới */
                pointer-events: none;
                display: none; /* Mặc định ẩn */
                flex-direction: row;
                opacity: 0.65;
                transition:
                    top 0.05s,
                    left 0.05s; /* Di chuyển mượt một chút */
            }
            .placement-preview .preview-letter {
                width: 25px;
                height: 25px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: 900;
                color: white;
                background-color: var(--success-color);
                border: 1px solid rgba(255, 255, 255, 0.8);
                box-sizing: border-box;
            }
            .placement-preview.invalid .preview-letter {
                background-color: var(--danger-color);
            }
            /* --- CSS CHO CHẾ ĐỘ THỬ THÁCH MỞ CHỮ --- */
            #reveal-challenge-container {
                display: none;
                flex-direction: column;
                align-items: center;
                width: 100%;
                margin-bottom: 10px;
                animation: fadeInDown 0.3s forwards;
            }
            #reveal-challenge-container.visible {
                display: flex;
            }
            .challenge-question {
                font-size: 1rem;
                color: var(--primary-accent);
                text-align: center;
                margin-bottom: 10px;
                font-weight: 700;
                line-height: 1.4;
                background: rgba(0, 0, 0, 0.4);
                padding: 10px;
                border-radius: 8px;
                border: 1px solid var(--light-text);
            }
            .challenge-input-box {
                width: 60px;
                height: 60px;
                background: white;
                color: var(--dark-blue);
                font-size: 2rem;
                font-weight: 900;
                text-align: center;
                border: 3px solid var(--secondary-accent);
                border-radius: 12px;
                outline: none;
                text-transform: uppercase;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            }
            .challenge-input-box:focus {
                border-color: var(--primary-accent);
                box-shadow: 0 0 15px var(--primary-accent);
            }
            .challenge-feedback {
                margin-top: 5px;
                font-size: 0.9rem;
                height: 1.2rem;
                font-weight: 700;
            }
            .challenge-feedback.correct {
                color: var(--success-color);
            }
            .challenge-feedback.incorrect {
                color: var(--danger-color);
            }
            /* --- CSS MỚI CHO CHẾ ĐỘ SỬA NGUYÊN ÂM --- */

            /* Mới: Thêm .selected-word vào chuỗi selector */
            .playable.selected-word.is-solved.editable-vowel {
                cursor: pointer;
                box-shadow: inset 0 0 0 2px var(--secondary-accent);
            }

            .playable.selected-word.is-solved.editable-vowel .cell-front {
                animation: vowel-pulse 2s infinite;
            }

            @keyframes vowel-pulse {
                0% {
                    background-color: white;
                }
                50% {
                    background-color: #70ffa2;
                } /* Xanh rất nhạt */
                100% {
                    background-color: white;
                }
            }

            /* Trạng thái ĐANG ĐƯỢC CHỌN để sửa dấu (Specific Edit Mode) */
            .playable.specific-editing {
                z-index: 100;
                transform: scale(1.15);
                box-shadow: 0 0 15px var(--primary-accent) !important;
                border: 2px solid var(--primary-accent);
            }

            .playable.specific-editing .cell-front {
                background: white;
                color: var(--dark-blue);
                animation: none; /* Tắt nhấp nháy */
            }
        </style>
    </head>
    <body>
        <div id="toast-container"></div>

        <div id="lobby-page" class="page">
            <div
                style="
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 10px;
                    width: 100%;
                    position: relative;
                "
            >
                <h1 class="page-title" style="margin-bottom: 0">SLAMizz</h1>
                <button
                    id="open-settings-btn"
                    class="action-btn icon-btn"
                    style="
                        width: 30px;
                        height: 30px;
                        padding: 5px;
                        background: transparent;
                        border: none;
                        color: var(--light-text);
                    "
                    title="Cấu hình Server"
                >
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="24"
                        height="24"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        stroke-width="2"
                        stroke-linecap="round"
                        stroke-linejoin="round"
                    >
                        <circle cx="12" cy="12" r="3"></circle>
                        <path
                            d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"
                        ></path>
                    </svg>
                </button>
            </div>
            <div id="puzzle-list" style="margin-top: 2rem"></div>
        </div>
        <div id="creation-page" class="page">
            <div id="creation-main-view">
                <div id="creation-top-bar">
                    <div class="form-group-material" style="flex-grow: 1">
                        <input type="text" id="puzzle-title-input" required placeholder=" " />
                        <label>Tên Bộ Đề</label>
                    </div>
                    <button id="tab-btn-words" class="tab-button active">1. Nhập Từ</button>
                    <button id="tab-btn-arrange" class="tab-button">2. Xếp Lưới</button>
                </div>

                <div id="tab-content-words" class="creation-tab-content active">
                    <div
                        id="word-list-container"
                        class="w-full"
                        style="max-height: calc(100dvh - 250px); overflow-y: auto"
                    ></div>
                </div>

                <div id="tab-content-arrange" class="creation-tab-content">
                    <div id="editor-container">
                        <div id="word-bank"></div>
                        <div id="editor-grid-wrapper">
                            <div id="editor-grid"></div>
                        </div>
                    </div>
                </div>
            </div>
            <button id="add-word-fab" title="Thêm từ mới">+</button>

            <div class="creation-footer">
                <button id="back-to-lobby-btn" class="action-btn" title="Quay Lại">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="24"
                        height="24"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        stroke-width="2"
                        stroke-linecap="round"
                        stroke-linejoin="round"
                    >
                        <line x1="19" y1="12" x2="5" y2="12"></line>
                        <polyline points="12 19 5 12 12 5"></polyline>
                    </svg>
                </button>
                <button id="import-puzzle-btn" class="action-btn icon-btn" title="Nhập bộ đề từ file">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="24"
                        height="24"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        stroke-width="2"
                        stroke-linecap="round"
                        stroke-linejoin="round"
                    >
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                </button>
                <button id="export-puzzle-btn" class="action-btn icon-btn" title="Xuất bộ đề ra file">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="24"
                        height="24"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        stroke-width="2"
                        stroke-linecap="round"
                        stroke-linejoin="round"
                    >
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </button>
                <button
                    id="delete-puzzle-btn"
                    class="action-btn"
                    style="background: linear-gradient(145deg, #c62828, #b71c1c); border-color: #e57373; display: none"
                >
                    Xóa
                </button>
                <button
                    id="upload-github-btn"
                    class="action-btn"
                    title="Tải lên Server"
                    style="background: linear-gradient(145deg, #7b1fa2, #4a148c); border-color: #ba68c8"
                >
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="24"
                        height="24"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        stroke-width="2"
                        stroke-linecap="round"
                        stroke-linejoin="round"
                    >
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                    Upload
                </button>
                <button id="save-puzzle-btn" class="action-btn primary" title="Lưu & Chơi">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="24"
                        height="24"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        stroke-width="3"
                        stroke-linecap="round"
                        stroke-linejoin="round"
                    >
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                </button>
            </div>
        </div>

        <!-- TÌM ĐOẠN HTML CŨ CỦA #game-page VÀ THAY THẾ BẰNG ĐOẠN NÀY -->
        <div id="game-page" class="page">
            <div id="game-header">
                <button id="back-to-lobby-btn-game" class="action-btn icon-btn" title="Về sảnh chờ">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="24"
                        height="24"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        stroke-width="2"
                        stroke-linecap="round"
                        stroke-linejoin="round"
                    >
                        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                        <polyline points="9 22 9 12 15 12 15 22"></polyline>
                    </svg>
                </button>
                <div id="game-stats">
                    <div id="score-display">0</div>
                    <div id="words-solved-stat">0/0</div>
                    <div id="turn-display" style="color: var(--primary-accent)">Lượt 1</div>
                    <div style="display: none" id="timer" class="w-1/3">00:00</div>
                    <div id="word-timer">00:30</div>
                </div>
            </div>

            <!-- KHỐI GAME-AREA ĐÃ ĐƯỢC SỬA ĐỔI: Thêm nút SLAM vào đây -->
            <div class="game-area">
                <div id="grid-wrapper">
                    <div id="number-overlay"></div>
                    <div id="grid-container"></div>
                </div>
                <!-- Vị trí mới của nút SLAM: Nằm dưới bảng, trong vùng game-area -->
                <div id="slam-button-container">
                    <button id="slam-btn">SLAM</button>
                </div>
            </div>

            <!-- KHỐI GAME-HUD ĐÃ ĐƯỢC SỬA ĐỔI: Xóa nút SLAM khỏi đây -->
            <div id="game-hud" class="game-hud">
                <div id="reveal-challenge-container">
                    <div id="challenge-question" class="challenge-question">Câu hỏi sẽ hiện ở đây...</div>
                    <input type="text" id="challenge-input" class="challenge-input-box" maxlength="1" readonly />
                    <div id="challenge-feedback" class="challenge-feedback"></div>
                </div>
                <div id="keyboard-wrapper" class="keyboard-wrapper">
                    <div id="clue-area">
                        <div id="clue-text">Chọn một ô để bắt đầu!</div>
                    </div>
                    <!-- Đã xóa div id="slam-button-container" khỏi đây -->
                    <div id="virtual-keyboard"></div>
                </div>
            </div>
        </div>

        <div class="modal-overlay" id="slam-modal">
            <div class="modal-content">
                <h2>Thử Thách SLAM!</h2>
                <p>
                    Bạn có chắc chắn? Mọi gợi ý và trợ giúp sẽ biến mất. Bạn sẽ phải giải toàn bộ bảng chỉ với trí nhớ
                    của mình.
                </p>
                <div class="modal-actions">
                    <button id="slam-confirm-btn" class="action-btn primary" style="background: var(--danger-color)">
                        Chấp nhận
                    </button>
                    <button id="slam-cancel-btn" class="action-btn">Hủy bỏ</button>
                </div>
            </div>
        </div>

        <div class="modal-overlay" id="confirm-modal">
            <div class="modal-content">
                <h2 id="confirm-title">Xác nhận</h2>
                <p id="confirm-text">Bạn có chắc chắn muốn thực hiện hành động này?</p>
                <div class="modal-actions">
                    <button id="confirm-ok-btn" class="action-btn primary">Đồng ý</button>
                    <button id="confirm-cancel-btn" class="action-btn">Hủy bỏ</button>
                </div>
            </div>
        </div>
        <!-- Modal Cấu Hình GitHub -->
        <div class="modal-overlay" id="settings-modal">
            <div class="modal-content" style="text-align: left; max-width: 500px">
                <h2 style="text-align: center">Kết Nối GitHub</h2>
                <div
                    class="form-group-material"
                    style="display: flex; align-items: center; margin-bottom: 20px; margin-top: 10px"
                >
                    <input
                        type="checkbox"
                        id="setting-manual-reveal"
                        style="width: 20px; height: 20px; margin-right: 10px"
                    />
                    <label for="setting-manual-reveal" style="position: static; font-size: 1rem; color: white"
                        >Bật Logic Puzzle (Mở khóa thủ công)</label
                    >
                </div>
                <div class="form-group-material" style="display: flex; align-items: center; margin-bottom: 20px">
                    <input
                        type="checkbox"
                        id="setting-vietnamese-keyboard"
                        style="width: 20px; height: 20px; margin-right: 10px"
                    />
                    <label for="setting-vietnamese-keyboard" style="position: static; font-size: 1rem; color: white"
                        >Bàn phím Tiếng Việt (Beta)</label
                    >
                </div>
                <p style="font-size: 0.9rem; color: var(--light-text); text-align: center; margin-bottom: 20px">
                    Token được lưu trên trình duyệt của bạn. <br />
                    Dùng để tải đề lên file dữ liệu chung.
                </p>

                <div class="form-group-material">
                    <input type="text" id="gh-token" placeholder=" " type="password" />
                    <label>GitHub Personal Access Token</label>
                </div>
                <div class="form-group-material">
                    <input type="text" id="gh-owner" placeholder=" " />
                    <label>Username / Organization</label>
                </div>
                <div class="form-group-material">
                    <input type="text" id="gh-repo" placeholder=" " />
                    <label>Repository Name</label>
                </div>
                <div class="form-group-material">
                    <input type="text" id="gh-path" placeholder=" " value="slamde/data.json" />
                    <label>File Path (VD: slamde/data.json)</label>
                </div>

                <div class="modal-actions" style="margin-top: 20px">
                    <button id="save-settings-btn" class="action-btn primary">Lưu Cấu Hình</button>
                    <button id="close-settings-btn" class="action-btn">Đóng</button>
                </div>
            </div>
        </div>
        <script>
            document.addEventListener("DOMContentLoaded", () => {
                // --- HÀM TIỆN ÍCH TIẾNG VIỆT ---
                // --- HÀM MỚI: TRẢ VỀ KHÔNG DẤU CHO CÁC Ô ĐÃ GIẢI ---
                const revertTonesOnSolvedCells = (wordData) => {
                    if (!wordData) return;
                    for (let i = 0; i < wordData.word.length; i++) {
                        let r = wordData.row,
                            c = wordData.col;
                        if (wordData.direction === "horizontal") c += i;
                        else r += i;

                        const cell = gridContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);

                        // Chỉ xử lý các ô ĐÃ GIẢI (màu trắng, tự động hiện...)
                        if (cell && cell.classList.contains("is-solved")) {
                            const cellFront = cell.querySelector(".cell-front");
                            const currentText = cellFront.textContent.trim();
                            // Đưa về dạng không dấu
                            cellFront.textContent = removeVietnameseTones(currentText);
                        }
                    }
                };
                const removeVietnameseTones = (str) => {
                    str = str.replace(/à|á|ạ|ả|ã|â|ầ|ấ|ậ|ẩ|ẫ|ă|ằ|ắ|ặ|ẳ|ẵ/g, "a");
                    str = str.replace(/è|é|ẹ|ẻ|ẽ|ê|ề|ế|ệ|ể|ễ/g, "e");
                    str = str.replace(/ì|í|ị|ỉ|ĩ/g, "i");
                    str = str.replace(/ò|ó|ọ|ỏ|õ|ô|ồ|ố|ộ|ổ|ỗ|ơ|ờ|ớ|ợ|ở|ỡ/g, "o");
                    str = str.replace(/ù|ú|ụ|ủ|ũ|ư|ừ|ứ|ự|ử|ữ/g, "u");
                    str = str.replace(/ỳ|ý|ỵ|ỷ|ỹ/g, "y");
                    str = str.replace(/đ/g, "d");
                    str = str.replace(/À|Á|Ạ|Ả|Ã|Â|Ầ|Ấ|Ậ|Ẩ|Ẫ|Ă|Ằ|Ắ|Ặ|Ẳ|Ẵ/g, "A");
                    str = str.replace(/È|É|Ẹ|Ẻ|Ẽ|Ê|Ề|Ế|Ệ|Ể|Ễ/g, "E");
                    str = str.replace(/Ì|Í|Ị|Ỉ|Ĩ/g, "I");
                    str = str.replace(/Ò|Ó|Ọ|Ỏ|Õ|Ô|Ồ|Ố|Ộ|Ổ|Ỗ|Ơ|Ờ|Ớ|Ợ|Ở|Ỡ/g, "O");
                    str = str.replace(/Ù|Ú|Ụ|Ủ|Ũ|Ư|Ừ|Ứ|Ự|Ử|Ữ/g, "U");
                    str = str.replace(/Ỳ|Ý|Ỵ|Ỷ|Ỹ/g, "Y");
                    str = str.replace(/Đ/g, "D");
                    return str;
                };

                // --- HÀM XỬ LÝ DẤU THÔNG MINH (SỬA LỖI Ắ, Ớ, Ứ...) ---
                const addToneToChar = (char, tone) => {
                    // Bản đồ định nghĩa các họ nguyên âm và các biến thể dấu của chúng
                    // Thứ tự: [Không dấu, Sắc, Huyền, Hỏi, Ngã, Nặng]
                    const vowelMap = {
                        A: ["A", "Á", "À", "Ả", "Ã", "Ạ"],
                        Ă: ["Ă", "Ắ", "Ằ", "Ẳ", "Ẵ", "Ặ"],
                        Â: ["Â", "Ấ", "Ầ", "Ẩ", "Ẫ", "Ậ"],
                        E: ["E", "É", "È", "Ẻ", "Ẽ", "Ẹ"],
                        Ê: ["Ê", "Ế", "Ề", "Ể", "Ễ", "Ệ"],
                        I: ["I", "Í", "Ì", "Ỉ", "Ĩ", "Ị"],
                        O: ["O", "Ó", "Ò", "Ỏ", "Õ", "Ọ"],
                        Ô: ["Ô", "Ố", "Ồ", "Ổ", "Ỗ", "Ộ"],
                        Ơ: ["Ơ", "Ớ", "Ờ", "Ở", "Ỡ", "Ợ"],
                        U: ["U", "Ú", "Ù", "Ủ", "Ũ", "Ụ"],
                        Ư: ["Ư", "Ứ", "Ừ", "Ử", "Ữ", "Ự"],
                        Y: ["Y", "Ý", "Ỳ", "Ỷ", "Ỹ", "Ỵ"],
                    };

                    // Mapping từ tên key sang index trong mảng vowelMap
                    const toneIndexMap = {
                        ACUTE: 1, // Sắc
                        GRAVE: 2, // Huyền
                        HOOK: 3, // Hỏi
                        TILDE: 4, // Ngã
                        DOT: 5, // Nặng
                    };

                    const targetIndex = toneIndexMap[tone];
                    if (targetIndex === undefined) return char; // Nếu tone không hợp lệ

                    // Duyệt qua từng họ nguyên âm
                    for (const base in vowelMap) {
                        const variants = vowelMap[base];
                        // Nếu ký tự hiện tại (char) nằm trong họ này (Ví dụ: char là 'Ă' nằm trong họ 'Ă')
                        if (variants.includes(char)) {
                            // Trả về ký tự có dấu tương ứng trong cùng họ đó (Ví dụ: index 1 của họ 'Ă' là 'Ắ')
                            return variants[targetIndex];
                        }
                    }

                    // Nếu không phải nguyên âm (B, C, D...) thì trả về như cũ
                    return char;
                };
                let wakeLock = null;
                const requestWakeLock = async () => {
                    if ("wakeLock" in navigator) {
                        try {
                            wakeLock = await navigator.wakeLock.request("screen");
                            // console.log("Screen Wake Lock active");
                        } catch (err) {
                            console.error(`Wake Lock error: ${err.name}, ${err.message}`);
                        }
                    }
                };
                // Yêu cầu giữ sáng ngay khi vào trang và khi quay lại tab
                requestWakeLock();
                document.addEventListener("visibilitychange", () => {
                    if (document.visibilityState === "visible") {
                        requestWakeLock();
                    }
                });
                // 1. Đẩy state ảo
                history.pushState(null, null, location.href);

                // 2. Bắt sự kiện Back
                window.addEventListener("popstate", (event) => {
                    // Đẩy lại state ngay lập tức để giữ chân
                    history.pushState(null, null, location.href);

                    const modal = document.getElementById("confirm-modal");
                    const title = document.getElementById("confirm-title");
                    const text = document.getElementById("confirm-text");
                    const okBtn = document.getElementById("confirm-ok-btn");
                    const cancelBtn = document.getElementById("confirm-cancel-btn");

                    if (modal) {
                        // Xác định ngữ cảnh để hiện thông báo phù hợp
                        let dialogTitle = "Thoát Game?";
                        let dialogText = "Bạn có muốn rời khỏi trang web này không?";
                        let confirmAction = () => history.go(-2); // Mặc định là thoát trang web

                        if (state.currentPage === "game") {
                            dialogTitle = "Thoát Màn Chơi?";
                            dialogText = "Tiến trình sẽ được lưu. Bạn muốn quay về sảnh chờ?";
                            confirmAction = () => switchView("lobby"); // Trong game thì về sảnh
                        } else if (state.currentPage === "creation") {
                            dialogTitle = "Hủy Soạn Thảo?";
                            dialogText = "Dữ liệu bộ đề chưa lưu sẽ bị mất. Bạn chắc chắn muốn về sảnh?";
                            confirmAction = () => switchView("lobby"); // Đang soạn thì về sảnh
                        }

                        // Cập nhật nội dung Modal
                        title.textContent = dialogTitle;
                        text.textContent = dialogText;
                        modal.classList.add("visible");

                        // Clone nút để reset sự kiện cũ
                        const newOkBtn = okBtn.cloneNode(true);
                        const newCancelBtn = cancelBtn.cloneNode(true);
                        okBtn.parentNode.replaceChild(newOkBtn, okBtn);
                        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

                        // Xử lý Đồng ý
                        newOkBtn.addEventListener("click", () => {
                            modal.classList.remove("visible");
                            confirmAction();
                        });

                        // Xử lý Hủy
                        newCancelBtn.addEventListener("click", () => {
                            modal.classList.remove("visible");
                        });
                    }
                });
                let state = {
                    currentPage: "lobby",
                    words: [],
                    currentPuzzleId: null,
                    selectedWordId: null,
                    solvedWords: new Set(),
                    timerInterval: null,
                    saveInterval: null,
                    wordTimerInterval: null,
                    wordTimeLeft: 30,
                    startTime: 0,
                    elapsedSeconds: 0,
                    totalScore: 0,
                    turnCount: 1,
                    currentInputCell: null,
                    slamModeActive: false,
                    gamePhase: "reveal",
                    revealedLetters: new Set(),
                    playableWordIds: new Set(),
                    disabledLetters: new Set(),
                    isGameFinished: false,
                    serverPuzzles: {},
                    editingServerId: null,

                    failedRevealLetters: new Set(), // Danh sách chữ cái trả lời sai logic
                    challengeModeActive: false, // Trạng thái đang trả lời câu hỏi logic
                    currentChallengeTarget: null, // Chữ cái đáp án của câu hỏi hiện tại
                    manualRevealEnabled: false, // Cài đặt bật/tắt tính năng
                    vietnameseKeyboardEnabled: false,
                    isProcessingChallenge: false,
                    editingSpecificCell: null,
                    isCheckingAnswer: false,
                };
                let editorState = {
                    isDragging: false,
                    draggedWordId: null,
                    ghostElement: null,
                    placementPreview: null,
                    gridOffset: { x: 0, y: 0 },
                    startOffset: { x: 0, y: 0 },
                };
                const tabBtnWords = document.getElementById("tab-btn-words");
                const tabBtnArrange = document.getElementById("tab-btn-arrange");
                const tabContentWords = document.getElementById("tab-content-words");
                const tabContentArrange = document.getElementById("tab-content-arrange");
                const wordBank = document.getElementById("word-bank");
                const editorGrid = document.getElementById("editor-grid");
                const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
                const exportBtn = document.getElementById("export-puzzle-btn");
                const importBtn = document.getElementById("import-puzzle-btn");
                const pages = {
                    lobby: document.getElementById("lobby-page"),
                    creation: document.getElementById("creation-page"),
                    game: document.getElementById("game-page"),
                };
                const settingVietnameseKeyboard = document.getElementById("setting-vietnamese-keyboard");
                const puzzleListContainer = document.getElementById("puzzle-list");
                const puzzleTitleInput = document.getElementById("puzzle-title-input");
                const gameArea = document.querySelector(".game-area");
                const wordListContainer = document.getElementById("word-list-container");
                const addWordFab = document.getElementById("add-word-fab");
                const savePuzzleBtn = document.getElementById("save-puzzle-btn");
                const deletePuzzleBtn = document.getElementById("delete-puzzle-btn");
                const backToLobbyBtn = document.getElementById("back-to-lobby-btn");
                const backToLobbyBtnGame = document.getElementById("back-to-lobby-btn-game");
                const editPuzzleBtn = document.getElementById("edit-puzzle-btn");
                const gridContainer = document.getElementById("grid-container");
                const numberOverlay = document.getElementById("number-overlay");
                const clueText = document.getElementById("clue-text");
                const timerDisplay = document.getElementById("timer");
                const wordsSolvedStat = document.getElementById("words-solved-stat");
                const scoreDisplay = document.getElementById("score-display");
                const wordTimerDisplay = document.getElementById("word-timer");
                const keyboardWrapper = document.getElementById("keyboard-wrapper");
                const virtualKeyboard = document.getElementById("virtual-keyboard");
                const slamBtn = document.getElementById("slam-btn");
                const slamModal = document.getElementById("slam-modal");
                const slamConfirmBtn = document.getElementById("slam-confirm-btn");
                const slamCancelBtn = document.getElementById("slam-cancel-btn");
                const confirmModal = document.getElementById("confirm-modal");
                const revealChallengeContainer = document.getElementById("reveal-challenge-container");
                const challengeQuestionText = document.getElementById("challenge-question");
                const challengeInput = document.getElementById("challenge-input");
                const challengeFeedback = document.getElementById("challenge-feedback");
                const settingManualReveal = document.getElementById("setting-manual-reveal");
                const getPuzzles = () => {
                    try {
                        const p = localStorage.getItem("slam-puzzles-list");
                        return p ? JSON.parse(p) : {};
                    } catch (e) {
                        return {};
                    }
                };
                const savePuzzles = (p) => {
                    localStorage.setItem("slam-puzzles-list", JSON.stringify(p));
                };
                // Hàm mã hóa/giải mã Base64 hỗ trợ tiếng Việt (UTF-8)
                const utf8_to_b64 = (str) => window.btoa(unescape(encodeURIComponent(str)));
                const b64_to_utf8 = (str) => decodeURIComponent(escape(window.atob(str)));
                // =======================================================================
                // ★★★ LOGIC MỚI CHO TÍNH NĂNG XUẤT/NHẬP BỘ ĐỀ ★★★
                // =======================================================================
                const settingsModal = document.getElementById("settings-modal");
                const openSettingsBtn = document.getElementById("open-settings-btn");
                const saveSettingsBtn = document.getElementById("save-settings-btn");
                const closeSettingsBtn = document.getElementById("close-settings-btn");
                const uploadGithubBtn = document.getElementById("upload-github-btn");

                // Input fields
                const ghTokenInput = document.getElementById("gh-token");
                const ghOwnerInput = document.getElementById("gh-owner");
                const ghRepoInput = document.getElementById("gh-repo");
                const ghPathInput = document.getElementById("gh-path");
                // Load settings khi mở modal
                openSettingsBtn.addEventListener("click", () => {
                    const config = JSON.parse(localStorage.getItem("slam-github-config") || "{}");
                    ghTokenInput.value = config.token || "";
                    ghOwnerInput.value = config.owner || "";
                    ghRepoInput.value = config.repo || "";
                    ghPathInput.value = config.path || "slamde/data.json";

                    // --- LOAD SETTING LOGIC PUZZLE ---
                    const manualReveal = localStorage.getItem("slam-setting-manual-reveal") === "true";
                    settingManualReveal.checked = manualReveal;
                    state.manualRevealEnabled = manualReveal;

                    const vnKeyboard = localStorage.getItem("slam-setting-vietnamese-keyboard") === "true";
                    settingVietnameseKeyboard.checked = vnKeyboard;
                    state.vietnameseKeyboardEnabled = vnKeyboard;

                    settingsModal.classList.add("visible");
                });

                closeSettingsBtn.addEventListener("click", () => settingsModal.classList.remove("visible"));

                saveSettingsBtn.addEventListener("click", () => {
                    const config = {
                        token: ghTokenInput.value.trim(),
                        owner: ghOwnerInput.value.trim(),
                        repo: ghRepoInput.value.trim(),
                        path: ghPathInput.value.trim(),
                    };
                    localStorage.setItem("slam-github-config", JSON.stringify(config));
                    // --- LƯU SETTING LOGIC PUZZLE ---
                    const isManual = settingManualReveal.checked;
                    localStorage.setItem("slam-setting-manual-reveal", isManual);
                    state.manualRevealEnabled = isManual;

                    const isVnKeyboard = settingVietnameseKeyboard.checked;
                    localStorage.setItem("slam-setting-vietnamese-keyboard", isVnKeyboard);
                    state.vietnameseKeyboardEnabled = isVnKeyboard;

                    // Nếu đang trong game, cần render lại bàn phím ngay lập tức
                    if (state.currentPage === "game") {
                        createVirtualKeyboard();
                        updateKeyboardState();
                    }

                    showToast("Đã lưu cấu hình!", "success");
                    settingsModal.classList.remove("visible");
                });
                // --- TÌM VÀ THAY THẾ sự kiện uploadGithubBtn.addEventListener ---
                uploadGithubBtn.addEventListener("click", async () => {
                    updateStateFromForms();
                    const title = puzzleTitleInput.value.trim();
                    if (!title || state.words.length < 2) {
                        showToast("Vui lòng hoàn thiện đề trước khi tải lên.", "error");
                        return;
                    }

                    const config = JSON.parse(localStorage.getItem("slam-github-config"));
                    if (!config || !config.token || !config.owner || !config.repo) {
                        showToast("Vui lòng nhập cấu hình GitHub trước!", "error");
                        settingsModal.classList.add("visible");
                        return;
                    }

                    // Xác định chế độ: Cập nhật hay Tạo mới
                    const isUpdate = !!state.editingServerId;
                    const actionName = isUpdate ? "CẬP NHẬT" : "TẢI LÊN MỚI";

                    const uploadConfirmed = await showConfirmation(
                        `${actionName} Server?`,
                        `Bạn muốn ${actionName.toLowerCase()} bộ đề "${title}" vào file "${config.path}"?`
                    );
                    if (!uploadConfirmed) return;

                    showToast("Đang kết nối GitHub...", "info");

                    // 1. Chuẩn bị dữ liệu đề
                    let minRow = Infinity,
                        minCol = Infinity;
                    const validWords = state.words.filter((w) => w.word && w.clue);
                    validWords.forEach((w) => {
                        if (w.row !== null) minRow = Math.min(minRow, w.row);
                        if (w.col !== null) minCol = Math.min(minCol, w.col);
                    });

                    // Nếu đang sửa -> Giữ nguyên ID cũ. Nếu mới -> Tạo ID mới.
                    const puzzleId = isUpdate
                        ? state.editingServerId
                        : `server_${Date.now()}_${Math.floor(Math.random() * 1000)}`;

                    const puzzleDataObj = {
                        id: puzzleId,
                        title: title,
                        highScore: 0, // Reset điểm khi sửa đề (hoặc giữ nguyên nếu muốn, nhưng sửa layout thì nên reset)
                        arrangedWords: validWords.map((w) => ({
                            id: w.id,
                            word: w.word,
                            clue: w.clue,
                            direction: w.direction,
                            row: w.row !== null ? w.row - minRow : 0,
                            col: w.col !== null ? w.col - minCol : 0,
                        })),
                    };

                    const apiUrl = `https://api.github.com/repos/${config.owner}/${config.repo}/contents/${config.path}`;

                    try {
                        // 2. Lấy file hiện tại
                        let currentData = [];
                        let sha = null;

                        const getResponse = await fetch(apiUrl, {
                            headers: {
                                Authorization: `Bearer ${config.token}`,
                                Accept: "application/vnd.github.v3+json",
                            },
                        });

                        if (getResponse.ok) {
                            const fileData = await getResponse.json();
                            sha = fileData.sha;
                            const content = b64_to_utf8(fileData.content.replace(/\n/g, ""));
                            currentData = JSON.parse(content);
                        } else if (getResponse.status !== 404) {
                            throw new Error("Lỗi khi đọc file từ Server.");
                        }

                        // 3. Xử lý Mảng dữ liệu (Update hoặc Push)
                        if (isUpdate) {
                            // Tìm và thay thế
                            const index = currentData.findIndex((p) => p.id === puzzleId);
                            if (index !== -1) {
                                // Giữ lại highScore cũ nếu muốn
                                // puzzleDataObj.highScore = currentData[index].highScore;
                                currentData[index] = puzzleDataObj;
                            } else {
                                // ID không tồn tại (có thể bị xóa bởi người khác), thêm mới
                                currentData.push(puzzleDataObj);
                            }
                        } else {
                            // Thêm mới
                            currentData.push(puzzleDataObj);
                        }

                        // 4. Đẩy file mới lên (PUT)
                        const newContentBase64 = utf8_to_b64(JSON.stringify(currentData, null, 2));

                        const putBody = {
                            message: `${isUpdate ? "Update" : "Add"} puzzle: ${title}`,
                            content: newContentBase64,
                            sha: sha, // Bắt buộc có SHA để update file cũ
                        };

                        const putResponse = await fetch(apiUrl, {
                            method: "PUT",
                            headers: {
                                Authorization: `Bearer ${config.token}`,
                                "Content-Type": "application/json",
                            },
                            body: JSON.stringify(putBody),
                        });

                        if (putResponse.ok) {
                            showToast("Thao tác thành công!", "success");
                            // Reset trạng thái
                            state.editingServerId = null;
                            switchView("lobby");
                        } else {
                            const err = await putResponse.json();
                            throw new Error(err.message);
                        }
                    } catch (e) {
                        showToast(`Lỗi: ${e.message}`, "error", 5000);
                        console.error(e);
                    }
                });
                const exportPuzzle = () => {
                    updateStateFromForms();
                    const title = puzzleTitleInput.value.trim();
                    if (!title) {
                        showToast("Vui lòng nhập tên bộ đề trước khi xuất.", "error");
                        return;
                    }
                    const validWords = state.words.filter((w) => w.word && w.clue);
                    if (validWords.length < 2) {
                        showToast("Cần ít nhất 2 từ hợp lệ để xuất file.", "error");
                        return;
                    }
                    // --- LOGIC GITHUB UPLOAD ---

                    // Tính toán để chuẩn hóa tọa độ (đưa về 0,0) giống như lúc Lưu
                    let minRow = Infinity,
                        minCol = Infinity;
                    let hasLayout = false;

                    validWords.forEach((word) => {
                        if (word.row !== null && word.col !== null) {
                            minRow = Math.min(minRow, word.row);
                            minCol = Math.min(minCol, word.col);
                            hasLayout = true;
                        }
                    });

                    const exportWords = validWords.map((w) => ({
                        word: w.word,
                        clue: w.clue,
                        // Nếu đã xếp lưới thì lưu tọa độ đã chuẩn hóa, nếu chưa thì để null
                        row: hasLayout && w.row !== null ? w.row - minRow : null,
                        col: hasLayout && w.col !== null ? w.col - minCol : null,
                        direction: w.direction || "horizontal",
                    }));

                    const puzzleData = {
                        title: title,
                        words: exportWords,
                    };

                    const dataStr =
                        "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(puzzleData, null, 2));
                    const downloadAnchorNode = document.createElement("a");
                    downloadAnchorNode.setAttribute("href", dataStr);
                    const safeFileName = title.replace(/[^a-z0-9]/gi, "_").toLowerCase();
                    downloadAnchorNode.setAttribute("download", `slam_puzzle_${safeFileName}.json`);
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                    showToast("Đã xuất bộ đề (kèm bố cục)!", "success");
                };
                // --- HÀM 2: NHẬP DỮ LIỆU TỪ FILE .JSON ---
                const importPuzzle = () => {
                    // Tạo một input ảo để người dùng chọn file
                    const fileInput = document.createElement("input");
                    fileInput.type = "file";
                    fileInput.accept = ".json"; // Chỉ chấp nhận file .json

                    fileInput.onchange = (e) => {
                        const file = e.target.files[0];
                        if (!file) return;

                        const reader = new FileReader();
                        // --- TÌM VÀ SỬA ĐOẠN LOGIC TRONG importPuzzle (phần reader.onload) ---
                        reader.onload = async (event) => {
                            try {
                                const puzzleData = JSON.parse(event.target.result);
                                if (!puzzleData.title || !Array.isArray(puzzleData.words)) {
                                    throw new Error("Cấu trúc file không hợp lệ.");
                                }

                                const confirmed = await showConfirmation(
                                    "Nhập Bộ Đề?",
                                    `Bạn có muốn thay thế bằng "${puzzleData.title}"?`
                                );

                                if (confirmed) {
                                    puzzleTitleInput.value = puzzleData.title;

                                    // LOGIC MỚI: Đọc cả row, col, direction nếu có
                                    state.words = puzzleData.words.map((w, index) => ({
                                        id: index,
                                        word: w.word || "",
                                        clue: w.clue || "",
                                        direction: w.direction || "horizontal",
                                        // Nếu file json có row/col thì lấy, không thì null
                                        row: w.row !== undefined && w.row !== null ? w.row : null,
                                        col: w.col !== undefined && w.col !== null ? w.col : null,
                                    }));

                                    state.currentPuzzleId = null;
                                    deletePuzzleBtn.style.display = "none";
                                    renderWordForms();

                                    // Nếu file import đã có sẵn layout, chuyển luôn sang tab Xếp Lưới để user thấy
                                    const hasLayout = state.words.some((w) => w.row !== null);
                                    if (hasLayout) {
                                        showToast("Đã nhập bộ đề và sơ đồ lưới!", "success");
                                        switchCreationTab("arrange");
                                    } else {
                                        showToast("Đã nhập danh sách từ!", "success");
                                    }
                                }
                            } catch (error) {
                                showToast(`Lỗi khi đọc file: ${error.message}`, "error");
                            }
                        };

                        reader.readAsText(file);
                    };

                    fileInput.click(); // Mở hộp thoại chọn file
                };

                if (exportBtn) exportBtn.addEventListener("click", exportPuzzle);
                if (importBtn) importBtn.addEventListener("click", importPuzzle);
                // =======================================================================
                // ★★★ KẾT THÚC LOGIC MỚI CHO TÍNH NĂNG XUẤT/NHẬP BỘ ĐỀ ★★★
                const showConfirmation = (title, text) => {
                    return new Promise((resolve) => {
                        document.getElementById("confirm-title").textContent = title;
                        document.getElementById("confirm-text").textContent = text;
                        confirmModal.classList.add("visible");
                        const okBtn = document.getElementById("confirm-ok-btn");
                        const cancelBtn = document.getElementById("confirm-cancel-btn");
                        const cleanup = (result) => {
                            confirmModal.classList.remove("visible");
                            okBtn.replaceWith(okBtn.cloneNode(true));
                            cancelBtn.replaceWith(cancelBtn.cloneNode(true));
                            resolve(result);
                        };
                        okBtn.addEventListener("click", () => cleanup(true), { once: true });
                        cancelBtn.addEventListener("click", () => cleanup(false), { once: true });
                    });
                };

                const switchView = (pageName, data = null) => {
                    stopGame();
                    state.currentPage = pageName;
                    Object.values(pages).forEach((p) => p.classList.remove("active"));
                    pages[pageName].classList.add("active");
                    if (pageName === "lobby") renderLobby();
                    if (pageName === "creation") initCreation(data);
                    if (pageName === "game") initGame(data);
                };

                const showToast = (message, type = "info", duration = 3000) => {
                    const toast = document.createElement("div");
                    toast.className = `toast ${type}`;
                    toast.textContent = message;
                    document.getElementById("toast-container").appendChild(toast);
                    setTimeout(() => {
                        toast.classList.add("exit");
                        toast.addEventListener("animationend", () => toast.remove());
                    }, duration);
                };
                // --- TÌM VÀ THAY THẾ TOÀN BỘ HÀM renderLobby ---
                const renderLobby = async () => {
                    puzzleListContainer.innerHTML = ""; // Xóa danh sách cũ

                    // 1. Render nút tạo mới trước
                    const addNewCard = document.createElement("div");
                    addNewCard.className = "new-puzzle-card";
                    addNewCard.innerHTML = `<div class="plus-icon">+</div><div class="new-puzzle-text">Tạo Bộ Đề Mới</div>`;
                    // Trong renderLobby:
                    addNewCard.addEventListener("click", () => {
                        state.editingServerId = null; // Reset về mode tạo mới
                        document.getElementById("upload-github-btn").innerHTML = `Upload`; // Reset text nút
                        document.getElementById("upload-github-btn").style.background =
                            "linear-gradient(145deg, #7b1fa2, #4a148c)";
                        switchView("creation");
                    });
                    puzzleListContainer.appendChild(addNewCard);

                    // 2. Lấy và Render dữ liệu Local (Trong máy)
                    const localPuzzles = getPuzzles();
                    const localIds = Object.keys(localPuzzles).sort(
                        (a, b) => (localPuzzles[b].lastModified || 0) - (localPuzzles[a].lastModified || 0)
                    );

                    localIds.forEach((id) => {
                        createPuzzleCard(id, localPuzzles[id], "local");
                    });

                    // 3. Fetch và Render dữ liệu Server
                    try {
                        // Giả định file nằm ở thư mục cùng cấp: slamde/data.json
                        // Thêm timestamp để tránh cache trình duyệt khi update file mới
                        const response = await fetch(`./slamde/data.json?t=${Date.now()}`);
                        if (response.ok) {
                            const serverData = await response.json();
                            // serverData nên là mảng các object puzzle
                            // Format file json server: [{ "id": "sv1", "title": "...", "arrangedWords": [...] }, ...]

                            state.serverPuzzles = {}; // Reset cache server

                            serverData.forEach((puzzle) => {
                                // Lưu vào state để dùng khi bấm play
                                // Đảm bảo ID không trùng với local, nếu trùng có thể prefix
                                const serverId = puzzle.id || `server_${Math.random()}`;
                                state.serverPuzzles[serverId] = puzzle;

                                createPuzzleCard(serverId, puzzle, "server");
                            });
                        }
                    } catch (e) {
                        console.log("Không tải được dữ liệu server hoặc chưa có file data.json", e);
                    }
                };

                // --- TÌM VÀ THAY THẾ HÀM createPuzzleCard ---
                const createPuzzleCard = (id, puzzle, source) => {
                    const card = document.createElement("div");
                    card.className = "puzzle-card";

                    let badge =
                        source === "server"
                            ? `<span style="background:#4caf50; font-size:0.7rem; padding:2px 6px; border-radius:4px; color:white; margin-left: 10px;">ONLINE</span>`
                            : "";

                    // Kiểm tra xem có save game không
                    const saveState = localStorage.getItem(`slam-gamestate-${id}`);

                    // Tạo HTML cho các nút chơi
                    let playButtonsHtml = "";
                    if (saveState) {
                        // Nếu có save: Hiển thị nút Continue (Xanh lá) và New Game (Xanh dương/Icon reload)
                        playButtonsHtml = `
            <button class="action-btn continue-puzzle-btn" data-id="${id}" data-source="${source}" title="Chơi tiếp" style="background: linear-gradient(145deg, #66bb6a, #43a047); border-color: #81c784;">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
            </button>
            <button class="action-btn new-game-btn" data-id="${id}" data-source="${source}" title="Chơi mới (Xóa save cũ)" style="background: linear-gradient(145deg, #42a5f5, #1e88e5); border-color: #64b5f6;">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.5 2v6h6M21.5 22v-6h-6"/><path d="M22 11.5A10 10 0 0 0 3.2 7.2M2 12.5a10 10 0 0 0 18.8 4.3"/></svg>
            </button>
        `;
                    } else {
                        // Nếu không có save: Chỉ hiển thị nút Chơi mới (Play)
                        playButtonsHtml = `
            <button class="action-btn new-game-btn primary" data-id="${id}" data-source="${source}" title="Bắt đầu chơi">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
            </button>
        `;
                    }

                    let actionBtnHtml = "";
                    if (source === "local") {
                        actionBtnHtml = `
            <button class="action-btn edit-puzzle-btn" data-id="${id}" data-source="local" title="Sửa Local">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
            </button>`;
                    } else {
                        const ghConfig = JSON.parse(localStorage.getItem("slam-github-config") || "{}");
                        const canEdit = ghConfig.token && ghConfig.owner && ghConfig.repo;
                        let editButton = "";
                        if (canEdit) {
                            editButton = `
            <button class="action-btn edit-puzzle-btn" data-id="${id}" data-source="server" title="Sửa trên Server" style="background: linear-gradient(145deg, #f57c00, #e65100); border-color: #ff9800;">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg>
            </button>`;
                        }
                        actionBtnHtml = `
            ${editButton}
            <button class="action-btn copy-puzzle-btn" data-id="${id}" title="Sao chép về máy" style="background: #546e7a; border-color: #78909c;">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
            </button>`;
                    }

                    card.innerHTML = `
        <h3 class="puzzle-card-title">${puzzle.title} ${badge}</h3>
        <p class="puzzle-card-meta">${puzzle.words ? puzzle.words.length : puzzle.arrangedWords ? puzzle.arrangedWords.length : 0} từ</p>
        <p class="puzzle-card-meta" style="color: var(--primary-accent); font-weight: 700;">Điểm cao: ${puzzle.highScore || 0}</p>
        <div class="puzzle-card-actions">
            ${playButtonsHtml}
            ${actionBtnHtml}
        </div>`;
                    puzzleListContainer.appendChild(card);
                };

                // --- TÌM VÀ THAY THẾ TOÀN BỘ puzzleListContainer.addEventListener ---
                puzzleListContainer.addEventListener("click", async (e) => {
                    const continueBtn = e.target.closest(".continue-puzzle-btn");
                    const newGameBtn = e.target.closest(".new-game-btn");
                    const editBtn = e.target.closest(".edit-puzzle-btn");
                    const copyBtn = e.target.closest(".copy-puzzle-btn");

                    // Logic Chơi Tiếp
                    if (continueBtn) {
                        const source = continueBtn.dataset.source;
                        // Chuyển view, initGame sẽ tự động load save nếu có
                        switchView("game", { id: continueBtn.dataset.id, source: source });
                    }

                    // Logic Chơi Mới
                    if (newGameBtn) {
                        const id = newGameBtn.dataset.id;
                        const source = newGameBtn.dataset.source;

                        // Kiểm tra nếu có save cũ thì hỏi xác nhận (nếu cần), hoặc xóa luôn
                        if (localStorage.getItem(`slam-gamestate-${id}`)) {
                            const confirmNew = await showConfirmation(
                                "Chơi mới?",
                                "Tiến trình cũ sẽ bị xóa. Bạn có chắc chắn?"
                            );
                            if (!confirmNew) return;
                            // Xóa save cũ
                            localStorage.removeItem(`slam-gamestate-${id}`);
                        }

                        // Chuyển view
                        switchView("game", { id: id, source: source });
                    }

                    // ... (Giữ nguyên phần logic Edit và Copy cũ) ...
                    if (editBtn) {
                        const source = editBtn.dataset.source;
                        if (source === "server") {
                            const serverId = editBtn.dataset.id;
                            const puzzleData = state.serverPuzzles[serverId];
                            if (puzzleData) {
                                state.editingServerId = serverId;
                                state.currentPuzzleId = null;
                                switchView("creation");
                                setTimeout(() => {
                                    puzzleTitleInput.value = puzzleData.title;
                                    state.words = (puzzleData.arrangedWords || puzzleData.words).map((w, i) => ({
                                        ...w,
                                        id: i,
                                    }));
                                    renderWordForms();
                                    const upBtn = document.getElementById("upload-github-btn");
                                    if (upBtn) {
                                        upBtn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg>
            Cập Nhật
        `;
                                        upBtn.style.background = "linear-gradient(145deg, #f57c00, #e65100)";
                                        upBtn.style.borderColor = "#ff9800";
                                    }
                                    showToast(`Đang sửa đề Online: ${puzzleData.title}`, "info");
                                }, 50);
                            }
                        } else {
                            state.editingServerId = null;
                            switchView("creation", editBtn.dataset.id);
                        }
                    }

                    if (copyBtn) {
                        const serverId = copyBtn.dataset.id;
                        const puzzleData = state.serverPuzzles[serverId];
                        if (puzzleData) {
                            state.editingServerId = null;
                            state.currentPuzzleId = null;
                            switchView("creation");
                            setTimeout(() => {
                                puzzleTitleInput.value = puzzleData.title + " (Copy)";
                                state.words = (puzzleData.arrangedWords || puzzleData.words).map((w, i) => ({
                                    ...w,
                                    id: i,
                                }));
                                renderWordForms();
                                showToast("Đã sao chép đề. Hãy lưu lại!", "success");
                            }, 50);
                        }
                    }
                });

                // --- TÌM VÀ THAY THẾ HÀM initCreation ---
                const initCreation = (puzzleId = null) => {
                    // Nếu có puzzleId (tức là sửa Local) HOẶC puzzleId là null (Tạo mới)
                    // Thì ta cần reset giao diện nút Upload về mặc định
                    // TRỪ KHI: state.editingServerId đang có giá trị (do logic ở Lobby vừa set xong)

                    if (state.editingServerId) {
                        // Đang sửa Server -> Không làm gì cả, để logic ở Lobby tự xử lý dữ liệu
                        state.currentPuzzleId = null;
                        switchCreationTab("words");
                        deletePuzzleBtn.style.display = "none";
                        return;
                    }

                    // Các trường hợp còn lại: Tạo mới hoặc Sửa Local
                    state.currentPuzzleId = puzzleId;
                    switchCreationTab("words"); // Luôn bắt đầu ở tab nhập từ
                    let wordsToRender = [];
                    puzzleTitleInput.value = "";

                    // Reset nút Upload về trạng thái mặc định (Màu tím)
                    const upBtn = document.getElementById("upload-github-btn");
                    if (upBtn) {
                        upBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg> Upload`;
                        upBtn.style.background = "linear-gradient(145deg, #7b1fa2, #4a148c)";
                        upBtn.style.borderColor = "#ba68c8";
                    }

                    if (puzzleId) {
                        // Sửa Local
                        const puzzle = getPuzzles()[puzzleId];
                        if (puzzle) {
                            puzzleTitleInput.value = puzzle.title;
                            if (puzzle.arrangedWords) {
                                wordsToRender = puzzle.arrangedWords.map((w, i) => ({ ...w, id: i }));
                            } else {
                                wordsToRender = puzzle.words.map((w, i) => ({
                                    ...w,
                                    id: i,
                                    direction: "horizontal",
                                    row: null,
                                    col: null,
                                }));
                            }
                            deletePuzzleBtn.style.display = "flex";
                        } else {
                            showToast("Không tìm thấy bộ đề!", "error");
                            state.currentPuzzleId = null;
                        }
                    } else {
                        // Tạo Mới Hoàn Toàn
                        deletePuzzleBtn.style.display = "none";
                        wordsToRender = [
                            {
                                id: 0,
                                word: "VIETNAM",
                                clue: "Đất nước hình chữ S",
                                direction: "horizontal",
                                row: null,
                                col: null,
                            },
                            { id: 1, word: "HANOI", clue: "Thủ đô", direction: "horizontal", row: null, col: null },
                        ];
                    }
                    state.words = wordsToRender;
                    renderWordForms();
                };
                // THAY THẾ HÀM CŨ BẰNG HÀM NÀY
                const renderWordForms = () => {
                    wordListContainer.innerHTML = state.words
                        .map(
                            (word, index) =>
                                `<div class="word-card" data-id="${word.id}">
            <div class="card-header">
                <h2 class="card-title">Từ #${index + 1}</h2>
<button class="remove-word-btn" title="Xóa từ này">
    <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><polyline points=\"3 6 5 6 21 6\"></polyline><path d=\"M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2\"></path></svg>
</button>
            </div>
            <div class="form-group-material">
                <input type="text" class="word-input" value="${word.word || ""}" placeholder=" " style="text-transform: uppercase;">
                <label>Từ (Word)</label>
            </div>
            <div class="form-group-material">
                <input type="text" class="clue-input" value="${word.clue || ""}" placeholder=" ">
                <label>Gợi ý (Clue)</label>
            </div>
        </div>`
                        )
                        .join("");
                };
                // THAY THẾ HÀM CŨ BẰNG HÀM NÀY
                const updateStateFromForms = () => {
                    const wordCards = document.querySelectorAll(".word-card");
                    let updatedWords = [];
                    wordCards.forEach((card) => {
                        const id = parseInt(card.dataset.id);
                        const existingWord = state.words.find((w) => w.id === id) || {};
                        updatedWords.push({
                            ...existingWord,
                            id: id,
                            word: card.querySelector(".word-input").value.toUpperCase().trim(),
                            clue: card.querySelector(".clue-input").value.trim(),
                        });
                    });
                    state.words = updatedWords;
                };

                // DÁN TOÀN BỘ KHỐI CODE NÀY VÀO SCRIPT

                // =======================================================================
                // ★★★ LOGIC CỐT LÕI MỚI CHO TRÌNH CHỈNH SỬA KÉO-THẢ ★★★
                // =======================================================================

                // THAY THẾ HÀM CŨ BẰNG HÀM NÀY
                const initEditor = () => {
                    updateStateFromForms();

                    // BƯỚC 1: Tính toán kích thước cần thiết
                    const gridSize = calculateEditorGridSize();

                    // BƯỚC 2: Tạo lưới với kích thước vừa tính
                    createEditorGrid(gridSize);

                    // BƯỚC 3: Render các thành phần khác như cũ
                    renderWordBank();
                    renderPlacedWords();
                };

                // THAY THẾ HÀM CŨ BẰNG HÀM NÀY
                const createEditorGrid = (gridSize) => {
                    editorGrid.innerHTML = ""; // Xóa lưới cũ trước khi tạo lưới mới

                    // Dùng gridSize động thay vì số 50 cố định
                    editorGrid.style.gridTemplateColumns = `repeat(${gridSize}, 25px)`;
                    editorGrid.style.gridTemplateRows = `repeat(${gridSize}, 25px)`;

                    const fragment = document.createDocumentFragment();
                    for (let i = 0; i < gridSize * gridSize; i++) {
                        const cell = document.createElement("div");
                        cell.className = "editor-cell";
                        cell.dataset.row = Math.floor(i / gridSize);
                        cell.dataset.col = i % gridSize;
                        fragment.appendChild(cell);
                    }
                    editorGrid.appendChild(fragment);
                };

                const calculateEditorGridSize = () => {
                    if (state.words.length === 0) return 20; // Kích thước mặc định nếu chưa có từ nào

                    // Tìm từ dài nhất trong danh sách
                    const longestWordLength = Math.max(...state.words.map((w) => w.word.length));

                    // Kích thước lưới sẽ bằng độ dài từ dài nhất + 1 khoảng đệm (ví dụ 5 ô)
                    // để có không gian sắp xếp. Tối thiểu là 20.
                    return Math.max(20, longestWordLength + 5);
                };
                const renderWordBank = () => {
                    wordBank.innerHTML = "";
                    const unplacedWords = state.words.filter(
                        (w) => w.word && (!w.hasOwnProperty("row") || w.row === null)
                    );

                    unplacedWords.forEach((word) => {
                        const wordEl = document.createElement("div");
                        wordEl.className = "bank-word";
                        wordEl.dataset.id = word.id;
                        wordEl.innerHTML = `
    <span class="word-direction-indicator">${word.direction === "vertical" ? "↓" : "→"}</span>
    <span style="flex-grow: 1;">${word.word}</span>
    <button class="rotate-btn" title="Xoay">↻</button>
`;

                        // Sự kiện kéo-thả cho cả thẻ từ
                        wordEl.addEventListener("mousedown", handleDragStart);
                        wordEl.addEventListener("touchstart", handleDragStart, {
                            passive: false,
                        });

                        // --- SỬA LẠI: Xử lý riêng cho nút xoay ---
                        const rotateBtn = wordEl.querySelector(".rotate-btn");
                        const handleRotate = (e) => {
                            e.stopPropagation(); // <-- Quan trọng: Ngăn sự kiện lan ra ngoài, tránh kích hoạt kéo-thả
                            const wordId = parseInt(wordEl.dataset.id);
                            const wordData = state.words.find((w) => w.id === wordId);
                            if (wordData) {
                                wordData.direction = wordData.direction === "horizontal" ? "vertical" : "horizontal";
                                showToast(`Đã xoay từ "${wordData.word}"`, "info", 1000);
                            }
                        };

                        // Gán sự kiện click cho nút xoay
                        rotateBtn.addEventListener("click", handleRotate);
                        // Ngăn kéo-thả khi nhấn chuột/chạm vào nút xoay
                        rotateBtn.addEventListener("mousedown", (e) => e.stopPropagation());
                        rotateBtn.addEventListener("touchstart", (e) => e.stopPropagation());
                        // --- KẾT THÚC PHẦN SỬA LẠI ---

                        wordBank.appendChild(wordEl);
                    });
                };
                const renderPlacedWords = () => {
                    // Xóa các từ cũ đi
                    editorGrid.querySelectorAll(".placed-word").forEach((el) => el.remove());

                    const placedWords = state.words.filter((w) => w.hasOwnProperty("row") && w.row !== null);

                    placedWords.forEach((word) => {
                        const wordWrapper = document.createElement("div");
                        wordWrapper.className = "placed-word";
                        wordWrapper.dataset.id = word.id;
                        wordWrapper.style.position = "absolute";
                        wordWrapper.style.display = "flex";
                        // Vị trí dựa trên ô lưới (25px) và khoảng cách (1px)
                        wordWrapper.style.top = `${word.row * 26}px`;
                        wordWrapper.style.left = `${word.col * 26}px`;

                        if (word.direction === "vertical") {
                            wordWrapper.style.flexDirection = "column";
                        }
                        wordWrapper.style.gap = "1px";
                        // Tạo từng ô chữ cho từ
                        word.word.split("").forEach((char) => {
                            const letterEl = document.createElement("div");
                            letterEl.className = "editor-cell-letter";
                            letterEl.textContent = char;
                            letterEl.style.width = "25px";
                            letterEl.style.height = "25px";
                            wordWrapper.appendChild(letterEl);
                        });

                        // THÊM SỰ KIỆN ĐỂ CÓ THỂ KÉO LẠI TỪ ĐÃ ĐẶT
                        wordWrapper.addEventListener("mousedown", handleDragStart);
                        wordWrapper.addEventListener("touchstart", handleDragStart, {
                            passive: false,
                        });

                        editorGrid.appendChild(wordWrapper);
                    });
                };
                // DÁN HÀM MỚI NÀY VÀO SCRIPT
                const handleGridWordInteraction = (e) => {
                    const target = e.target.closest(".placed-word");
                    if (!target) return;

                    // Logic Xoay khi nhấp đúp
                    if (e.type === "dblclick") {
                        e.preventDefault();
                        const wordId = parseInt(target.dataset.id);
                        const wordData = state.words.find((w) => w.id === wordId);
                        if (!wordData) return;

                        // Lưu lại trạng thái cũ
                        const oldDirection = wordData.direction;
                        const newDirection = oldDirection === "horizontal" ? "vertical" : "horizontal";

                        // Thử xoay
                        wordData.direction = newDirection;

                        // Kiểm tra xem vị trí mới có hợp lệ không (trừ chính nó ra)
                        if (isPlacementValid(wordData, wordData.row, wordData.col, true)) {
                            showToast("Đã xoay!", "success", 1000);
                        } else {
                            // Nếu không hợp lệ, trả lại như cũ
                            wordData.direction = oldDirection;
                            showToast("Không thể xoay ở vị trí này!", "error");
                        }
                        renderPlacedWords(); // Cập nhật lại giao diện
                    }
                };

                // Gắn sự kiện vào lưới
                editorGrid.addEventListener("dblclick", handleGridWordInteraction);

                // --- CHANGE START: FIX GHOST JUMPING ---
                // The logic inside this function has been reordered to prevent the ghost from jumping.
                // It now calculates the position of the word *before* removing it from the grid for the drag operation.
                const handleDragStart = (e) => {
                    e.preventDefault();

                    const target = e.target.closest(".bank-word, .placed-word");
                    if (!target) return;

                    const wordId = parseInt(target.dataset.id);
                    const wordData = state.words.find((w) => w.id === wordId);
                    if (!wordData) return;

                    // Get all coordinate and position data BEFORE changing the DOM
                    const rect = target.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    editorState.startOffset = {
                        x: clientX - rect.left,
                        y: clientY - rect.top,
                    };
                    const gridRect = editorGrid.getBoundingClientRect();
                    editorState.gridOffset = {
                        x: gridRect.left + editorGrid.scrollLeft,
                        y: gridRect.top + editorGrid.scrollTop,
                    };

                    // If the word is already on the grid, update its state and re-render the grid
                    // This effectively "picks up" the word.
                    if (target.classList.contains("placed-word")) {
                        wordData.row = null;
                        wordData.col = null;
                        renderPlacedWords();
                    }

                    editorState.isDragging = true;
                    editorState.draggedWordId = wordId;

                    // Create the ghost element that follows the cursor
                    editorState.ghostElement = document.createElement("div");
                    editorState.ghostElement.className = "word-ghost";
                    if (wordData.direction === "vertical") {
                        editorState.ghostElement.style.flexDirection = "column";
                    }
                    wordData.word.split("").forEach((char) => {
                        const letterEl = document.createElement("div");
                        letterEl.className = "ghost-letter";
                        letterEl.textContent = char;
                        editorState.ghostElement.appendChild(letterEl);
                    });
                    document.body.appendChild(editorState.ghostElement);

                    // Create the preview element that snaps to the grid
                    editorState.placementPreview = document.createElement("div");
                    editorState.placementPreview.className = "placement-preview";
                    editorState.placementPreview.style.gap = "1px";
                    wordData.word.split("").forEach((char) => {
                        const letterEl = document.createElement("div");
                        letterEl.className = "preview-letter";
                        letterEl.textContent = char;
                        editorState.placementPreview.appendChild(letterEl);
                    });
                    editorGrid.appendChild(editorState.placementPreview);

                    updateGhostPosition(e);

                    document.addEventListener("mousemove", handleDragMove);
                    document.addEventListener("touchmove", handleDragMove, {
                        passive: false,
                    });
                    document.addEventListener("mouseup", handleDragEnd);
                    document.addEventListener("touchend", handleDragEnd);
                };
                // --- CHANGE END: FIX GHOST JUMPING ---

                const handleDragMove = (e) => {
                    if (!editorState.isDragging) return;
                    e.preventDefault();
                    updateGhostPosition(e);
                };

                // --- CHANGE START: HIDE REDUNDANT GHOST ---
                // This function now checks if the cursor is over the grid.
                // If it is, it hides the free-floating ghost and shows the grid preview.
                // If it's not, it does the opposite.
                const updateGhostPosition = (e) => {
                    if (!editorState.ghostElement || !editorState.placementPreview) return;

                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                    // Update the free-floating ghost's position
                    editorState.ghostElement.style.left = `${clientX - editorState.startOffset.x}px`;
                    editorState.ghostElement.style.top = `${clientY - editorState.startOffset.y}px`;

                    const gridRect = editorGrid.getBoundingClientRect();
                    const isOverGrid =
                        clientX >= gridRect.left &&
                        clientX <= gridRect.right &&
                        clientY >= gridRect.top &&
                        clientY <= gridRect.bottom;

                    if (isOverGrid) {
                        // Show the grid preview and hide the free-floating ghost
                        editorState.placementPreview.style.display = "flex";
                        editorState.ghostElement.style.display = "none";

                        const wordData = state.words.find((w) => w.id === editorState.draggedWordId);
                        let { row, col } = getGridCoordsFromEvent(e);
                        let snappedDirection = wordData.direction;

                        // --- Auto-snap and rotate logic ---
                        let hasFoundSnap = false;
                        for (let i = 0; i < wordData.word.length; i++) {
                            let checkRow = row,
                                checkCol = col;
                            if (snappedDirection === "horizontal") checkCol += i;
                            else checkRow += i;

                            const targetCellLetter = getLetterAt(checkRow, checkCol);
                            if (targetCellLetter && targetCellLetter.letter === wordData.word[i]) {
                                const targetWord = state.words.find((w) => w.id === targetCellLetter.wordId);
                                if (targetWord) {
                                    const newDirection =
                                        targetWord.direction === "horizontal" ? "vertical" : "horizontal";
                                    let newRow = checkRow,
                                        newCol = checkCol;
                                    if (newDirection === "horizontal") newCol = checkCol - i;
                                    else newRow = checkRow - i;

                                    if (isPlacementValid({ ...wordData, direction: newDirection }, newRow, newCol)) {
                                        snappedDirection = newDirection;
                                        row = newRow;
                                        col = newCol;
                                        hasFoundSnap = true;
                                        break;
                                    }
                                }
                            }
                        }
                        // --- End of auto-snap logic ---

                        const isValid = isPlacementValid({ ...wordData, direction: snappedDirection }, row, col);

                        // Update the grid preview's position and appearance
                        editorState.placementPreview.style.top = `${row * 26}px`;
                        editorState.placementPreview.style.left = `${col * 26}px`;
                        editorState.placementPreview.style.flexDirection =
                            snappedDirection === "vertical" ? "column" : "row";
                        editorState.placementPreview.classList.toggle("invalid", !isValid);
                        editorState.ghostElement.classList.toggle("invalid", !isValid);

                        editorState.finalPlacement = {
                            row,
                            col,
                            direction: snappedDirection,
                            isValid,
                        };
                    } else {
                        // Show the free-floating ghost and hide the grid preview
                        editorState.placementPreview.style.display = "none";
                        editorState.ghostElement.style.display = "flex";
                        editorState.finalPlacement = {
                            isValid: false,
                        }; // Mark as invalid if dropped outside
                    }
                };
                // --- CHANGE END: HIDE REDUNDANT GHOST ---

                const getGridCoordsFromEvent = (e) => {
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                    // SỬA LẠI: Tính toán vị trí dựa trên góc trên bên trái của bóng ma, không phải con trỏ
                    const ghostX = clientX - editorState.startOffset.x;
                    const ghostY = clientY - editorState.startOffset.y;

                    const x = ghostX - editorState.gridOffset.x;
                    const y = ghostY - editorState.gridOffset.y;

                    const col = Math.round(x / 26); // Dùng Math.round để cảm giác dính tốt hơn
                    const row = Math.round(y / 26);

                    return {
                        row,
                        col,
                    };
                };

                // --- CHANGE START: ALLOW PLACING ANYWHERE ---
                // The rule requiring a new word to connect to an existing word has been commented out.
                const isPlacementValid = (wordData, row, col, ignoreSelf = false) => {
                    const gridSize = calculateEditorGridSize();

                    // 1. Check if the word is outside the grid
                    if (row < 0 || col < 0 || row >= gridSize || col >= gridSize) return false;
                    if (wordData.direction === "horizontal" && col + wordData.word.length > gridSize) return false;
                    if (wordData.direction === "vertical" && row + wordData.word.length > gridSize) return false;

                    let intersectionFound = false;
                    const placedWords = state.words.filter(
                        (w) => w.hasOwnProperty("row") && w.row !== null && w.id !== wordData.id
                    );

                    // 2. Loop through each letter of the word to check for collisions
                    for (let i = 0; i < wordData.word.length; i++) {
                        let r = row,
                            c = col;
                        if (wordData.direction === "horizontal") {
                            c += i;
                        } else {
                            r += i;
                        }

                        const otherLetter = getLetterAt(r, c);

                        if (otherLetter) {
                            if (otherLetter.letter !== wordData.word[i]) return false; // Intersects but with the wrong letter
                            intersectionFound = true;
                        }

                        // Check for parallel collisions
                        const isIntersectionPoint = otherLetter !== null;

                        if (wordData.direction === "horizontal") {
                            if (!isIntersectionPoint) {
                                if (getLetterAt(r - 1, c) !== null) return false; // Word above
                                if (getLetterAt(r + 1, c) !== null) return false; // Word below
                            }
                            if (i === 0 && getLetterAt(r, c - 1) !== null) return false; // Word at the start
                            if (i === wordData.word.length - 1 && getLetterAt(r, c + 1) !== null) return false; // Word at the end
                        } else {
                            // Vertical
                            if (!isIntersectionPoint) {
                                if (getLetterAt(r, c - 1) !== null) return false; // Word to the left
                                if (getLetterAt(r, c + 1) !== null) return false; // Word to the right
                            }
                            if (i === 0 && getLetterAt(r - 1, c) !== null) return false; // Word at the start
                            if (i === wordData.word.length - 1 && getLetterAt(r + 1, c) !== null) return false; // Word at the end
                        }
                    }

                    // 3. This rule is now disabled to allow placing words freely.
                    //if (!ignoreSelf && placedWords.length > 0 && !intersectionFound) return false;

                    return true;
                };
                // --- CHANGE END: ALLOW PLACING ANYWHERE ---

                const getLetterAt = (row, col) => {
                    for (const word of state.words) {
                        if (!word.hasOwnProperty("row") || word.row === null) continue;

                        if (
                            word.direction === "horizontal" &&
                            word.row === row &&
                            col >= word.col &&
                            col < word.col + word.word.length
                        ) {
                            return {
                                letter: word.word[col - word.col],
                                wordId: word.id,
                            };
                        }
                        if (
                            word.direction === "vertical" &&
                            word.col === col &&
                            row >= word.row &&
                            row < word.row + word.word.length
                        ) {
                            return {
                                letter: word.word[row - word.row],
                                wordId: word.id,
                            };
                        }
                    }
                    return null;
                };

                const handleDragEnd = (e) => {
                    if (!editorState.isDragging) return;

                    // Only place the word if the final placement was valid
                    if (editorState.finalPlacement && editorState.finalPlacement.isValid) {
                        const { row, col, direction } = editorState.finalPlacement;
                        const wordData = state.words.find((w) => w.id === editorState.draggedWordId);
                        if (wordData) {
                            wordData.row = row;
                            wordData.col = col;
                            wordData.direction = direction;
                        }
                    }

                    // Cleanup ghost and preview elements
                    if (editorState.ghostElement) editorState.ghostElement.remove();
                    if (editorState.placementPreview) editorState.placementPreview.remove();
                    const lingeringPreviews = editorGrid.querySelectorAll(".placement-preview");
                    lingeringPreviews.forEach((el) => el.remove());
                    // Reset dragging state
                    editorState.isDragging = false;
                    editorState.ghostElement = null;
                    editorState.placementPreview = null;
                    editorState.draggedWordId = null;

                    // Remove event listeners
                    document.removeEventListener("mousemove", handleDragMove);
                    document.removeEventListener("touchmove", handleDragMove);
                    document.removeEventListener("mouseup", handleDragEnd);
                    document.removeEventListener("touchend", handleDragEnd);

                    // Re-render the editor UI
                    renderWordBank();
                    renderPlacedWords();
                };

                // Chuyển đổi giữa 2 tab
                const switchCreationTab = (tabName) => {
                    if (tabName === "arrange") {
                        initEditor();
                        tabBtnWords.classList.remove("active");
                        tabBtnArrange.classList.add("active");
                        tabContentWords.classList.remove("active");
                        tabContentArrange.classList.add("active");
                    } else {
                        tabBtnWords.classList.add("active");
                        tabBtnArrange.classList.remove("active");
                        tabContentWords.classList.add("active");
                        tabContentArrange.classList.remove("active");
                    }
                };

                tabBtnWords.addEventListener("click", () => switchCreationTab("words"));
                tabBtnArrange.addEventListener("click", () => switchCreationTab("arrange"));
                addWordFab.addEventListener("click", () => {
                    updateStateFromForms();
                    // Tạo ID mới an toàn hơn
                    const newId = state.words.length > 0 ? Math.max(...state.words.map((w) => w.id)) + 1 : 0;
                    state.words.push({
                        id: newId,
                        word: "",
                        clue: "",
                        direction: "horizontal", // Thêm các thuộc tính mặc định
                        row: null,
                        col: null,
                    });
                    renderWordForms();
                    wordListContainer.scrollTop = wordListContainer.scrollHeight;
                });
                wordListContainer.addEventListener("click", (e) => {
                    // 1. Dùng .closest() để đảm bảo bắt được sự kiện dù người dùng bấm vào icon SVG
                    const removeBtn = e.target.closest(".remove-word-btn");

                    if (removeBtn) {
                        // Cập nhật trạng thái từ các form khác trước khi xóa
                        updateStateFromForms();

                        // 2. Lấy .word-card cha để tìm đúng `data-id` của từ cần xóa
                        const cardToRemove = removeBtn.closest(".word-card");
                        const wordIdToRemove = parseInt(cardToRemove.dataset.id);

                        // 3. Dùng .filter() để xóa từ khỏi mảng một cách an toàn dựa trên ID
                        state.words = state.words.filter((word) => word.id !== wordIdToRemove);

                        // Render lại danh sách từ sau khi đã xóa
                        renderWordForms();
                    }
                });

                // TÌM VÀ THAY THẾ TOÀN BỘ KHỐI NÀY
                savePuzzleBtn.addEventListener("click", () => {
                    updateStateFromForms(); // Cập nhật dữ liệu từ ô nhập liệu vào biến state

                    // 1. Kiểm tra tên bộ đề
                    const title = puzzleTitleInput.value.trim();
                    if (!title) {
                        showToast("Vui lòng nhập tên bộ đề.", "error");
                        return;
                    }

                    // 2. KIỂM TRA TỪNG TỪ: Có từ mà không có gợi ý (hoặc ngược lại)
                    // Đây là đoạn logic mới bạn yêu cầu
                    for (let i = 0; i < state.words.length; i++) {
                        const w = state.words[i];
                        const hasWord = w.word && w.word.trim().length > 0;
                        const hasClue = w.clue && w.clue.trim().length > 0;

                        // Trường hợp: Đã nhập Từ nhưng quên Gợi ý
                        if (hasWord && !hasClue) {
                            showToast(`Lỗi ở từ #${i + 1} ("${w.word}"): Thiếu gợi ý!`, "error");
                            switchCreationTab("words"); // Tự động chuyển về tab nhập liệu để user sửa

                            // Highlight ô bị lỗi (tùy chọn)
                            const errorInput = document.querySelector(`.word-card[data-id="${w.id}"] .clue-input`);
                            if (errorInput) errorInput.focus();

                            return; // Dừng lưu ngay lập tức
                        }

                        // Trường hợp: Đã nhập Gợi ý nhưng quên nhập Từ
                        if (!hasWord && hasClue) {
                            showToast(`Lỗi ở từ #${i + 1}: Có gợi ý nhưng chưa nhập từ!`, "error");
                            switchCreationTab("words");
                            const errorInput = document.querySelector(`.word-card[data-id="${w.id}"] .word-input`);
                            if (errorInput) errorInput.focus();
                            return;
                        }
                    }

                    // 3. Lọc ra các từ hợp lệ (đầy đủ cả từ và gợi ý)
                    const validWords = state.words.filter((w) => w.word && w.clue);

                    // 4. Kiểm tra số lượng từ tối thiểu
                    if (validWords.length < 2) {
                        showToast("Cần ít nhất 2 từ hoàn chỉnh (có đủ Từ và Gợi ý).", "error");
                        switchCreationTab("words");
                        return;
                    }

                    // 5. Kiểm tra xem tất cả từ đã được xếp vào lưới chưa
                    const unplacedWords = validWords.filter((w) => !w.hasOwnProperty("row") || w.row === null);
                    if (unplacedWords.length > 0) {
                        showToast(`Còn ${unplacedWords.length} từ chưa được xếp vào lưới!`, "error");
                        switchCreationTab("arrange"); // Tự động chuyển sang tab xếp lưới
                        return;
                    }

                    // --- NẾU TẤT CẢ OK THÌ TIẾN HÀNH LƯU ---

                    // Chuẩn hóa tọa độ để lưới bắt đầu từ 0,0
                    let minRow = Infinity,
                        minCol = Infinity;
                    validWords.forEach((word) => {
                        minRow = Math.min(minRow, word.row);
                        minCol = Math.min(minCol, word.col);
                    });

                    const arrangedWords = validWords.map((word) => ({
                        ...word,
                        row: word.row - minRow,
                        col: word.col - minCol,
                    }));

                    const puzzles = getPuzzles();
                    const puzzleId = state.currentPuzzleId || `puzzle_${Date.now()}`;
                    puzzles[puzzleId] = {
                        id: puzzleId,
                        title: title,
                        words: arrangedWords.map(({ word, clue }) => ({
                            word,
                            clue,
                        })), // Chỉ lưu word, clue cho gọn trong danh sách preview
                        arrangedWords: arrangedWords, // Lưu toàn bộ dữ liệu đã xếp
                        lastModified: Date.now(),
                    };
                    savePuzzles(puzzles);
                    localStorage.removeItem(`slam-gamestate-${puzzleId}`);
                    showToast("Đã lưu bộ đề thành công!", "success");
                    switchView("lobby");
                });
                deletePuzzleBtn.addEventListener("click", async () => {
                    if (!state.currentPuzzleId) return;
                    const confirmed = await showConfirmation("Xóa Bộ Đề?", "Hành động này không thể hoàn tác.");
                    if (confirmed) {
                        const puzzles = getPuzzles();
                        delete puzzles[state.currentPuzzleId];
                        savePuzzles(puzzles);
                        localStorage.removeItem(`slam-gamestate-${state.currentPuzzleId}`);
                        showToast("Đã xóa bộ đề.", "success");
                        switchView("lobby");
                    }
                });

                backToLobbyBtn.addEventListener("click", () => switchView("lobby"));
                backToLobbyBtnGame.addEventListener("click", () => switchView("lobby"));

                const animateWordSolved = async (wordId) => {
                    const wordData = state.words.find((w) => w.id === wordId);
                    if (!wordData) return;

                    const playableCells = [];
                    for (let i = 0; i < wordData.word.length; i++) {
                        let r = wordData.row,
                            c = wordData.col;
                        if (wordData.direction === "horizontal") c += i;
                        else r += i;
                        const playable = gridContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        if (playable) playableCells.push(playable);
                    }

                    const dominoDelay = 60;
                    const animationDuration = 250;
                    const holdDuration = 800; // Tăng thời gian chờ để người chơi kịp nhìn thấy chữ có dấu

                    // GIAI ĐOẠN 1: MÀU CAM - HIỆN CHỮ GỐC (CÓ DẤU)
                    const phase1Promises = playableCells.map((cell, i) => {
                        return new Promise((resolve) => {
                            setTimeout(() => {
                                cell.classList.remove("anim-typing", "is-solved");
                                cell.classList.add("anim-correct-phase1");

                                const cellFront = cell.querySelector(".cell-front");
                                // Luôn hiển thị chữ gốc (có dấu) ở giai đoạn này
                                cellFront.innerHTML = `<span class="letter-reveal-anim">${wordData.word[i]}</span>`;

                                setTimeout(resolve, animationDuration + 40);
                            }, i * dominoDelay);
                        });
                    });
                    await Promise.all(phase1Promises);
                    await delay(holdDuration);

                    // GIAI ĐOẠN 2: MÀU TRẮNG - VỀ CHỮ KHÔNG DẤU (NẾU BẬT CHẾ ĐỘ TV)
                    const phase2Promises = playableCells.map((cell, i) => {
                        return new Promise((resolve) => {
                            setTimeout(() => {
                                cell.classList.remove("anim-correct-phase1");
                                cell.classList.add("anim-correct-phase2");
                                const cellFront = cell.querySelector(".cell-front");

                                // --- LOGIC MỚI: CHUYỂN VỀ KHÔNG DẤU ---
                                let finalChar = wordData.word[i];
                                if (state.vietnameseKeyboardEnabled) {
                                    finalChar = removeVietnameseTones(finalChar);
                                }

                                cellFront.textContent = finalChar;

                                setTimeout(resolve, animationDuration);
                            }, i * dominoDelay);
                        });
                    });
                    await Promise.all(phase2Promises);

                    // Dọn dẹp
                    playableCells.forEach((cell, i) => {
                        cell.classList.remove("anim-correct-phase2");
                        cell.classList.add("is-solved");

                        // Đảm bảo trạng thái cuối cùng là không dấu
                        const cellFront = cell.querySelector(".cell-front");
                        let finalChar = wordData.word[i];
                        if (state.vietnameseKeyboardEnabled) {
                            finalChar = removeVietnameseTones(finalChar);
                        }
                        cellFront.textContent = finalChar;
                    });
                };

                const saveGameState = () => {
                    if (state.isGameFinished) return;
                    if (!state.currentPuzzleId) return;
                    const gridContent = {};
                    gridContainer.querySelectorAll(".playable").forEach((cell) => {
                        const text = cell.querySelector(".cell-front").textContent;
                        if (text) gridContent[`${cell.dataset.row}-${cell.dataset.col}`] = text;
                    });
                    const gameState = {
                        solvedWords: Array.from(state.solvedWords),
                        revealedLetters: Array.from(state.revealedLetters),
                        elapsedSeconds:
                            state.elapsedSeconds +
                            (state.startTime ? Math.floor((Date.now() - state.startTime) / 1000) : 0),
                        totalScore: state.totalScore,
                        gridContent: gridContent,
                        slamModeActive: state.slamModeActive,
                        disabledLetters: Array.from(state.disabledLetters),
                        turnCount: state.turnCount,
                        gamePhase: state.gamePhase, // Lưu lại giai đoạn hiện tại của game
                        playableWordIds: Array.from(state.playableWordIds), // Lưu lại danh sách các từ có thể chơi
                        selectedWordId: state.selectedWordId,
                    };
                    localStorage.setItem(`slam-gamestate-${state.currentPuzzleId}`, JSON.stringify(gameState));
                };
                const selectNextLetterToReveal = () => {
                    // 1. Lấy danh sách các từ chưa giải quyết xong
                    const unsolvedWords = state.words.filter((w) => !state.solvedWords.has(w.id));
                    if (unsolvedWords.length === 0) return null;

                    // --- BƯỚC 1: XÁC ĐỊNH CÁC Ô ĐÃ SÁNG ĐÈN (VISIBILITY MAP) ---
                    // Tập hợp tọa độ các ô đã hiện chữ (do người chơi giải được từ chứa ô đó hoặc đã được tiết lộ trước đó)
                    const visibleCells = new Set();
                    state.solvedWords.forEach((id) => {
                        const w = state.words.find((word) => word.id === id);
                        if (w) {
                            for (let i = 0; i < w.word.length; i++) {
                                let r = w.row,
                                    c = w.col;
                                if (w.direction === "horizontal") c += i;
                                else r += i;
                                visibleCells.add(`${r}-${c}`);
                            }
                        }
                    });

                    // --- BƯỚC 2: TÌM ỨNG VIÊN (CÓ LOGIC LOẠI TRỪ FAIL) ---
                    // Chỉ chọn những ký tự nằm ở các ô ĐANG BỊ ẨN
                    const candidates = new Set();
                    unsolvedWords.forEach((w) => {
                        for (let i = 0; i < w.word.length; i++) {
                            const char = w.word[i];

                            // ★ QUAN TRỌNG: Bỏ qua chữ cái này nếu người chơi từng trả lời sai câu hỏi logic về nó
                            if (state.failedRevealLetters.has(char)) continue;

                            let r = w.row,
                                c = w.col;
                            if (w.direction === "horizontal") c += i;
                            else r += i;

                            // Kiểm tra xem ô này đã hiện chưa?
                            // 1. Hiện do máy đã mở global chữ này (state.revealedLetters)
                            // 2. Hiện do ô này thuộc về một từ người chơi đã giải (visibleCells)
                            const isVisible = state.revealedLetters.has(char) || visibleCells.has(`${r}-${c}`);

                            // Chỉ thêm vào danh sách nếu ô này VẪN CÒN ẨN
                            if (!isVisible) {
                                candidates.add(char);
                            }
                        }
                    });

                    // --- BƯỚC 3: KIỂM TRA AN TOÀN (GIỮ NGUYÊN LOGIC CŨ) ---
                    const safeCandidates = Array.from(candidates).filter((charToTest) => {
                        // Giả lập: Mở chữ này ra thì có từ nào hoàn thành 100% không?
                        for (const wordData of unsolvedWords) {
                            let isWordFullyVisible = true;

                            for (let i = 0; i < wordData.word.length; i++) {
                                const letter = wordData.word[i];
                                let r = wordData.row,
                                    c = wordData.col;
                                if (wordData.direction === "horizontal") c += i;
                                else r += i;

                                // Một ô được coi là SẼ HIỆN trong tương lai giả định nếu:
                                // 1. Nó là chữ đang test
                                // 2. Nó đã được máy mở trước đó
                                // 3. Nó là ô đã giải của người chơi
                                const isCellVisibleFuture =
                                    letter === charToTest ||
                                    state.revealedLetters.has(letter) ||
                                    visibleCells.has(`${r}-${c}`);

                                if (!isCellVisibleFuture) {
                                    isWordFullyVisible = false;
                                    break;
                                }
                            }

                            // Nếu từ này bị hoàn thành -> Nguy hiểm -> Loại
                            if (isWordFullyVisible) return false;
                        }
                        return true;
                    });

                    if (safeCandidates.length === 0) return null;

                    // --- BƯỚC 4 & 5: CHIẾN THUẬT CHỌN LỰA ---

                    // Tính toán tần suất xuất hiện của ô (để biết giao điểm)
                    const cellOccupancy = {};
                    state.words.forEach((w) => {
                        for (let i = 0; i < w.word.length; i++) {
                            let r = w.row,
                                c = w.col;
                            if (w.direction === "horizontal") c += i;
                            else r += i;
                            cellOccupancy[`${r}-${c}`] = (cellOccupancy[`${r}-${c}`] || 0) + 1;
                        }
                    });

                    const candidateDetails = safeCandidates.map((char) => {
                        let frequency = 0;
                        let intersectionCount = 0;
                        let wordsWithChar = new Set();

                        unsolvedWords.forEach((w) => {
                            if (w.word.includes(char)) {
                                wordsWithChar.add(w.id);
                                for (let i = 0; i < w.word.length; i++) {
                                    if (w.word[i] === char) {
                                        frequency++;
                                        let r = w.row,
                                            c = w.col;
                                        if (w.direction === "horizontal") c += i;
                                        else r += i;
                                        if (cellOccupancy[`${r}-${c}`] > 1) {
                                            intersectionCount++;
                                        }
                                    }
                                }
                            }
                        });

                        const wordCount = wordsWithChar.size;
                        const nonIntersectionCount = frequency - intersectionCount;

                        return { char, frequency, wordCount, intersectionCount, nonIntersectionCount };
                    });

                    candidateDetails.sort((a, b) => {
                        // 1. Xuất hiện >=2 từ, không giao nhau (Ưu tiên cao nhất)
                        const a_P1 = a.wordCount >= 2 && a.intersectionCount === 0;
                        const b_P1 = b.wordCount >= 2 && b.intersectionCount === 0;
                        if (a_P1 && !b_P1) return -1;
                        if (!a_P1 && b_P1) return 1;

                        // 2. Chỉ nằm ở điểm giao nhau
                        const a_P2 = a.nonIntersectionCount === 0 && a.intersectionCount > 0;
                        const b_P2 = b.nonIntersectionCount === 0 && b.intersectionCount > 0;
                        if (a_P2 && !b_P2) return -1;
                        if (!a_P2 && b_P2) return 1;

                        // 3. Chỉ có ở 1 từ duy nhất (Đẩy lên trước Frequency)
                        const a_P4 = a.wordCount === 1;
                        const b_P4 = b.wordCount === 1;
                        if (a_P4 && !b_P4) return -1;
                        if (!a_P4 && b_P4) return 1;

                        // 4. Frequency cao nhất (Đã chuyển xuống cuối cùng theo yêu cầu)
                        if (b.frequency !== a.frequency) return b.frequency - a.frequency;

                        return 0;
                    });

                    return candidateDetails[0].char;
                };

                const alphabet = "AĂÂBCDĐEÊGHIKLMNOÔƠPQRSTUƯVXY"; // Bảng chữ cái tiếng Việt mở rộng (tùy chỉnh nếu muốn dùng bảng English)
                const alphabetSimple = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; // Dùng bảng này cho chuẩn logic quốc tế và khớp với bàn phím

                const generateLogicQuestion = (targetChar) => {
                    targetChar = targetChar.toUpperCase();
                    const targetIndex = alphabetSimple.indexOf(targetChar);
                    if (targetIndex === -1) return null; // Ký tự không nằm trong bảng chữ cái (ví dụ số)

                    const type = Math.random() > 0.5 ? "shift" : "middle";

                    // Dạng 1: Dịch chuyển (Thứ n sau/trước X)
                    if (type === "shift") {
                        const direction = Math.random() > 0.5 ? 1 : -1; // 1: Xuôi (Sau), -1: Ngược (Trước)
                        const offset = Math.floor(Math.random() * 5) + 1; // 1 đến 5

                        // Tính chữ cái mốc (Start Char)
                        // Target = Start + offset * dir => Start = Target - offset * dir
                        let startIndex = (targetIndex - offset * direction) % alphabetSimple.length;
                        if (startIndex < 0) startIndex += alphabetSimple.length;

                        const startChar = alphabetSimple[startIndex];
                        const dirText = direction === 1 ? "theo chiều xuôi" : "theo chiều ngược";
                        const afterText = direction === 1 ? "sau" : "trước"; // Dùng từ ngữ phù hợp

                        return {
                            text: `Chữ cái nào nằm ở thứ ${offset} ${afterText} chữ "${startChar}" ${dirText} của bảng chữ cái (English)?`,
                            answer: targetChar,
                        };
                    }
                    // Dạng 2: Ở giữa
                    else {
                        // Tìm A và B sao cho Target ở giữa. Target = (A + B) / 2
                        // A = Target - distance, B = Target + distance
                        // Cần đảm bảo A và B nằm trong giới hạn 0-25

                        const maxDist = Math.min(targetIndex, 25 - targetIndex);
                        if (maxDist < 1) {
                            // Nếu là A hoặc Z thì không có ở giữa, fallback về dạng shift
                            return generateLogicQuestion(targetChar);
                        }

                        const distance = Math.floor(Math.random() * maxDist) + 1;
                        const charA = alphabetSimple[targetIndex - distance];
                        const charB = alphabetSimple[targetIndex + distance];

                        return {
                            text: `Chữ cái nào nằm ở chính giữa chữ "${charA}" và chữ "${charB}" trong bảng chữ cái?`,
                            answer: targetChar,
                        };
                    }
                };
                const performAutoReveal = async () => {
                    if (state.gamePhase !== "reveal" || state.isGameFinished) return;

                    const letterToReveal = selectNextLetterToReveal();

                    // Nếu không còn chữ nào an toàn hoặc hết chữ để chọn
                    if (!letterToReveal) {
                        const unsolvedWords = state.words.filter((w) => !state.solvedWords.has(w.id));
                        if (unsolvedWords.length > 0) {
                            state.gamePhase = "playing";
                            state.turnCount++;
                            document.getElementById("turn-display").textContent = `Lượt ${state.turnCount}`;
                            state.playableWordIds.clear();
                            unsolvedWords.forEach((w) => state.playableWordIds.add(w.id));

                            showToast("Đến lượt bạn! Hãy hoàn thành các từ còn lại.", "info", 3000);
                            clueText.textContent = "Thử thách: Điền các ký tự cuối cùng!";
                            deselectWord();
                            saveGameState();
                        } else {
                            triggerWinAnimation();
                        }
                        return;
                    }

                    // --- LOGIC MỚI: KIỂM TRA CHẾ ĐỘ THỦ CÔNG ---
                    if (state.manualRevealEnabled) {
                        const questionData = generateLogicQuestion(letterToReveal);
                        if (questionData) {
                            // Kích hoạt UI Challenge
                            state.challengeModeActive = true;
                            state.currentChallengeTarget = letterToReveal;
                            state.isProcessingChallenge = false; // Reset cờ mỗi khi bắt đầu câu hỏi mới

                            // Hiển thị UI
                            revealChallengeContainer.classList.add("visible");
                            challengeQuestionText.textContent = questionData.text;
                            challengeInput.value = "";
                            challengeFeedback.textContent = "";
                            challengeFeedback.className = "challenge-feedback";

                            // Hiện bàn phím ảo
                            keyboardWrapper.classList.add("visible");
                            clueText.textContent = "Giải câu đố logic để mở chữ cái!";

                            updateEnterButtonState(); // <--- THÊM DÒNG NÀY ĐỂ ĐỔI NÚT THÀNH "GỬI" NGAY

                            return;
                        }
                    }
                    // ------------------------------------------

                    // Nếu không bật chế độ thủ công hoặc không tạo được câu hỏi

                    await delay(1000);
                    revealLetterOnGrid(letterToReveal);
                    //showToast(`Tiết lộ chữ: ${letterToReveal}`, "info", 1500);
                };
                const loadGameState = () => {
                    const savedState = localStorage.getItem(`slam-gamestate-${state.currentPuzzleId}`);
                    if (!savedState) return;
                    try {
                        const gameState = JSON.parse(savedState);
                        if (gameState.isComplete) {
                            localStorage.removeItem(`slam-gamestate-${state.currentPuzzleId}`);
                            showToast("Bắt đầu màn chơi mới!", "info");
                            return false;
                        }
                        state.turnCount = gameState.turnCount || 0; // <--- THÊM DÒNG NÀY
                        document.getElementById("turn-display").textContent = `Lượt ${state.turnCount}`; // <--- CẬP NHẬT UI
                        state.solvedWords = new Set(gameState.solvedWords || []);
                        state.revealedLetters = new Set(gameState.revealedLetters || []);
                        state.elapsedSeconds = gameState.elapsedSeconds || 0;
                        state.totalScore = gameState.totalScore || 0;
                        state.slamModeActive = gameState.slamModeActive || false;
                        state.disabledLetters = new Set(gameState.disabledLetters || []);

                        if (gameState.gamePhase) {
                            state.gamePhase = gameState.gamePhase;
                        }
                        state.playableWordIds = new Set(gameState.playableWordIds || []);

                        updateScore(0);
                        if (gameState.gridContent) {
                            for (const key in gameState.gridContent) {
                                const [r, c] = key.split("-");
                                const cell = gridContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                                if (cell) cell.querySelector(".cell-front").textContent = gameState.gridContent[key];
                            }
                        }

                        // --- BẮT ĐẦU CODE MỚI ---
                        // Sau khi điền các chữ cái, hãy áp dụng lại style màu trắng cho các ô đã được tiết lộ
                        if (state.revealedLetters.size > 0) {
                            state.words.forEach((wordData) => {
                                // Không cần xử lý lại những từ đã được giải hoàn toàn
                                if (state.solvedWords.has(wordData.id)) return;

                                for (let i = 0; i < wordData.word.length; i++) {
                                    const letter = wordData.word[i];
                                    // Nếu chữ cái trong từ này nằm trong danh sách đã tiết lộ
                                    if (state.revealedLetters.has(letter)) {
                                        let r = wordData.row,
                                            c = wordData.col;
                                        if (wordData.direction === "horizontal") c += i;
                                        else r += i;
                                        const cell = gridContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                                        // Thêm class 'is-solved' để nó có màu trắng
                                        if (cell) {
                                            cell.classList.add("is-solved");
                                            // Đảm bảo hiển thị không dấu nếu load lại
                                            if (state.vietnameseKeyboardEnabled) {
                                                cell.querySelector(".cell-front").textContent =
                                                    removeVietnameseTones(letter);
                                            } else {
                                                cell.querySelector(".cell-front").textContent = letter;
                                            }
                                        }
                                    }
                                }
                            });
                        }
                        // --- KẾT THÚC CODE MỚI ---

                        state.solvedWords.forEach((wordId) => {
                            const wordData = state.words.find((w) => w.id === wordId);
                            if (wordData) {
                                for (let i = 0; i < wordData.word.length; i++) {
                                    let r = wordData.row,
                                        c = wordData.col;
                                    if (wordData.direction === "horizontal") c += i;
                                    else r += i;
                                    const cell = gridContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                                    if (cell) cell.classList.add("is-solved");
                                }
                            }
                        });
                        if (gameState.selectedWordId !== null && gameState.selectedWordId !== undefined) {
                            // Nếu có, hãy khôi phục lại lựa chọn đó
                            state.selectedWordId = gameState.selectedWordId;
                            // Gọi hàm updateSelectionAndFocus để cập nhật giao diện (hiển thị gợi ý, bàn phím, phóng to ô chữ...)
                            // Dùng setTimeout để đảm bảo grid đã được render hoàn chỉnh
                            setTimeout(() => {
                                updateSelectionAndFocus();
                            }, 100);
                        }
                    } catch (e) {
                        console.error("Lỗi tải game:", e);
                    }
                };
                const updateScore = (change) => {
                    state.totalScore += change;
                    scoreDisplay.textContent = state.totalScore;
                };

                const startTimer = () => {
                    if (state.timerInterval) clearInterval(state.timerInterval); // Thay stopTimer() bằng dòng này
                    state.startTime = Date.now();
                    state.timerInterval = setInterval(() => {
                        const elapsed = state.elapsedSeconds + Math.floor((Date.now() - state.startTime) / 1000);
                        const minutes = String(Math.floor(elapsed / 60)).padStart(2, "0");
                        const seconds = String(elapsed % 60).padStart(2, "0");
                        timerDisplay.textContent = `${minutes}:${seconds}`;
                    }, 1000);
                };
                const stopTimer = () => {
                    if (state.timerInterval) {
                        state.elapsedSeconds += Math.floor((Date.now() - state.startTime) / 1000);
                        clearInterval(state.timerInterval);
                        state.timerInterval = null;
                        state.startTime = 0;
                    }
                };

                const startWordTimer = () => {
                    stopWordTimer();
                    state.wordTimeLeft = 30;
                    wordTimerDisplay.textContent = `00:${state.wordTimeLeft}`;
                    state.wordTimerInterval = setInterval(() => {
                        state.wordTimeLeft--;
                        wordTimerDisplay.textContent = `00:${String(state.wordTimeLeft).padStart(2, "0")}`;
                        if (state.wordTimeLeft <= 0) {
                            handleWordTimeout();
                        }
                    }, 1000);
                };
                const stopWordTimer = () => {
                    if (state.wordTimerInterval) clearInterval(state.wordTimerInterval);
                    state.wordTimerInterval = null;
                    wordTimerDisplay.textContent = "00:30";
                };

                const stopGame = () => {
                    stopTimer();
                    stopWordTimer();
                    if (state.currentPage === "game") saveGameState();
                };

                const updateStats = () => {
                    wordsSolvedStat.textContent = `${state.solvedWords.size}/${state.words.length}`;
                };
                const repositionNumberLabels = () => {
                    document.querySelectorAll(".word-number-label").forEach((label) => {
                        const wordId = parseInt(label.dataset.wordId);
                        if (isNaN(wordId)) return;

                        const wordData = state.words.find((w) => w.id === wordId);
                        const firstCell = gridContainer.querySelector(
                            `.cell:has([data-row="${wordData.row}"][data-col="${wordData.col}"])`
                        );

                        if (firstCell && wordData) {
                            const gap = parseInt(getComputedStyle(gridContainer).gap) || 2;
                            // Reset lại transform trước khi tính toán để tránh lỗi cộng dồn
                            label.style.transform = "";

                            if (wordData.direction === "horizontal") {
                                label.style.top = `${firstCell.offsetTop + firstCell.offsetHeight / 2}px`;
                                label.style.left = `${firstCell.offsetLeft - gap}px`;
                                label.style.transform = "translate(-100%, -50%)";
                            } else {
                                // vertical
                                label.style.top = `${firstCell.offsetTop - gap}px`;
                                label.style.left = `${firstCell.offsetLeft + firstCell.offsetWidth / 2}px`;
                                label.style.transform = "translate(-50%, -100%)";
                            }
                        }
                    });
                };

                const adjustGridSize = () => {
                    const gridData = generateGridData(JSON.parse(JSON.stringify(state.words)));
                    if (gridData.rows === 0 || gridData.cols === 0) return;
                    const availableWidth = gameArea.clientWidth - 20;
                    const availableHeight = gameArea.clientHeight - 20;
                    const cellSizeByWidth = availableWidth / (gridData.cols + 1.5);
                    const cellSizeByHeight = availableHeight / (gridData.rows + 1.5);
                    const newCellSize = Math.floor(Math.min(cellSizeByWidth, cellSizeByHeight));
                    document.documentElement.style.setProperty("--cell-size", `${newCellSize}px`);
                };

                const createGameGrid = () => {
                    const gridData = generateGridData(state.words);
                    state.words = gridData.words;
                    adjustGridSize();
                    gridContainer.innerHTML = "";
                    numberOverlay.innerHTML = ""; // Dọn sạch overlay

                    // --- PHẦN CODE MỚI ĐƯỢC THÊM VÀO ---
                    // Tạo các nhãn số cho mỗi từ
                    state.words.forEach((word, index) => {
                        const numberLabel = document.createElement("div");
                        numberLabel.className = "word-number-label";
                        numberLabel.dataset.wordId = word.id;
                        numberLabel.textContent = index + 1;
                        numberOverlay.appendChild(numberLabel);
                    });
                    // --- KẾT THÚC PHẦN CODE MỚI ---

                    const fragment = document.createDocumentFragment();

                    gridContainer.style.gridTemplateRows = `repeat(${gridData.rows}, var(--cell-size))`;
                    gridContainer.style.gridTemplateColumns = `repeat(${gridData.cols}, var(--cell-size))`;

                    for (let r = 0; r < gridData.rows; r++) {
                        for (let c = 0; c < gridData.cols; c++) {
                            const key = `${r}-${c}`;
                            const cellDiv = document.createElement("div");
                            cellDiv.className = "cell";
                            if (gridData.grid.has(key)) {
                                const cellInfo = gridData.grid.get(key);
                                cellDiv.innerHTML = `<div class="playable" data-row="${r}" data-col="${c}"><div class="cell-face cell-front"></div></div>`;
                                const playableDiv = cellDiv.querySelector(".playable");
                                cellInfo.wordIds.forEach((id) => (playableDiv.dataset[`word_${id}`] = true));
                            }

                            // BƯỚC 2: Thay vì thêm vào gridContainer, hãy thêm vào fragment.
                            // Thao tác này rất nhanh vì nó diễn ra trong bộ nhớ.
                            fragment.appendChild(cellDiv);
                        }
                    }

                    // BƯỚC 3: Sau khi vòng lặp kết thúc, thêm toàn bộ fragment vào gridContainer
                    // chỉ bằng một thao tác duy nhất.
                    gridContainer.innerHTML = ""; // Xóa grid cũ trước
                    gridContainer.appendChild(fragment);

                    setTimeout(() => {
                        repositionNumberLabels();
                    }, 100);
                };
                const generateGridData = (words) => {
                    if (!words || words.length === 0)
                        return {
                            grid: new Map(),
                            rows: 0,
                            cols: 0,
                        };
                    const wordsCopy = JSON.parse(JSON.stringify(words));
                    let minR = Infinity,
                        maxR = -Infinity,
                        minC = Infinity,
                        maxC = -Infinity;
                    wordsCopy.forEach((word) => {
                        let r = word.row,
                            c = word.col;
                        minR = Math.min(minR, r);
                        minC = Math.min(minC, c);
                        if (word.direction === "horizontal") {
                            maxC = Math.max(maxC, c + word.word.length - 1);
                            maxR = Math.max(maxR, r);
                        } else {
                            maxR = Math.max(maxR, r + word.word.length - 1);
                            maxC = Math.max(maxC, c);
                        }
                    });
                    const grid = new Map();
                    wordsCopy.forEach((word) => {
                        word.row -= minR;
                        word.col -= minC;
                        let r = word.row;
                        let c = word.col;
                        for (let i = 0; i < word.word.length; i++) {
                            const key = `${r}-${c}`;
                            const originalChar = word.word[i].toUpperCase();
                            // Nếu bật chế độ TV, chữ hiển thị trên lưới (khi chưa giải hoặc đã giải xong) là chữ không dấu
                            const displayChar = state.vietnameseKeyboardEnabled
                                ? removeVietnameseTones(originalChar)
                                : originalChar;

                            if (!grid.has(key))
                                grid.set(key, {
                                    letter: displayChar, // Dùng displayChar để render HTML
                                    wordIds: new Set(),
                                });
                            grid.get(key).wordIds.add(word.id);
                            if (word.direction === "horizontal") c++;
                            else r++;
                        }
                    });
                    return {
                        grid,
                        rows: maxR - minR + 1,
                        cols: maxC - minC + 1,
                        words: wordsCopy,
                    };
                };

                const triggerWinAnimation = () => {
                    state.isGameFinished = true;
                    deselectWord();

                    stopTimer(); // Dừng hẳn timer
                    clueText.textContent = "XUẤT SẮC! BẠN ĐÃ CHIẾN THẮNG!";
                    keyboardWrapper.classList.remove("visible");

                    // Logic cập nhật điểm cao
                    const puzzles = getPuzzles();
                    const currentPuzzle = puzzles[state.currentPuzzleId];
                    if (currentPuzzle) {
                        const oldHighScore = currentPuzzle.highScore || 0;
                        if (state.totalScore > oldHighScore) {
                            currentPuzzle.highScore = state.totalScore;
                            savePuzzles(puzzles);
                            showToast(`ĐIỂM CAO MỚI: ${state.totalScore}!`, "success", 4000);
                        }
                    }

                    // Đánh dấu game đã hoàn thành và xóa save game cũ
                    const finalGameState = {
                        isComplete: true,
                        totalScore: state.totalScore,
                        // bạn có thể lưu thêm thông tin khác nếu muốn
                    };
                    localStorage.setItem(`slam-gamestate-${state.currentPuzzleId}`, JSON.stringify(finalGameState));

                    // Animation
                    const allPlayableCells = Array.from(gridContainer.querySelectorAll(".playable"));
                    allPlayableCells.forEach((cell) => {
                        cell.dataset.letter = cell.querySelector(".cell-front").textContent;
                        cell.querySelector(".cell-front").textContent = "";
                    });

                    const flickerInterval = setInterval(() => {
                        allPlayableCells.forEach((cell) => {
                            cell.querySelector(".cell-front").textContent = "";
                        });
                        const cellsToShow = allPlayableCells.sort(() => 0.5 - Math.random()).slice(0, 5);
                        cellsToShow.forEach((cell) => {
                            cell.querySelector(".cell-front").textContent = cell.dataset.letter;
                        });
                    }, 150);

                    setTimeout(() => {
                        clearInterval(flickerInterval);
                        allPlayableCells.forEach((cell) => {
                            cell.querySelector(".cell-front").textContent = cell.dataset.letter;
                        });
                    }, 2000);
                };

                const handleIncorrectGuess = async (wordData) => {
                    // ★ LOGIC MỚI: Dọn dẹp dấu thanh trên các ô đã giải (ô màu trắng)
                    if (state.vietnameseKeyboardEnabled) {
                        revertTonesOnSolvedCells(wordData);
                    }

                    const lockedWordId = state.selectedWordId;
                    state.selectedWordId = null;
                    state.currentInputCell = null;
                    stopWordTimer();
                    // --- LOGIC TÍNH ĐIỂM (GIỮ NGUYÊN) ---
                    let penalty = 0;
                    if (wordData) {
                        penalty = Math.ceil(wordData.word.length / 2);
                    } else {
                        penalty = 2;
                    }
                    updateScore(-penalty);
                    showToast(`Không chính xác! Trừ ${penalty} điểm`, "error", 1500);

                    if (wordData) {
                        const playableCells = [];
                        for (let i = 0; i < wordData.word.length; i++) {
                            let r = wordData.row,
                                c = wordData.col;
                            if (wordData.direction === "horizontal") c += i;
                            else r += i;
                            const playable = gridContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                            if (playable) playableCells.push(playable);
                        }

                        // ★ FIX BUG: Xóa sạch nội dung text ngay lập tức để tránh ký tự vừa gõ bị sót lại
                        playableCells.forEach((cell) => {
                            if (!cell.classList.contains("is-solved")) {
                                // Xóa chữ ngay lập tức, bất chấp animation gõ đang chạy
                                cell.querySelector(".cell-front").textContent = "";
                                cell.classList.remove("anim-typing"); // Xóa class gõ
                            }
                        });

                        // Animation khóa ô (Domino)
                        const dominoDelay = 50;
                        playableCells.forEach((p, i) => {
                            if (!p.classList.contains("is-solved")) {
                                setTimeout(() => {
                                    p.classList.add("anim-incorrect"); // Rung lắc
                                    p.classList.add("is-locked"); // Đổi màu xám
                                }, i * dominoDelay);
                            }
                        });
                        const totalAnimationTime = (playableCells.length - 1) * dominoDelay + 400;
                        await delay(totalAnimationTime);
                    }

                    // Reset trạng thái
                    state.gamePhase = "reveal";
                    state.playableWordIds.clear();
                    document.querySelectorAll(".word-number-label.visible").forEach((l) => hideNumberLabel(l));
                    deselectWord(); // Đảm bảo UI bàn phím đóng lại
                    saveGameState();
                    performAutoReveal();
                };

                const handleWordTimeout = () => {
                    if (state.isCheckingAnswer) return; // Nếu đang check rồi thì thôi
                    state.isCheckingAnswer = true;

                    const wordData = state.words.find((w) => w.id === state.selectedWordId);
                    showToast("Hết giờ!", "error");

                    handleIncorrectGuess(wordData).then(() => {
                        state.isCheckingAnswer = false;
                    });
                };
                // --- TÌM VÀ THAY THẾ TOÀN BỘ HÀM checkSelectedWord ---
                const checkSelectedWord = async () => {
                    keyboardWrapper.classList.remove("visible");
                    // 1. CHỐNG SPAM: Nếu đang kiểm tra rồi thì dừng lại ngay
                    if (state.isCheckingAnswer) return;

                    // 2. Khóa chức năng kiểm tra
                    state.isCheckingAnswer = true;

                    try {
                        const timeLeft = state.wordTimeLeft;
                        stopWordTimer();
                        const wordData = state.words.find((w) => w.id === state.selectedWordId);
                        if (!wordData) {
                            state.isCheckingAnswer = false; // Mở khóa nếu lỗi
                            return;
                        }

                        let userInput = "";
                        for (let i = 0; i < wordData.word.length; i++) {
                            let r = wordData.row,
                                c = wordData.col;
                            if (wordData.direction === "horizontal") c += i;
                            else r += i;
                            const playable = gridContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                            if (playable) {
                                userInput += playable.querySelector(".cell-front").textContent.trim().toUpperCase();
                            }
                        }

                        if (userInput === wordData.word) {
                            document
                                .querySelectorAll(".editable-vowel")
                                .forEach((el) => el.classList.remove("editable-vowel"));

                            const allSolvedInTurn = new Set([wordData.id]);

                            // Kiểm tra các từ giao nhau
                            for (let i = 0; i < wordData.word.length; i++) {
                                let r = wordData.row,
                                    c = wordData.col;
                                if (wordData.direction === "horizontal") c += i;
                                else r += i;

                                const cell = gridContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                                const wordIdsInCell = Object.keys(cell.dataset)
                                    .filter((k) => k.startsWith("word_"))
                                    .map((k) => parseInt(k.replace("word_", "")));

                                for (const otherId of wordIdsInCell) {
                                    if (otherId !== wordData.id && !state.solvedWords.has(otherId)) {
                                        const otherWordData = state.words.find((w) => w.id === otherId);
                                        if (otherWordData) {
                                            let otherWordFromGrid = "";
                                            let isComplete = true;
                                            for (let j = 0; j < otherWordData.word.length; j++) {
                                                let r2 = otherWordData.row,
                                                    c2 = otherWordData.col;
                                                if (otherWordData.direction === "horizontal") c2 += j;
                                                else r2 += j;
                                                const otherCell = gridContainer.querySelector(
                                                    `[data-row="${r2}"][data-col="${c2}"]`
                                                );
                                                const text = otherCell
                                                    ?.querySelector(".cell-front")
                                                    .textContent.trim()
                                                    .toUpperCase();
                                                if (!text) {
                                                    isComplete = false;
                                                    break;
                                                }
                                                otherWordFromGrid += text;
                                            }
                                            if (isComplete && otherWordFromGrid === otherWordData.word) {
                                                allSolvedInTurn.add(otherId);
                                            }
                                        }
                                    }
                                }
                            }

                            // Tính điểm
                            let turnScore = 0;
                            allSolvedInTurn.forEach((id) => {
                                const w = state.words.find((word) => word.id === id);
                                if (w) {
                                    turnScore += w.word.length;
                                    for (let i = 0; i < w.word.length; i++) {
                                        let r = w.row,
                                            c = w.col;
                                        if (w.direction === "horizontal") c += i;
                                        else r += i;
                                        const cell = gridContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                                        if (cell) {
                                            cell.classList.add("selected-word");
                                        }
                                    }
                                }
                            });
                            updateScore(turnScore);
                            showToast(`+${turnScore} điểm! Giải được ${allSolvedInTurn.size} từ!`, "success", 2000);

                            // Chạy hiệu ứng
                            await Promise.all(Array.from(allSolvedInTurn).map((id) => animateWordSolved(id)));

                            allSolvedInTurn.forEach((id) => state.solvedWords.add(id));
                            updateStats();

                            if (state.solvedWords.size === state.words.length) {
                                triggerWinAnimation();
                            } else {
                                state.gamePhase = "reveal";
                                state.playableWordIds.clear();
                                deselectWord();
                                performAutoReveal();
                            }
                            saveGameState();
                        } else {
                            // Nếu sai, chờ chạy xong hiệu ứng rung lắc rồi mới mở khóa
                            await handleIncorrectGuess(wordData);
                        }
                    } catch (e) {
                        console.error(e);
                    } finally {
                        // 3. Mở khóa sau khi hoàn tất mọi thứ (dù đúng hay sai)
                        state.isCheckingAnswer = false;
                    }
                };
                const hideNumberLabel = (label) => {
                    if (!label) return;
                    const wordData = state.words.find((w) => w.id == label.dataset.wordId);
                    if (wordData) {
                        label.classList.add(wordData.direction === "horizontal" ? "hiding-right" : "hiding-down");
                        label.addEventListener(
                            "animationend",
                            () => {
                                label.classList.remove("visible", "hiding-right", "hiding-down");
                            },
                            {
                                once: true,
                            }
                        );
                    } else {
                        label.classList.remove("visible");
                    }
                };

                // --- TÌM VÀ THAY THẾ HÀM deselectWord ---
                const deselectWord = () => {
                    // ★ LOGIC MỚI: Trước khi bỏ chọn, hãy dọn dẹp dấu thanh trên các ô đã giải
                    if (state.selectedWordId !== null && state.vietnameseKeyboardEnabled) {
                        const wordData = state.words.find((w) => w.id === state.selectedWordId);
                        revertTonesOnSolvedCells(wordData);
                    }

                    updateKeyboardState();
                    repositionNumberLabels();
                    gridContainer.classList.remove("word-zoomed");
                    gridContainer.style.transform = "";
                    gridContainer.style.transformOrigin = "";
                    stopWordTimer();
                    state.selectedWordId = null;
                    state.currentInputCell = null;
                    document.getElementById("grid-wrapper").classList.remove("selection-active");
                    document
                        .querySelectorAll(".playable.selected-word")
                        .forEach((el) => el.classList.remove("selected-word"));

                    const shouldShowNumbers =
                        !state.isGameFinished &&
                        ((state.gamePhase === "playing" && state.playableWordIds.size > 0) || state.slamModeActive);
                    document.querySelectorAll(".word-number-label").forEach((label) => {
                        const wordId = parseInt(label.dataset.wordId);
                        const isPlayable = state.playableWordIds.has(wordId);

                        if (shouldShowNumbers && isPlayable) {
                            label.classList.remove("hiding-right", "hiding-down");
                            label.classList.add("visible");
                        } else {
                            if (label.classList.contains("visible")) {
                                hideNumberLabel(label);
                            }
                        }
                    });

                    keyboardWrapper.classList.remove("visible");
                    if (state.gamePhase === "playing") {
                        if (state.playableWordIds.size > 0 && !state.slamModeActive) {
                            clueText.textContent = "Chọn một từ được đánh số để giải!";
                        }
                    } else if (state.gamePhase === "reveal") {
                        clueText.textContent = "Chuẩn bị lượt tiếp theo...";
                    }
                };
                // --- THAY THẾ HÀM handleCellClick ---
                const handleCellClick = (clickedCell) => {
                    // 1. Nếu bấm ra ngoài ô đang sửa dấu -> Thoát chế độ sửa
                    if (state.editingSpecificCell && state.editingSpecificCell !== clickedCell) {
                        exitVowelEditMode();
                    }

                    // 2. Logic mới: Bấm vào ô đã giải nhưng là nguyên âm (editable-vowel)
                    if (clickedCell.classList.contains("editable-vowel")) {
                        // Chỉ cho phép nếu ô này thuộc từ đang chọn (để tránh xung đột logic chọn từ)
                        if (clickedCell.classList.contains("selected-word")) {
                            if (state.editingSpecificCell === clickedCell) {
                                // Bấm lại lần nữa -> Thoát
                                exitVowelEditMode();
                            } else {
                                // Chưa sửa -> Vào chế độ sửa
                                enterVowelEditMode(clickedCell);
                            }
                            return; // Dừng, không chạy logic chọn từ bên dưới
                        }
                    }

                    // 3. Logic cũ (Chọn từ)
                    if (state.selectedWordId !== null) {
                        const wordIds = Object.keys(clickedCell.dataset)
                            .filter((k) => k.startsWith("word_"))
                            .map((k) => parseInt(k.replace("word_", "")));

                        // Nếu click vào ô thường (chưa giải) trong từ đang chọn -> Di chuyển con trỏ
                        if (wordIds.includes(state.selectedWordId) && !clickedCell.classList.contains("is-solved")) {
                            state.currentInputCell = clickedCell;
                        }
                        return;
                    }

                    // (Phần còn lại giữ nguyên như cũ...)
                    if (state.gamePhase !== "playing" || state.playableWordIds.size === 0) return;
                    const wordIds = Object.keys(clickedCell.dataset)
                        .filter((k) => k.startsWith("word_"))
                        .map((k) => parseInt(k.replace("word_", "")));
                    if (wordIds.length === 0) return;
                    const selectableUnsolvedIds = wordIds.filter(
                        (id) => !state.solvedWords.has(id) && state.playableWordIds.has(id)
                    );
                    if (selectableUnsolvedIds.length === 0) {
                        showToast("Chỉ có thể chọn các từ được đánh số.", "error", 2000);
                        return;
                    }
                    const targetId = selectableUnsolvedIds[0];
                    if (state.solvedWords.has(targetId)) return;
                    state.selectedWordId = targetId;
                    updateSelectionAndFocus();
                };
                // --- CÁC HÀM MỚI ---

                const enterVowelEditMode = (cell) => {
                    // Nếu đang sửa ô khác thì thoát ô đó trước
                    if (state.editingSpecificCell && state.editingSpecificCell !== cell) {
                        exitVowelEditMode();
                    }

                    state.editingSpecificCell = cell;
                    cell.classList.add("specific-editing");

                    // Cập nhật gợi ý
                    clueText.textContent = "Chỉnh sửa dấu cho ký tự này...";

                    // Cập nhật bàn phím (chỉ hiện các phím liên quan)
                    updateKeyboardState();
                    updateEnterButtonState(); // Đổi nút Enter thành Gửi/Hủy
                };

                const exitVowelEditMode = () => {
                    if (!state.editingSpecificCell) return;

                    state.editingSpecificCell.classList.remove("specific-editing");
                    state.editingSpecificCell = null;

                    // Khôi phục gợi ý cũ
                    if (state.selectedWordId !== null) {
                        const wordData = state.words.find((w) => w.id === state.selectedWordId);
                        if (wordData) clueText.textContent = `${wordData.id + 1}. ${wordData.clue}`;
                    }

                    // Khôi phục bàn phím đầy đủ
                    updateKeyboardState();
                    updateEnterButtonState();
                };
                // --- THAY THẾ TOÀN BỘ HÀM updateSelectionAndFocus BẰNG BẢN NÀY ---
                const updateSelectionAndFocus = () => {
                    // 1. Dọn dẹp cũ
                    document
                        .querySelectorAll(".playable.selected-word")
                        .forEach((el) => el.classList.remove("selected-word"));
                    document.querySelectorAll(".editable-vowel").forEach((el) => el.classList.remove("editable-vowel")); // Xóa class này
                    document.getElementById("grid-wrapper").classList.remove("selection-active");
                    document.querySelectorAll(".word-number-label.visible").forEach((l) => hideNumberLabel(l));

                    // Thoát chế độ sửa dấu nếu đang bật
                    if (state.editingSpecificCell) exitVowelEditMode();

                    const wordData = state.words.find((w) => w.id === state.selectedWordId);
                    if (!wordData) {
                        deselectWord();
                        return;
                    }

                    document.getElementById("grid-wrapper").classList.add("selection-active");
                    if (!state.slamModeActive) clueText.textContent = `${wordData.id + 1}. ${wordData.clue}`;

                    let firstEmptyCell = null;
                    const firstCell = gridContainer.querySelector(
                        `[data-row="${wordData.row}"][data-col="${wordData.col}"]`
                    );
                    let lastCell = null;

                    // Danh sách nguyên âm cơ bản để kiểm tra
                    const vowelsBase = ["A", "E", "I", "O", "U", "Y", "Ă", "Â", "Ê", "Ô", "Ơ", "Ư"];

                    for (let i = 0; i < wordData.word.length; i++) {
                        let r = wordData.row,
                            c = wordData.col;
                        if (wordData.direction === "horizontal") c += i;
                        else r += i;

                        const playable = gridContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        if (playable) {
                            playable.classList.add("selected-word");
                            playable.classList.remove("is-locked");

                            const cellText = playable.querySelector(".cell-front").textContent.trim();
                            const isSolved = playable.classList.contains("is-solved");

                            // ★ LOGIC MỚI: Nếu ô đã giải VÀ là nguyên âm VÀ đang bật chế độ Tiếng Việt
                            // -> Thêm class editable-vowel để người dùng biết có thể bấm vào
                            if (isSolved && state.vietnameseKeyboardEnabled) {
                                // Lấy chữ cái gốc (không dấu) để check xem có phải nguyên âm không
                                const baseChar = removeVietnameseTones(cellText || "");
                                if (vowelsBase.includes(baseChar)) {
                                    playable.classList.add("editable-vowel");
                                }
                            }

                            if (!firstEmptyCell && cellText === "" && !isSolved) {
                                firstEmptyCell = playable;
                            }
                            if (i === wordData.word.length - 1) lastCell = playable;
                        }
                    }

                    // Zoom effect
                    if (firstCell && lastCell) {
                        const centerX = (firstCell.offsetLeft + lastCell.offsetLeft + lastCell.offsetWidth) / 2;
                        const centerY = (firstCell.offsetTop + lastCell.offsetTop + lastCell.offsetHeight) / 2;
                        gridContainer.style.transformOrigin = `${centerX}px ${centerY}px`;
                        gridContainer.classList.add("word-zoomed");
                    }

                    state.currentInputCell =
                        firstEmptyCell ||
                        gridContainer.querySelector(`[data-row="${wordData.row}"][data-col="${wordData.col}"]`);
                    keyboardWrapper.classList.add("visible");
                    startWordTimer();
                    updateEnterButtonState();
                };
                // --- TÌM VÀ THAY THẾ HÀM updateKeyboardState ---
                const updateKeyboardState = () => {
                    let allowedChars = null;
                    let toneBase = null; // Ký tự dùng để tính dấu (Ă, Â, E, Ê...)

                    if (state.editingSpecificCell && state.vietnameseKeyboardEnabled) {
                        const cellText = state.editingSpecificCell.querySelector(".cell-front").textContent.trim();

                        // 1. Xác định ASCII Base (để biết lọc phím chữ cái nào: A, Ă, Â)
                        const asciiBase = removeVietnameseTones(cellText);

                        // 2. Xác định Tone Base (để hiển thị dấu cho đúng: Ă -> Ắ)
                        // Chúng ta cần tìm xem ký tự hiện tại thuộc "họ" nào
                        const vowelFamilies = [
                            ["A", "Á", "À", "Ả", "Ã", "Ạ"],
                            ["Ă", "Ắ", "Ằ", "Ẳ", "Ẵ", "Ặ"],
                            ["Â", "Ấ", "Ầ", "Ẩ", "Ẫ", "Ậ"],
                            ["E", "É", "È", "Ẻ", "Ẽ", "Ẹ"],
                            ["Ê", "Ế", "Ề", "Ể", "Ễ", "Ệ"],
                            ["I", "Í", "Ì", "Ỉ", "Ĩ", "Ị"],
                            ["O", "Ó", "Ò", "Ỏ", "Õ", "Ọ"],
                            ["Ô", "Ố", "Ồ", "Ổ", "Ỗ", "Ộ"],
                            ["Ơ", "Ớ", "Ờ", "Ở", "Ỡ", "Ợ"],
                            ["U", "Ú", "Ù", "Ủ", "Ũ", "Ụ"],
                            ["Ư", "Ứ", "Ừ", "Ử", "Ữ", "Ự"],
                            ["Y", "Ý", "Ỳ", "Ỷ", "Ỹ", "Ỵ"],
                            ["D", "Đ"],
                        ];

                        // Mặc định toneBase là chính nó
                        toneBase = cellText;

                        // Tìm xem nó thuộc họ nào thì lấy gốc của họ đó (index 0)
                        for (const family of vowelFamilies) {
                            if (family.includes(cellText)) {
                                toneBase = family[0]; // VD: Nếu là 'Ắ' thì toneBase là 'Ă'
                                break;
                            }
                        }

                        // Logic lọc phím chữ cái (giữ nguyên logic cũ dựa trên asciiBase)
                        const variantMap = {
                            A: ["A", "Ă", "Â"],
                            E: ["E", "Ê"],
                            O: ["O", "Ô", "Ơ"],
                            U: ["U", "Ư"],
                            D: ["D", "Đ"],
                            I: ["I"],
                            Y: ["Y"],
                        };

                        allowedChars = new Set(["TONE_ACUTE", "TONE_GRAVE", "TONE_HOOK", "TONE_TILDE", "TONE_DOT"]);

                        if (variantMap[asciiBase]) {
                            variantMap[asciiBase].forEach((c) => allowedChars.add(c));
                        } else {
                            allowedChars.add(asciiBase);
                        }
                    }

                    virtualKeyboard.querySelectorAll(".key").forEach((keyEl) => {
                        const keyRaw = keyEl.dataset.key;
                        const keyUpper = keyRaw.toUpperCase();

                        // ★ SỬA LOGIC HIỂN THỊ DẤU: Dùng toneBase thay vì baseChar cũ
                        if (keyRaw.startsWith("TONE_")) {
                            if (toneBase) {
                                const toneType = keyRaw.replace("TONE_", "");
                                // Tính toán: Ă + Sắc = Ắ
                                const previewChar = addToneToChar(toneBase, toneType);
                                keyEl.textContent = previewChar;
                                keyEl.style.color = "var(--primary-accent)";
                                keyEl.style.fontWeight = "900";
                            } else {
                                keyEl.textContent = keyEl.dataset.defaultLabel || "";
                                keyEl.style.color = "white";
                                keyEl.style.fontWeight = "normal";
                            }
                        }

                        if (keyRaw === "Enter" || keyRaw === "Backspace") return;

                        let isDisabled = false;
                        if (state.editingSpecificCell) {
                            if (allowedChars && !allowedChars.has(keyRaw)) isDisabled = true;
                        } else {
                            isDisabled = state.disabledLetters.has(keyUpper) || state.revealedLetters.has(keyUpper);
                        }

                        keyEl.disabled = isDisabled;
                        keyEl.style.opacity = isDisabled ? "0.3" : "1";
                    });
                };

                const createVirtualKeyboard = () => {
                    let keysLayout;

                    if (state.vietnameseKeyboardEnabled) {
                        // Layout Tiếng Việt
                        keysLayout = [
                            ["TONE_ACUTE", "TONE_GRAVE", "TONE_HOOK", "TONE_TILDE", "TONE_DOT", "Ă", "Ơ", "Ư"],
                            ["Q", "E", "Ê", "R", "T", "Y", "U", "I", "O", "Ô", "P"],
                            ["A", "Â", "S", "D", "Đ", "G", "H", "K", "L"],
                            ["Backspace", "X", "C", "V", "B", "N", "M", "Enter"],
                        ];
                    } else {
                        // Layout Tiếng Anh
                        keysLayout = [
                            ["Q", "W", "E", "R", "T", "Y", "U", "I", "O", "P"],
                            ["A", "S", "D", "F", "G", "H", "J", "K", "L"],
                            ["Backspace", "Z", "X", "C", "V", "B", "N", "M", "Enter"],
                        ];
                    }

                    virtualKeyboard.innerHTML = keysLayout
                        .map(
                            (row) =>
                                `<div class="keyboard-row">${row
                                    .map((key) => {
                                        let c = "key";
                                        let label = key;

                                        // Xác định nhãn hiển thị cho phím dấu
                                        if (key === "TONE_ACUTE") label = "´";
                                        else if (key === "TONE_GRAVE") label = "\`";
                                        else if (key === "TONE_HOOK") label = "?";
                                        else if (key === "TONE_TILDE") label = "~";
                                        else if (key === "TONE_DOT") label = ".";

                                        if (key.startsWith("TONE_")) c += " tone-key";
                                        if (key.length > 1 && !key.startsWith("TONE_")) c += " special";
                                        if (key === "Enter") c += " enter";

                                        // ★ LƯU Ý: Thêm data-default-label để dùng cho việc reset sau này
                                        return `<button class="${c}" data-key="${key}" data-default-label="${label}">
                                ${key === "Backspace" ? "XÓA" : key === "Enter" ? "ENTER" : label}
                            </button>`;
                                    })
                                    .join("")}</div>`
                        )
                        .join("");
                };
                // --- CẬP NHẬT: ĐỔI TEXT NÚT ENTER THÀNH GỬI KHI Ở CHẾ ĐỘ CHALLENGE ---
                const updateEnterButtonState = () => {
                    const enterBtn = virtualKeyboard.querySelector('.key[data-key="Enter"]');
                    if (!enterBtn) return;

                    // 1. Challenge Mode
                    if (state.challengeModeActive) {
                        enterBtn.textContent = "OK";
                        enterBtn.classList.remove("action-cancel");
                        return;
                    }

                    // 2. ★ LOGIC MỚI: Specific Edit Mode
                    if (state.editingSpecificCell) {
                        enterBtn.textContent = "XONG"; // Hoặc "GỬI"
                        enterBtn.classList.remove("action-cancel");
                        // Style xanh lá để báo hiệu xác nhận
                        enterBtn.style.background = "var(--success-color)";
                        return;
                    }

                    // 3. Normal Mode (Reset style)
                    enterBtn.style.background = "";

                    // 2. Các logic cũ cho chế độ chơi thường
                    if (state.selectedWordId === null) {
                        enterBtn.textContent = "ENTER";
                        enterBtn.classList.remove("action-cancel");
                        return;
                    }

                    const wordData = state.words.find((w) => w.id === state.selectedWordId);
                    if (!wordData) return;

                    let isFull = true;
                    for (let i = 0; i < wordData.word.length; i++) {
                        let r = wordData.row,
                            c = wordData.col;
                        if (wordData.direction === "horizontal") c += i;
                        else r += i;

                        const cell = gridContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        const text = cell ? cell.querySelector(".cell-front").textContent.trim() : "";
                        if (!text) {
                            isFull = false;
                            break;
                        }
                    }

                    enterBtn.style.background = "";
                    enterBtn.style.color = "";
                    enterBtn.style.boxShadow = "";

                    if (isFull) {
                        enterBtn.textContent = "ENTER";
                        enterBtn.classList.remove("action-cancel");
                    } else {
                        enterBtn.textContent = "HỦY";
                        enterBtn.classList.add("action-cancel");
                    }
                };
                const revealLetterOnGrid = async (letter) => {
                    state.revealedLetters.add(letter.toUpperCase());
                    state.playableWordIds.clear();

                    let lettersToDeduct = 0; // Biến đếm số lượng ký tự MỚI được hiện ra

                    state.words.forEach((wordData) => {
                        let containsLetter = false;
                        for (let i = 0; i < wordData.word.length; i++) {
                            if (wordData.word[i] === letter) {
                                containsLetter = true;
                                let r = wordData.row,
                                    c = wordData.col;
                                if (wordData.direction === "horizontal") c += i;
                                else r += i;
                                const playable = gridContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);

                                // Tìm đoạn: if (playable && !playable.classList.contains("is-solved")) { ... }

                                // --- THAY THẾ BẰNG ---
                                if (playable && !playable.classList.contains("is-solved")) {
                                    const currentContent = playable.querySelector(".cell-front").textContent.trim();
                                    if (!currentContent) {
                                        lettersToDeduct++;
                                    }

                                    let charToShow = letter;
                                    // ★ LOGIC MỚI: Nếu bật tiếng Việt -> Hiển thị không dấu
                                    if (state.vietnameseKeyboardEnabled) {
                                        charToShow = removeVietnameseTones(letter);
                                    }

                                    playable.querySelector(".cell-front").innerHTML =
                                        `<span class="letter-pop-in">${charToShow}</span>`;
                                    playable.classList.remove("is-locked", "anim-incorrect");
                                    playable.classList.add("is-solved");

                                    // Lưu chữ gốc vào dataset để máy biết mà kiểm tra đúng sai ngầm
                                    playable.dataset.realChar = letter;
                                }
                            }
                        }

                        if (containsLetter && !state.solvedWords.has(wordData.id)) {
                            state.playableWordIds.add(wordData.id);
                        }
                    });

                    // --- LOGIC TRỪ ĐIỂM ---
                    if (lettersToDeduct > 0) {
                        updateScore(-lettersToDeduct); // Trừ số điểm tương ứng
                        // Có thể hiện toast thông báo hoặc không, tùy ý
                        // showToast(`Trừ ${lettersToDeduct} điểm (gợi ý)`, "info", 1000);
                    }

                    const newlyCompletedWords = [];
                    state.playableWordIds.forEach((wordId) => {
                        if (state.solvedWords.has(wordId)) return;
                        const wordData = state.words.find((w) => w.id === wordId);
                        if (!wordData) return;

                        let currentGridWord = "";
                        let isCompleteOnGrid = true;
                        for (let i = 0; i < wordData.word.length; i++) {
                            let r = wordData.row,
                                c = wordData.col;
                            if (wordData.direction === "horizontal") c += i;
                            else r += i;
                            const cell = gridContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                            const cellText = cell
                                ? cell.querySelector(".cell-front").textContent.trim().toUpperCase()
                                : "";
                            if (cellText === "") {
                                isCompleteOnGrid = false;
                                break;
                            }
                            currentGridWord += cellText;
                        }

                        if (isCompleteOnGrid && currentGridWord === wordData.word) {
                            newlyCompletedWords.push(wordId);
                        }
                    });

                    if (newlyCompletedWords.length > 0) {
                        await Promise.all(newlyCompletedWords.map((id) => animateWordSolved(id)));
                        newlyCompletedWords.forEach((wordId) => {
                            state.solvedWords.add(wordId);
                            state.playableWordIds.delete(wordId);
                        });
                        showToast(`Đã tự động hoàn thành ${newlyCompletedWords.length} từ!`, "success");
                        updateStats();
                        saveGameState();

                        if (state.solvedWords.size === state.words.length) {
                            triggerWinAnimation();
                            return;
                        } else {
                            setTimeout(() => {
                                performAutoReveal();
                            }, 500);
                            return;
                        }
                    }

                    state.gamePhase = "playing";
                    state.turnCount++; // Tăng số lượt
                    document.getElementById("turn-display").textContent = `Lượt ${state.turnCount}`; // Cập nhật UI
                    deselectWord();
                    saveGameState();
                };

                const handleWordInput = (key) => {
                    if (state.selectedWordId === null || !state.currentInputCell) return;

                    // ★ FIX BUG RACE CONDITION 2: Chặn nhập nếu ô hiện tại đang bị khóa (do hết giờ/trả lời sai)
                    if (state.currentInputCell.classList.contains("is-locked")) return;

                    const wordData = state.words.find((w) => w.id === state.selectedWordId);
                    if (!wordData) return;

                    // --- LOGIC XỬ LÝ NÚT XÓA (BACKSPACE) ---
                    if (key === "Backspace") {
                        const currentCellPlayable = state.currentInputCell;
                        const currentCellFront = currentCellPlayable.querySelector(".cell-front");

                        // Hàm trợ giúp để chạy animation xóa
                        const animateDelete = (cell, frontElement) => {
                            cell.classList.remove("anim-typing"); // Xóa class gõ nếu có
                            cell.classList.add("anim-delete"); // Thêm class xóa

                            // Đợi animation chạy xong (150ms) rồi mới xóa chữ
                            setTimeout(() => {
                                frontElement.textContent = "";
                                cell.classList.remove("anim-delete");
                            }, 150);
                        };

                        // TRƯỜNG HỢP 1: Xóa ký tự trong ô hiện tại nếu nó có chữ
                        if (
                            !currentCellPlayable.classList.contains("is-solved") &&
                            currentCellFront.textContent.trim() !== ""
                        ) {
                            animateDelete(currentCellPlayable, currentCellFront);
                            return;
                        }

                        // TRƯỜNG HỢP 2: Nếu ô hiện tại trống, di chuyển lùi lại ô trước đó và xóa
                        let targetCellToDelete = null;
                        let cellToTest = currentCellPlayable;

                        // Tìm ô hợp lệ trước đó
                        for (let i = 0; i < wordData.word.length; i++) {
                            const { row, col } = cellToTest.dataset;
                            const prevRow = parseInt(row) - (wordData.direction === "vertical" ? 1 : 0);
                            const prevCol = parseInt(col) - (wordData.direction === "horizontal" ? 1 : 0);
                            const prevCell = gridContainer.querySelector(
                                `[data-row="${prevRow}"][data-col="${prevCol}"]`
                            );

                            if (prevCell && prevCell.classList.contains("selected-word")) {
                                cellToTest = prevCell;
                                // Chỉ xóa nếu ô đó chưa được giải (không phải ô màu trắng)
                                if (!cellToTest.classList.contains("is-solved")) {
                                    targetCellToDelete = cellToTest;
                                    break;
                                }
                            } else {
                                break; // Hết phạm vi từ
                            }
                        }

                        if (targetCellToDelete) {
                            state.currentInputCell = targetCellToDelete;
                            const targetFront = state.currentInputCell.querySelector(".cell-front");
                            animateDelete(state.currentInputCell, targetFront);
                        }
                        setTimeout(() => updateEnterButtonState(), 160); // Đợi animation xóa xong chút rồi cập nhật
                        return;
                    }
                    // --- LOGIC XỬ LÝ NHẬP CHỮ ---
                    let cellToWriteIn = state.currentInputCell;

                    // Nếu ô hiện tại đã được giải (do tiết lộ), tìm ô trống tiếp theo
                    if (cellToWriteIn.classList.contains("is-solved")) {
                        let nextEmptyCell = null;
                        let tempCell = cellToWriteIn;
                        for (let i = 0; i < wordData.word.length * 2; i++) {
                            // Lặp đủ dài để chắc chắn quét hết từ
                            const { row, col } = tempCell.dataset;
                            const nextRow = parseInt(row) + (wordData.direction === "vertical" ? 1 : 0);
                            const nextCol = parseInt(col) + (wordData.direction === "horizontal" ? 1 : 0);
                            const potentialNext = gridContainer.querySelector(
                                `[data-row="${nextRow}"][data-col="${nextCol}"]`
                            );
                            if (potentialNext && potentialNext.classList.contains("selected-word")) {
                                if (!potentialNext.classList.contains("is-solved")) {
                                    nextEmptyCell = potentialNext;
                                    break;
                                }
                                tempCell = potentialNext;
                            } else {
                                break;
                            }
                        }
                        if (nextEmptyCell) cellToWriteIn = nextEmptyCell;
                    }

                    // Ghi chữ và áp dụng animation
                    if (cellToWriteIn && !cellToWriteIn.classList.contains("is-solved")) {
                        cellToWriteIn.classList.add("anim-typing");
                        cellToWriteIn.querySelector(".cell-front").textContent = key.toUpperCase();

                        // Tự động di chuyển đến ô tiếp theo
                        let nextFocusCell = null;
                        let tempCell = cellToWriteIn;
                        for (let i = 0; i < wordData.word.length; i++) {
                            const { row, col } = tempCell.dataset;
                            const nextRow = parseInt(row) + (wordData.direction === "vertical" ? 1 : 0);
                            const nextCol = parseInt(col) + (wordData.direction === "horizontal" ? 1 : 0);
                            const potentialNext = gridContainer.querySelector(
                                `[data-row="${nextRow}"][data-col="${nextCol}"]`
                            );
                            if (potentialNext && potentialNext.classList.contains("selected-word")) {
                                nextFocusCell = potentialNext; // Di chuyển dù ô tiếp theo đã được giải
                                break;
                            } else {
                                break;
                            }
                        }
                        state.currentInputCell = nextFocusCell || cellToWriteIn;
                        updateEnterButtonState();
                    }
                };
                saveGameState();
                const handleKeyPress = (key) => {
                    // 1. Logic Challenge (Giữ nguyên)
                    if (state.challengeModeActive) {
                        if (key === "Backspace") challengeInput.value = "";
                        else if (key === "Enter") submitChallengeAnswer();
                        else if (key.length === 1 && /^[a-zA-Z]$/.test(key)) challengeInput.value = key.toUpperCase();
                        return;
                    }
                    if (state.editingSpecificCell) {
                        const cellFront = state.editingSpecificCell.querySelector(".cell-front");
                        const currentText = cellFront.textContent.trim();

                        if (key === "Enter") {
                            exitVowelEditMode(); // Bấm Enter/Gửi để thoát
                        } else if (key === "Backspace") {
                            // Nút xóa: Đưa về dạng không dấu ban đầu
                            cellFront.textContent = removeVietnameseTones(currentText);
                        } else if (key.startsWith("TONE_")) {
                            // Nhập dấu: Gọi hàm xử lý dấu (reuse hàm cũ nhưng trỏ vào ô đang sửa)
                            const toneType = key.replace("TONE_", "");
                            const newChar = addToneToChar(currentText, toneType);
                            if (newChar !== currentText) {
                                cellFront.textContent = newChar;
                                // Animation nhẹ
                                cellFront.animate(
                                    [{ transform: "scale(1)" }, { transform: "scale(1.2)" }, { transform: "scale(1)" }],
                                    { duration: 150 }
                                );
                            }
                        } else {
                            // Nhập ký tự (A, Ă, Â...): Thay thế trực tiếp
                            // Chỉ nhận nếu phím đó không bị disable (theo logic updateKeyboardState)
                            const btn = virtualKeyboard.querySelector(`.key[data-key="${key}"]`);
                            if (btn && !btn.disabled) {
                                cellFront.textContent = key;
                                // Animation nhẹ
                                cellFront.animate(
                                    [{ transform: "scale(1)" }, { transform: "scale(1.2)" }, { transform: "scale(1)" }],
                                    { duration: 150 }
                                );
                                updateKeyboardState();
                            }
                        }
                        return; // Kết thúc, không chạy logic bên dưới
                    }
                    // 2. Xử lý nhập liệu Game
                    const targetMode = state.slamModeActive || state.gamePhase === "playing";
                    if (targetMode) {
                        if (key === "Enter") {
                            if (state.selectedWordId !== null) checkSelectedWord();
                        } else if (key.startsWith("TONE_")) {
                            // --- XỬ LÝ DẤU TIẾNG VIỆT ---
                            handleToneInput(key);
                        } else {
                            handleWordInput(key);
                        }
                    }
                };

                // --- TÌM VÀ THAY THẾ TOÀN BỘ HÀM handleToneInput BẰNG CODE NÀY ---
                const handleToneInput = (toneKey) => {
                    const wordId = state.selectedWordId;
                    if (wordId === null) return;

                    const wordData = state.words.find((w) => w.id === wordId);
                    if (!wordData) return;

                    // 1. Xác định vị trí Index hiện tại của con trỏ trong từ (0, 1, 2...)
                    let currentIndex = -1;

                    if (state.currentInputCell) {
                        // Dùng toán học để tính index dựa trên tọa độ
                        const currentR = parseInt(state.currentInputCell.dataset.row);
                        const currentC = parseInt(state.currentInputCell.dataset.col);

                        if (wordData.direction === "horizontal") {
                            currentIndex = currentC - wordData.col;
                        } else {
                            currentIndex = currentR - wordData.row;
                        }
                    } else {
                        // Nếu không có con trỏ (trường hợp đã điền kín từ), giả định đang đứng ở cuối từ
                        currentIndex = wordData.word.length;
                    }

                    // Hàm tiện ích lấy ô tại index cụ thể
                    const getCellAtIndex = (idx) => {
                        if (idx < 0 || idx >= wordData.word.length) return null;
                        let r = wordData.row;
                        let c = wordData.col;
                        if (wordData.direction === "horizontal") c += idx;
                        else r += idx;
                        return gridContainer.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    };

                    const toneType = toneKey.replace("TONE_", "");
                    let targetCell = null;

                    // 2. CHIẾN THUẬT TÌM MỤC TIÊU (ƯU TIÊN)

                    // TRƯỜNG HỢP A: Kiểm tra chính ô đang đứng (nếu con trỏ không bị văng ra ngoài)
                    // Dành cho trường hợp người chơi click trực tiếp vào chữ 'A' để sửa thành 'Á'
                    if (currentIndex < wordData.word.length) {
                        const cell = getCellAtIndex(currentIndex);
                        if (cell && !cell.classList.contains("is-locked") && !cell.classList.contains("is-solved")) {
                            const content = cell.querySelector(".cell-front").textContent.trim();
                            // Thử bỏ dấu xem có thay đổi gì không? (Để biết đây có phải nguyên âm không)
                            if (content && addToneToChar(content, toneType) !== content) {
                                targetCell = cell;
                            }
                        }
                    }

                    // TRƯỜNG HỢP B: Nếu trường hợp A thất bại (ô hiện tại trống, hoặc là phụ âm, hoặc hết từ)
                    // Thì lùi lại 1 ô (Backtrack). Đây là logic cho việc gõ xong tự nhảy nhưng muốn bỏ dấu lại.
                    if (!targetCell) {
                        const prevCell = getCellAtIndex(currentIndex - 1);
                        if (
                            prevCell &&
                            !prevCell.classList.contains("is-locked") &&
                            !prevCell.classList.contains("is-solved")
                        ) {
                            targetCell = prevCell;
                        }
                    }

                    // 3. THỰC HIỆN BỎ DẤU
                    if (targetCell) {
                        const cellFront = targetCell.querySelector(".cell-front");
                        const currentText = cellFront.textContent.trim();

                        if (currentText) {
                            const newChar = addToneToChar(currentText, toneType);
                            if (newChar !== currentText) {
                                cellFront.textContent = newChar;

                                // Animation nảy lên
                                cellFront.animate(
                                    [
                                        { transform: "scale(1)" },
                                        { transform: "scale(1.3)", color: "#ffeb3b" }, // Highlight màu vàng chút
                                        { transform: "scale(1)" },
                                    ],
                                    { duration: 200 }
                                );
                            }
                        }
                    }
                };

                const submitChallengeAnswer = async () => {
                    // 1. CHỐNG SPAM: Nếu đang xử lý rồi thì chặn luôn
                    if (state.isProcessingChallenge) return;

                    const input = challengeInput.value.trim().toUpperCase();
                    if (!input) return; // Không làm gì nếu chưa nhập

                    // Khóa ngay lập tức để không bấm được lần 2
                    state.isProcessingChallenge = true;

                    const target = state.currentChallengeTarget;

                    // Tạm ẩn bàn phím ngay lập tức để cảm giác phản hồi nhanh
                    keyboardWrapper.classList.remove("visible");

                    if (input === target) {
                        // --- TRƯỜNG HỢP ĐÚNG ---
                        challengeInput.style.borderColor = "var(--success-color)";
                        challengeFeedback.textContent = "Chính xác!";
                        challengeFeedback.classList.add("correct");

                        await delay(800);

                        // Dọn dẹp UI
                        state.challengeModeActive = false; // Tắt chế độ
                        revealChallengeContainer.classList.remove("visible");
                        challengeInput.style.borderColor = "";
                        updateEnterButtonState(); // Reset nút về mặc định

                        // Thực hiện mở chữ
                        revealLetterOnGrid(target);
                        showToast(`Mở khóa chữ: ${target}`, "success");
                    } else {
                        // --- TRƯỜNG HỢP SAI (Đã sửa: Không hiện đáp án, Không báo chữ bị cấm) ---
                        challengeInput.style.borderColor = "var(--danger-color)";

                        // Chỉ báo sai chung chung
                        challengeFeedback.textContent = "Sai rồi!";
                        challengeFeedback.classList.add("incorrect");

                        await delay(1500);

                        // Logic xử lý sai
                        state.challengeModeActive = false; // Tắt chế độ
                        state.failedRevealLetters.add(target); // Thêm vào danh sách đen ngầm

                        // Dọn dẹp UI
                        revealChallengeContainer.classList.remove("visible");
                        challengeInput.style.borderColor = "";
                        updateEnterButtonState(); // Reset nút về mặc định

                        // Thông báo ẩn danh
                        showToast("Bạn đã bỏ lỡ cơ hội mở chữ cái này.", "error");

                        // Gọi lại để máy chọn chữ khác (Vì chữ cũ đã bị ban)
                        performAutoReveal();
                    }

                    state.currentChallengeTarget = null;
                    state.isProcessingChallenge = false; // Mở khóa cho lượt sau (dù logic sẽ chuyển sang phase khác)
                };
                slamBtn.addEventListener("click", () => {
                    if (!state.slamModeActive) slamModal.classList.add("visible");
                });
                slamCancelBtn.addEventListener("click", () => slamModal.classList.remove("visible"));
                slamConfirmBtn.addEventListener("click", () => {
                    state.slamModeActive = true;
                    state.gamePhase = "playing";
                    state.playableWordIds.clear();
                    state.words.forEach((w) => {
                        if (!state.solvedWords.has(w.id)) state.playableWordIds.add(w.id);
                    });
                    document.querySelectorAll(".word-number-label").forEach((l) => {
                        const wordId = parseInt(l.dataset.wordId);
                        if (state.playableWordIds.has(wordId) && !state.solvedWords.has(wordId))
                            l.classList.add("visible");
                    });
                    deselectWord();
                    slamModal.classList.remove("visible");
                    clueText.classList.add("hidden");
                    slamBtn.disabled = true;
                    showToast("SLAM MODE ACTIVATED!", "error");
                    saveGameState();
                });

                virtualKeyboard.addEventListener("click", (e) => {
                    if (e.target.matches(".key")) {
                        handleKeyPress(e.target.dataset.key);
                    }
                });
                gridContainer.addEventListener("click", (e) => {
                    const playable = e.target.closest(".playable");
                    if (playable) handleCellClick(playable);
                });
                numberOverlay.addEventListener("click", (e) => {
                    const label = e.target.closest(".word-number-label");
                    if (!label) return;

                    // Lấy ID từ số được bấm
                    const wordId = parseInt(label.dataset.wordId);

                    // Kiểm tra các điều kiện để được chọn (giống logic click ô chữ)
                    // 1. Phải đang ở giai đoạn chơi hoặc SLAM
                    if (state.gamePhase !== "playing" && !state.slamModeActive) return;

                    // 2. Từ này phải nằm trong danh sách được phép chơi
                    if (!state.playableWordIds.has(wordId) && !state.slamModeActive) {
                        showToast("Từ này chưa được mở khóa!", "error");
                        return;
                    }

                    // 3. Từ này chưa được giải
                    if (state.solvedWords.has(wordId)) return;

                    // Thực hiện chọn từ
                    state.selectedWordId = wordId;
                    updateSelectionAndFocus();
                });
                window.addEventListener("resize", () => {
                    if (state.currentPage === "game") {
                        adjustGridSize();
                        repositionNumberLabels();
                    }
                });
                window.addEventListener("beforeunload", () => {
                    if (state.currentPage === "game") saveGameState();
                });

                const initGame = (data) => {
                    let puzzleId, source;

                    // Hỗ trợ cả cách gọi cũ (chỉ string ID) và cách gọi mới (object)
                    if (typeof data === "object" && data !== null) {
                        puzzleId = data.id;
                        source = data.source;
                    } else {
                        puzzleId = data;
                        source = "local";
                    }

                    let puzzle;
                    if (source === "server") {
                        puzzle = state.serverPuzzles[puzzleId];
                    } else {
                        puzzle = getPuzzles()[puzzleId];
                    }

                    if (!puzzle) {
                        showToast("Lỗi: Không tìm thấy bộ đề.", "error");
                        switchView("lobby");
                        return;
                    }

                    state.currentPuzzleId = puzzleId;
                    state.turnCount = 0; // <--- THÊM DÒNG NÀY
                    document.getElementById("turn-display").textContent = `Lượt 1`; // <--- CẬP NHẬT UI
                    state.words = puzzle.arrangedWords || puzzle.words;
                    state.isGameFinished = false;
                    state.solvedWords.clear();
                    state.revealedLetters.clear();
                    state.disabledLetters.clear();
                    state.playableWordIds.clear();
                    state.selectedWordId = null;
                    state.slamModeActive = false;
                    state.gamePhase = "reveal";
                    state.elapsedSeconds = 0;
                    state.totalScore = 0;
                    state.failedRevealLetters = new Set(); // Reset danh sách fail
                    state.manualRevealEnabled = localStorage.getItem("slam-setting-manual-reveal") === "true"; // Load setting
                    state.challengeModeActive = false;
                    state.vietnameseKeyboardEnabled =
                        localStorage.getItem("slam-setting-vietnamese-keyboard") === "true";
                    createVirtualKeyboard(); // Vẽ lại bàn phím ngay khi vào game để khớp với cài đặt
                    // ------------------------
                    // Ẩn UI challenge nếu đang hiện
                    revealChallengeContainer.classList.remove("visible");
                    updateScore(0);
                    createGameGrid();
                    loadGameState(); // Tải trạng thái game trước

                    // Cập nhật giao diện dựa trên trạng thái vừa tải
                    slamBtn.disabled = state.slamModeActive;
                    if (state.slamModeActive) {
                        clueText.classList.add("hidden");
                    } else {
                        clueText.classList.remove("hidden");
                    }
                    updateKeyboardState();
                    deselectWord();
                    updateStats();
                    startTimer();
                    performAutoReveal();
                };

                createVirtualKeyboard();
                switchView("lobby");
            });
        </script>
    </body>
</html>
