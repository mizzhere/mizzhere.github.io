<!doctype html>
<html lang="vi">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
        <title>mizzsub</title>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
            rel="stylesheet"
        />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.2/color-thief.umd.js"></script>
        <style>
    /* ========================================= */
    /* 1. GLOBAL VARIABLES & BASE STYLES         */
    /* ========================================= */
    :root {
        --primary-bg: #141414;
        --secondary-bg: #1e1e1e;
        --text-color: #e5e5e5;
        --accent-color: #e50914;
        --text-light: #fff;
        --dynamic-color: 20, 20, 20; /* Dạng R, G, B để dễ chỉnh độ mờ */
    --dynamic-accent: #e50914;   /* Màu nhấn động */
    }

    body {
        font-family: "Inter", sans-serif;
        margin: 0;
        background-color: var(--primary-bg);
        color: var(--text-color);
        overflow-x: hidden;

        /* Cấm bôi đen & Menu ngữ cảnh mobile */
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
    }

    /* Cấm kéo ảnh/video */
    img, video, iframe {
        pointer-events: none;
        -webkit-user-drag: none;
    }

    /* Cho phép nhập liệu */
    input, textarea {
        -webkit-user-select: text !important;
        user-select: text !important;
        pointer-events: auto !important;
    }

    main {
        padding: 0;
        padding-bottom: 50px;
        box-sizing: border-box;
    }

    .hidden {
        display: none !important;
    }

    /* Skeleton Loading */
    .skeleton-card {
        background-color: #2a2a2a;
        animation: pulse 1.5s infinite ease-in-out;
    }

    @keyframes pulse {
        0% { background-color: #2a2a2a; }
        50% { background-color: #3a3a3a; }
        100% { background-color: #2a2a2a; }
    }

    /* ========================================= */
    /* 2. HEADER & SEARCH BAR                    */
    /* ========================================= */
    #page-header {
        position: sticky;
        top: 0;
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 15px clamp(20px, 4vw, 60px);
        background: linear-gradient(
            to bottom,
            rgba(0, 0, 0, 0.9) 0%,
            rgba(20, 20, 20, 0.8) 60%,
            transparent 100%
        );
        transition: background-color 0.3s;
        pointer-events: auto; /* Đảm bảo click overlay không che input */
    }

    #page-header.scrolled {
        background-color: var(--primary-bg);
        box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
    }

    #main-title {
        font-size: 1.5rem;
        font-weight: 800;
        color: var(--accent-color);
        text-transform: uppercase;
        letter-spacing: 1px;
        margin: 0;
        cursor: pointer;
        text-shadow: 0 0 20px rgba(229, 9, 20, 0.4);
        font-family: "Arial Black", sans-serif;
    }

    #actions-container {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    /* Expandable Search Box */
    #search-box-wrapper {
        display: flex;
        align-items: center;
        background: transparent;
        border: 1px solid transparent;
        padding: 5px;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: visible !important;
    }
    #search-suggestions {
    position: absolute;
    top: 100%; /* Nằm ngay dưới ô input */
    left: 0;
    width: 100%;
    background-color: #1e1e1e;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-top: none;
    border-radius: 0 0 8px 8px;
    z-index: 10000;
    max-height: 400px;
    overflow-y: auto;
    box-shadow: 0 10px 20px rgba(0,0,0,0.5);
    display: none; /* Mặc định ẩn */
}

#search-suggestions.visible {
    display: block;
}

.suggestion-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px;
    cursor: pointer;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    transition: background 0.2s;
}

.suggestion-item:last-child {
    border-bottom: none;
}

.suggestion-item:hover {
    background-color: #333;
}

.suggestion-thumb {
    width: 60px;
    height: 34px;
    object-fit: cover;
    border-radius: 4px;
    background: #000;
}

.suggestion-info {
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.suggestion-title {
    font-size: 0.95rem;
    color: #fff;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.suggestion-type {
    font-size: 0.75rem;
    color: var(--accent-color);
    text-transform: uppercase;
    font-weight: 700;
}
    #search-box-wrapper.active {
        background-color: rgba(0, 0, 0, 0.7);
        border: 1px solid #fff;
        padding: 5px 10px;
        border-radius: 4px;
        z-index: 9999; /* Fix lỗi input ko nhập được */
    }

    #search-trigger-btn {
        background: none;
        border: none;
        cursor: pointer;
        padding: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #fff;
        transition: transform 0.2s;
    }

    #search-trigger-btn:hover {
        transform: scale(1.1);
    }

    #search-input {
        background: none;
        border: none;
        outline: none;
        color: #fff;
        font-size: 0.95rem;
        width: 0;
        padding: 0;
        opacity: 0;
        transition: all 0.3s ease;
        font-weight: 500;
        pointer-events: auto !important; /* Fix lỗi input */
        z-index: 10000;
    }

    #search-box-wrapper.active #search-input {
        width: 250px;
        padding-left: 10px;
        opacity: 1;
    }

    #search-clear-btn {
        background: none;
        border: none;
        color: #999;
        cursor: pointer;
        display: none;
        font-size: 1.2rem;
        padding: 0 5px;
    }

    #search-box-wrapper.active #search-clear-btn.visible {
        display: block;
    }

    #add-video-btn {
        background: transparent;
        border: none;
        width: 40px;
        height: 40px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        fill: #fff;
        opacity: 0.8;
        transition: all 0.2s;
        border-radius: 50%;
    }

    #add-video-btn:hover {
        background-color: rgba(255, 255, 255, 0.1);
        opacity: 1;
        transform: rotate(90deg);
    }

    /* Mobile Search Fix */
    @media (max-width: 768px) {
        #page-header.search-active #main-title,
        #page-header.search-active #actions-container > #add-video-btn {
            display: none;
        }

        #page-header.search-active #search-box-wrapper {
            width: 100%;
            position: absolute;
            left: 15px;
            right: 15px;
            z-index: 100;
            background-color: var(--primary-bg);
        }

        #page-header.search-active #search-box-wrapper.active #search-input {
            width: 100%;
        }
    }
/* --- FIX CSS TÌM KIẾM --- */
#search-box-wrapper {
    display: flex;
    align-items: center;
    background: transparent;
    border: 1px solid transparent;
    padding: 5px;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    border-radius: 4px;
    position: relative; /* Để quản lý z-index */
}

#search-box-wrapper.active {
    background-color: rgba(0, 0, 0, 0.8); /* Đậm hơn chút để che nền */
    border: 1px solid rgba(255, 255, 255, 0.5);
    padding: 5px 10px;
    z-index: 9999;
}

#search-input {
    background: none;
    border: none;
    outline: none;
    color: #fff;
    font-size: 1rem;
    
    /* Trạng thái đóng: Rút gọn hoàn toàn */
    width: 0;
    padding: 0;
    opacity: 0;
    pointer-events: none; /* Không cho bấm khi đóng */
    
    transition: width 0.3s ease, opacity 0.3s ease;
}

/* Trạng thái mở: Buộc phải hiện */
#search-box-wrapper.active #search-input {
    width: 250px !important; /* Force độ rộng */
    opacity: 1 !important;
    padding-left: 10px;
    pointer-events: auto !important; /* Cho phép nhập liệu */
}

/* Fix trên mobile */
@media (max-width: 768px) {
    #page-header.search-active #search-box-wrapper.active {
        position: absolute;
        left: 10px;
        right: 10px;
        width: auto;
        background-color: #141414;
        z-index: 10001;
    }
    #page-header.search-active #search-box-wrapper.active #search-input {
        width: 100% !important;
    }
}
/* ========================================= */
    /* 3. HERO SLIDER (UPDATED)                  */
    /* ========================================= */
    #hero-section {
        position: relative;
        width: 100%;
        height: 70vh; /* Giữ nguyên chiều cao */
        overflow: hidden;
        background-color: #000;
        margin-bottom: 20px;
    }

    .hero-track {
        display: flex;
        height: 100%;
        width: 100%;
        will-change: transform; /* Tối ưu hiệu năng cuộn */
    }

    .hero-slide {
        min-width: 100%;
        height: 100%;
        position: relative;
        flex-shrink: 0;
        overflow: hidden;
    }

    .hero-bg-wrapper {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 110%;
        z-index: 1;
    }

    .hero-bg {
        width: 100%; height: 100%;
        object-fit: cover;
        opacity: 0.6;
    }

    .hero-overlay {
    /* Thay vì màu đen cứng, ta dùng gradient từ màu động */
    background: linear-gradient(
        to right,
        rgba(var(--dynamic-color), 1) 0%,
        rgba(var(--dynamic-color), 0.6) 50%,
        rgba(var(--dynamic-color), 0.2) 80%,
        transparent 100%
    ),
    linear-gradient(
        to top,
        rgba(var(--dynamic-color), 1) 0%,
        transparent 50%
    );
    transition: background 1s ease; /* Chuyển màu mượt mà */
}


    .hero-content {
        position: absolute;
        bottom: 12%; /* Đẩy lên cao hơn chút để nhường chỗ cho ảnh nhỏ */
        left: clamp(20px, 4vw, 60px);
        z-index: 10;
        max-width: 60%; /* Giới hạn chiều rộng nội dung */
        opacity: 0;
        transform: translateY(30px);
        transition: opacity 0.8s ease, transform 0.8s ease;
    }

    .hero-slide.active .hero-content {
        opacity: 1;
        transform: translateY(0);
    }

    .hero-badge {
        display: inline-block;
        background-color: rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255,255,255,0.4);
        color: #fff;
        padding: 4px 12px;
        font-weight: 600;
        font-size: 0.8rem;
        border-radius: 4px;
        margin-bottom: 15px;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .hero-program {
        font-size: 1rem;
        color: var(--accent-color);
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 5px;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
    }

    /* FIX 2: CHỮ NHỎ HƠN */
    .hero-title {
        font-size: clamp(1.8rem, 4vw, 2.8rem); /* Giảm từ 3.5rem xuống */
        font-weight: 800;
        line-height: 1.2;
        margin: 0 0 15px 0;
        color: #fff;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
    }

    .hero-actions {
        display: flex; gap: 15px;
    }

    .hero-btn {
        padding: 10px 24px; /* Nút gọn hơn chút */
        border: none; border-radius: 6px;
        font-size: 1rem; font-weight: 600;
        cursor: pointer; display: flex; align-items: center; gap: 8px;
        transition: transform 0.2s, background 0.2s;
    }

    .hero-btn-primary { background-color: #fff; color: #000; }
    .hero-btn-primary:hover { background-color: #ddd; transform: scale(1.05); }

    .hero-btn-secondary { background-color: rgba(109, 109, 110, 0.7); color: #fff; backdrop-filter: blur(4px); }
    .hero-btn-secondary:hover { background-color: rgba(109, 109, 110, 0.4); transform: scale(1.05); }

    /* FIX 4: THANH ĐIỀU HƯỚNG BẰNG ẢNH NHỎ */
    .hero-thumb-nav {
        position: absolute;
        bottom: 30px;
        right: clamp(20px, 4vw, 60px);
        display: flex;
        gap: 10px;
        z-index: 20;
    }

    .hero-thumb-item {
        width: 60px;
        height: 36px;
        border-radius: 4px;
        overflow: hidden;
        cursor: pointer;
        opacity: 0.5;
        border: 2px solid transparent;
        transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        position: relative;
    }

    .hero-thumb-item img {
        width: 100%; height: 100%; object-fit: cover;
    }

    .hero-thumb-item:hover { opacity: 1; transform: scale(1.1); }
    
    .hero-thumb-item.active {
        opacity: 1;
        border-color: #fff;
        transform: scale(1.15);
        box-shadow: 0 4px 10px rgba(0,0,0,0.5);
    }

    /* Mũi tên điều hướng 2 bên (ẩn bớt đi cho đỡ rối hoặc làm mờ) */
    .hero-nav-btn {
        position: absolute; top: 0; bottom: 0; width: 60px;
        border: none; cursor: pointer; z-index: 25; color: #fff;
        display: flex; justify-content: center; align-items: center;
        opacity: 0; transition: all 0.3s; background: transparent;
    }
    #hero-section:hover .hero-nav-btn { opacity: 1; }
    .hero-nav-btn:hover { background: rgba(0,0,0,0.3); }
    .hero-nav-btn svg { width: 32px; height: 32px; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5)); }
    .hero-nav-btn.prev { left: 0; }
    .hero-nav-btn.next { right: 0; }

    @media (max-width: 768px) {
        #hero-section { height: 60vh; }
        .hero-content { bottom: 15%; width: 90%; max-width: 100%; }
        /* Mobile ẩn ảnh nhỏ đi cho đỡ chật, dùng dots hoặc ẩn luôn */
        .hero-thumb-nav { display: none; } 
    }
    /* ========================================= */
    /* 4. MAIN LAYOUT, LISTS & SCROLL BUTTONS    */
    /* ========================================= */
    #library-container {
        display: flex;
        flex-direction: column;
    }

    .program-row {
        position: relative;
    }

    .program-title, .search-results-header {
        font-size: 1.5rem;
        font-weight: 600;
        margin-bottom: 15px;
        color: #fff;
        padding-left: clamp(20px, 4vw, 60px);
        padding-right: clamp(20px, 4vw, 60px);
    }

    .list-wrapper {
        position: relative;
    }

    .video-list {
        display: flex;
        gap: 15px;
        overflow-x: auto;
        overflow-y: hidden;
        scroll-behavior: smooth;
        scroll-snap-type: x mandatory;
        scroll-padding-left: clamp(20px, 4vw, 60px);
        width: 100%;
        box-sizing: border-box;
    }

    .video-list::-webkit-scrollbar {
        display: none;
    }

    .video-list::before, .video-list::after {
        content: '';
        display: block;
        width: clamp(20px, 4vw, 60px);
        flex-shrink: 0;
    }

    .video-list::before { margin-right: -15px; }
    .video-list::after { margin-left: -15px; }

    /* Scroll Buttons for Carousel */
    .scroll-btn {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 50px;
        background: rgba(20, 20, 20, 0.5);
        border: none;
        cursor: pointer;
        z-index: 20;
        color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 0;
        transition: opacity 0.3s, background 0.3s;
    }

    .scroll-btn svg {
        width: 30px;
        height: 30px;
        fill: #fff;
        transition: transform 0.2s;
    }

    .scroll-btn:hover svg {
        transform: scale(1.2);
    }

    .list-wrapper:hover .scroll-btn {
        opacity: 1;
    }

    .scroll-btn.left {
        left: 0;
        background: linear-gradient(to right, rgba(0, 0, 0, 0.8) 0%, transparent 100%);
    }

    .scroll-btn.right {
        right: 0;
        background: linear-gradient(to left, rgba(0, 0, 0, 0.8) 0%, transparent 100%);
    }

    .scroll-btn.hidden-arrow {
        opacity: 0 !important;
        pointer-events: none !important;
    }

    /* Grid View (Search Results) */
    .grid-view-container {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 20px 15px;
        padding: 0 clamp(20px, 4vw, 60px);
    }

    .grid-view-container .video-card {
        width: 100% !important;
        flex-basis: auto !important;
    }

    @media (max-width: 768px) {
        .grid-view-container {
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        }
    }

    /* ========================================= */
    /* 5. VIDEO CARDS                            */
    /* ========================================= */
    .video-card {
        background-color: var(--secondary-bg);
        border-radius: 6px;
        scroll-snap-align: start;
        position: relative;
        cursor: pointer;
        transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.27), z-index 0s 0.3s;
        flex-shrink: 0;
        flex-grow: 0;
        /* Width Calculation: (100% - gap * 3) / 4 items */
        width: calc((100% - 45px) / 4);
        flex-basis: calc((100% - 45px) / 4);
    }

    @media (max-width: 1024px) {
        .video-card {
            width: calc((100% - 30px) / 3);
            flex-basis: calc((100% - 30px) / 3);
        }
    }

    @media (max-width: 768px) {
        .video-card {
            width: calc((100% - 15px) / 2);
            flex-basis: calc((100% - 15px) / 2);
        }
    }

    .card-image-wrapper {
        position: relative;
        width: 100%;
        aspect-ratio: 16 / 9;
        border-radius: 6px;
        overflow: hidden;
        z-index: 1;
    }

    .video-thumbnail {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
    }

    .episode-badge {
        position: absolute;
        top: 8px;
        right: 8px;
        background-color: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 600;
        backdrop-filter: blur(4px);
        z-index: 5;
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    /* Progress bar on Card */
    .progress-bar-wrapper {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background-color: rgba(255, 255, 255, 0.3);
        z-index: 2;
    }

    .watched-bar {
        height: 100%;
        background-color: var(--accent-color);
        width: 0%;
        max-width: 100%;
    }

    /* Hover Effects */
    @media (hover: hover) {
        .video-card:hover {
            transform: none !important;
            z-index: auto !important;
            opacity: 1 !important;
            filter: none !important;
            box-shadow: none !important;
        }
        .video-card:hover .card-info {
            display: none !important;
        }
        /* Làm mờ card gốc khi Portal đang hiện */
        .video-card:hover {
            opacity: 0.5; 
        }
    }

    /* ========================================= */
    /* 6. HOVER PORTAL (POPUP PREVIEW)           */
    /* ========================================= */
    #hover-portal {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 10000;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.27);
        width: 300px;
    }

    #hover-portal.visible {
        opacity: 1;
        pointer-events: auto;
        transform: scale(1.3);
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
    }

    .portal-card {
        background-color: #1e1e1e;
        border-radius: 6px;
        overflow: hidden;
    }

    .portal-image-wrapper {
        width: 100%;
        aspect-ratio: 16/9;
    }

    .portal-image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .portal-info {
        padding: 15px;
    }

    #portal-title {
        font-size: 1rem;
        margin: 0 0 8px 0;
        color: #fff;
    }

    .portal-meta {
        font-size: 0.8rem;
        color: #aaa;
        margin-bottom: 10px;
        display: flex;
        gap: 10px;
    }

    .portal-actions {
        display: flex;
        gap: 10px;
    }

    .portal-actions button {
        flex: 1;
        padding: 6px 0;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 600;
        font-size: 0.8rem;
    }

    #portal-play-btn { background: #fff; color: #000; }
    #portal-play-btn:hover { background: #ddd; }

    #portal-info-btn { background: rgba(255, 255, 255, 0.2); color: #fff; }
    #portal-info-btn:hover { background: rgba(255, 255, 255, 0.3); }

    /* ========================================= */
    /* 7. MODALS (GENERAL & DETAIL)              */
    /* ========================================= */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(5px);
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
        box-sizing: border-box;
        z-index: 2000;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .modal-overlay.visible {
        opacity: 1;
        pointer-events: auto;
    }

    .modal-content {
        background: linear-gradient(to bottom, rgba(var(--dynamic-color), 0.8), #141414 80%);
        border-radius: 8px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        position: relative;
        display: block;
        overflow-y: auto;
        max-height: 90dvh;
        width: 100%;
        max-width: 850px;
        scrollbar-width: none;
        opacity: 0;
        transform: scale(0.95) translateY(10px);
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .modal-overlay.visible .modal-content {
        opacity: 1;
        transform: scale(1) translateY(0);
    }

    .modal-content::-webkit-scrollbar {
        display: none;
    }

    .modal-close-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        z-index: 20;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(4px);
        border: none;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        color: #000;
        fill: #000;
        transition: transform 0.2s ease, background-color 0.2s;
    }

    .modal-close-btn:hover {
        transform: scale(1.1);
        background: #fff;
    }

    /* Mobile Modal Slide-up & Drag */
    .modal-drag-handle {
        width: 40px;
        height: 5px;
        background-color: rgba(255,255,255,0.3);
        border-radius: 10px;
        margin: 10px auto;
        display: none;
    }

    @media (max-width: 768px) {
        .modal-overlay {
            padding: 0;
            align-items: flex-end;
        }
        .modal-content {
            max-height: 85vh;
            border-radius: 16px 16px 0 0;
            margin-bottom: 0;
            opacity: 1;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .modal-overlay.visible .modal-content {
            transform: translateY(0);
            opacity: 1;
        }
        .modal-drag-handle { display: block; }
        .modal-content.snapping {
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
    }

    /* Modal Body & Detail Specifics */
    #detail-modal-content { width: 100%; max-width: 800px; }
    #modal-body { padding: 20px 30px 30px 30px; overflow-y: visible; height: auto; }
    
    #modal-header {
        position: relative;
        aspect-ratio: 16 / 9;
        flex-shrink: 0;
    }

    #modal-thumbnail {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 8px 8px 0 0;
        z-index: 1;
        position: relative;
    }

    #modal-header::after {
        content: "";
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 50%;
        background: linear-gradient(to top, var(--primary-bg) 20%, transparent 100%);
        pointer-events: none;
    }

    #modal-play-btn {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.9);
        color: #000;
        border: none;
        border-radius: 5px;
        padding: 10px 25px;
        font-size: 1.2rem;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        z-index: 5;
    }

    #modal-play-btn svg { width: 24px; height: 24px; }

    #modal-title { font-size: clamp(1.5rem, 4vw, 2.2rem); font-weight: 700; margin: 0 0 15px 0; }
    #modal-original-title { margin: -10px 0 15px 0; font-size: 1rem; font-weight: 400; color: #888; font-style: italic; }
    
    #modal-meta { display: flex; align-items: center; gap: 15px; margin-bottom: 20px; color: #aaa; }
    #modal-description { color: #bbb; line-height: 1.6; margin-bottom: 25px; font-size: 0.95rem; }

    #modal-participants-title { font-size: 1.1rem; font-weight: 600; margin-bottom: 10px; }
    #modal-participants-list, #modal-genres-list { display: flex; flex-wrap: wrap; gap: 10px; list-style: none; padding: 0; margin-bottom: 20px; }
    
    .participant-tag { background-color: var(--secondary-bg); padding: 5px 12px; border-radius: 4px; font-size: 0.9rem; }
    .genre-tag { background-color: #333; padding: 4px 10px; border-radius: 4px; font-size: 0.85rem; color: #ccc; }

    /* ========================================= */
    /* 8. TEASER INSIDE MODAL                    */
    /* ========================================= */
    #teaser-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 2;
        background: #000;
        overflow: hidden;
        display: block;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.8s ease-in;
    }

    #teaser-container.visible { opacity: 1; pointer-events: auto; }

    .video-background {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(1.4);
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #teaser-player-iframe { width: 100%; height: 100%; display: block; border: none; }

    #teaser-volume-btn {
        position: absolute;
        bottom: 20px;
        right: 20px;
        z-index: 10;
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: #fff;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: all 0.2s;
    }

    #teaser-volume-btn:hover { background: #fff; color: #000; }

    #teaser-subtitle {
        position: absolute;
        bottom: 70px;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
        width: 80%;
        z-index: 5;
        pointer-events: none;
        font-size: 1rem;
        color: #fff;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        background: rgba(0, 0, 0, 0.4);
        padding: 2px 8px;
        border-radius: 4px;
    }
    #teaser-subtitle:empty { display: none; }

    /* ========================================= */
    /* 9. MODAL EPISODE LIST (HORIZONTAL)        */
    /* ========================================= */
    #modal-episodes-list {
        display: flex;
        gap: 15px;
        overflow-x: auto;
        padding-bottom: 15px;
        scroll-behavior: smooth;
        width: 100%;
        box-sizing: border-box;
        -ms-overflow-style: none;
        scrollbar-width: none;
    }
    #modal-episodes-list::-webkit-scrollbar { display: none; }

    .modal-episode-item {
        display: flex;
        flex-direction: column;
        min-width: 180px;
        max-width: 180px;
        gap: 10px;
        padding: 10px;
        background-color: var(--secondary-bg);
        border-radius: 6px;
        border: 1px solid transparent;
        transition: transform 0.2s, background-color 0.2s;
        cursor: pointer;
    }

    .modal-episode-item:hover {
        background-color: #333;
        transform: scale(1.05);
    }

    .modal-ep-thumb { width: 100%; aspect-ratio: 16/9; object-fit: cover; border-radius: 4px; }
    .modal-ep-info { display: flex; flex-direction: column; }
    .modal-ep-number { font-size: 0.9rem; color: var(--accent-color); font-weight: 700; }
    .modal-ep-title { font-size: 0.85rem; color: #ddd; line-clamp: 2; -webkit-line-clamp: 2; display: -webkit-box; -webkit-box-orient: vertical; overflow: hidden; height: 2.4em; }
    .modal-episode-item .play-icon { display: none; }

    /* Nút cuộn trong Modal */
    #modal-list-wrapper .scroll-btn {
        width: 40px;
        background: rgba(0, 0, 0, 0.6);
        opacity: 0;
    }
    #modal-list-wrapper:hover .scroll-btn { opacity: 1; }

    /* ========================================= */
    /* 10. ADD VIDEO MODAL                       */
    /* ========================================= */
    #add-video-modal-content { width: 90%; max-width: 500px; padding: 30px; }
    #youtube-url-input { width: 100%; box-sizing: border-box; background-color: var(--secondary-bg); color: var(--text-color); border: 1px solid #444; border-radius: 4px; padding: 15px; font-size: 1.1rem; margin-bottom: 15px; }
    #srt-file-label { display: block; width: 100%; box-sizing: border-box; background-color: var(--secondary-bg); border: 1px dashed #555; border-radius: 4px; padding: 15px; font-size: 1rem; margin-bottom: 20px; text-align: center; cursor: pointer; }
    #srt-file-input { display: none; }
    #srt-file-name { color: #aaa; font-style: italic; display: block; margin-top: 5px; }
    #load-video-btn { width: 100%; padding: 15px; font-size: 1.1rem; font-weight: 600; background-color: var(--accent-color); color: var(--text-light); border: none; border-radius: 4px; cursor: pointer; }

    /* ========================================= */
    /* 11. PLAYER V5 - CORE LAYOUT               */
    /* ========================================= */
    #player-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 3000;
        color: white;
        font-family: "Inter", sans-serif;
        overflow: hidden;
    }

    #player-container.no-cursor { cursor: none; }

    #youtube-player {
        position: absolute;
        width: 100%;
        height: 100%;
        border: none;
        opacity: 0;
        transition: opacity 0.5s ease-in;
    }
    #youtube-player.ready { opacity: 1; }

    /* Loading Spinner */
    #loading-spinner {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50px;
        height: 50px;
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid var(--accent-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
        z-index: 5;
        display: none;
    }
    @keyframes spin {
        0% { transform: translate(-50%, -50%) rotate(0deg); }
        100% { transform: translate(-50%, -50%) rotate(360deg); }
    }

   /* ========================================= */
    /* 12. PLAYER CONTROLS & OVERLAYS            */
    /* ========================================= */
    
    /* Mặc định: Ẩn và KHÔNG bấm được (pointer-events: none) */
    #video-header-overlay, #custom-controls, #center-play-pause-btn {
        opacity: 0;
        transition: opacity 0.3s ease;
        position: absolute;
        left: 0;
        width: 100%;
        box-sizing: border-box;
        pointer-events: none; /* [QUAN TRỌNG] Chặn click khi ẩn */
    }

    /* Khi Active: Hiện và CHO PHÉP bấm (pointer-events: auto) */
    #player-container.controls-active > #video-header-overlay,
    #player-container.controls-active > #custom-controls,
    #player-container.controls-active > #center-play-pause-btn {
        opacity: 1;
        pointer-events: auto; /* [QUAN TRỌNG] Kích hoạt click lại */
    }

    /* Header Overlay */
    #video-header-overlay {
        top: 0;
        height: 120px;
        padding: 30px clamp(30px, 5vw, 60px);
        background: linear-gradient(to bottom, rgba(0, 0, 0, 0.85) 0%, transparent 100%);
        z-index: 12;
        display: flex;
        align-items: flex-start;
        gap: 20px;
    }

    #back-btn {
        background: transparent;
        border: none;
        fill: #fff;
        cursor: pointer;
        width: 44px;
        height: 44px;
        padding: 8px;
        border-radius: 50%;
        transition: background 0.2s;
        /* Đã xóa pointer-events: auto ở đây để phụ thuộc vào cha */
        margin-top: -5px;
    }
    #back-btn:hover { background: rgba(255, 255, 255, 0.15); }

    #video-info-area { display: flex; flex-direction: column; justify-content: center; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8); }
    #video-program-display { font-size: 1.1rem; font-weight: 700; color: #fff; margin: 0 0 4px 0; opacity: 1; }
    #video-title-display { font-size: 0.95rem; color: #ddd; margin: 0; font-weight: 400; }

    /* Center Big Play Button */
    #center-play-pause-btn {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80px;
        height: 80px;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(2px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        z-index: 15;
        transition: transform 0.1s;
    }
    #center-play-pause-btn:active { transform: translate(-50%, -50%) scale(0.95); }
    #center-play-pause-btn svg { width: 40px; height: 40px; fill: #fff; margin-left: 4px; }

    /* Interaction Zone */
    #interaction-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; display: flex; }

    /* Subtitles */
    #subtitle-display {
        position: absolute;
        bottom: 50px;
        max-width: 95%;
        z-index: 20;
        text-align: center;
        pointer-events: none;
        transition: bottom 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    #player-container.controls-active #subtitle-display { bottom: 120px; }
    #subtitle-display:not(:empty) { opacity: 1; }

    /* Custom Controls (Bottom) */
    #custom-controls {
        bottom: 0;
        padding: 0 clamp(30px, 5vw, 60px) 1vh;
        background: linear-gradient(to top, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.5) 60%, transparent 100%);
        z-index: 12;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    /* Time & Progress */
    .time-row-container {
        display: flex;
        justify-content: space-between;
        width: 100%;
        margin-bottom: 5px;
        pointer-events: none;
    }
    #current-time-text, #duration-time-text {
        font-size: 0.9rem;
        font-weight: 600;
        color: #ddd;
        text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        font-variant-numeric: tabular-nums;
    }
    #time-display { display: none; }

    .progress-container {
        position: relative;
        width: 100%;
        height: 6px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
        cursor: pointer;
        /* Đã xóa pointer-events: auto ở đây */
        transition: height 0.1s;
        overflow: visible;
    }
    .progress-container:hover { height: 8px; }

    #progress-bar {
        appearance: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 3px;
        cursor: pointer;
        margin: 0;
        background: linear-gradient(
            to right,
            var(--accent-color) 0%,
            var(--accent-color) var(--progress-percent, 0%),
            transparent var(--progress-percent, 0%),
            transparent 100%
        );
        z-index: 1;
    }
    #progress-bar::-webkit-slider-thumb {
        appearance: none;
        width: 16px;
        height: 16px;
        background: #e50914;
        border-radius: 50%;
        cursor: pointer;
        transform: scale(0);
        transition: transform 0.1s;
        position: relative;
        z-index: 10;
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
    }
    #player-container.controls-active #progress-bar::-webkit-slider-thumb { transform: scale(1); }

    /* Timeline Markers */
    .timeline-marker {
        position: absolute;
        top: 0;
        width: 3px;
        height: 100%;
        background-color: #fff;
        z-index: 5;
        pointer-events: none;
        box-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
        transition: height 0.1s;
    }
    .timeline-marker:hover::after {
        content: attr(data-label);
        position: absolute;
        bottom: 15px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 600;
        white-space: nowrap;
        pointer-events: none;
        z-index: 20;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
    }

    /* Controls Buttons Row */
    .controls-row { display: flex; align-items: center; justify-content: space-between; margin-top: 5px; }
    .left-controls, .right-controls { display: flex; align-items: center; }
    .left-controls { gap: 20px; }
    .right-controls { gap: 15px; }

    #play-pause-btn { 
        background: none; border: none; cursor: pointer; padding: 0; 
        /* Đã xóa pointer-events: auto ở đây */
        display: flex; align-items: center; 
    }
    #play-pause-btn svg { width: 32px; height: 32px; fill: #fff; filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.5)); }

    .icon-btn {
        background: none;
        border: none;
        cursor: pointer;
        padding: 8px;
        /* Đã xóa pointer-events: auto ở đây */
        opacity: 0.8;
        transition: opacity 0.2s, transform 0.2s;
    }
    .icon-btn:hover { opacity: 1; transform: scale(1.1); }
    .icon-btn svg { width: 26px; height: 26px; fill: #fff; }

    #cc-toggle-btn.off { opacity: 0.4; }
    #cc-toggle-btn.off:hover { opacity: 0.6; }
    /* ========================================= */
    /* 13. PLAYER FLOATING MENUS                 */
    /* ========================================= */
    .floating-menu {
        position: absolute;
        bottom: 90px;
        right: clamp(30px, 5vw, 60px);
        background-color: rgba(28, 28, 28, 0.9);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
        padding: 20px;
        display: none;
        flex-direction: column;
        z-index: 9999;
        opacity: 0;
        transform: translateY(20px) scale(0.9);
        transition: opacity 0.3s ease, transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.27);
        transform-origin: bottom right;
    }
    .floating-menu.visible { opacity: 1; transform: translateY(0) scale(1); pointer-events: auto; }

    /* Animation Items */
    .floating-menu .control-group, .floating-menu .episode-item { opacity: 0; transform: translateX(-10px); transition: all 0.3s ease; }
    .floating-menu.visible .control-group, .floating-menu.visible .episode-item { opacity: 1; transform: translateX(0); }
    .floating-menu.visible .control-group:nth-child(1) { transition-delay: 0.05s; }
    .floating-menu.visible .control-group:nth-child(2) { transition-delay: 0.1s; }
    .floating-menu.visible .control-group:nth-child(3) { transition-delay: 0.15s; }
    .floating-menu.visible .control-group:nth-child(4) { transition-delay: 0.2s; }

    /* Settings Menu */
    #settings-menu { width: 300px; gap: 20px; }
    .control-group label { display: block; margin-bottom: 8px; font-size: 0.9rem; color: #ccc; display: flex; justify-content: space-between; font-weight: 600; }
    .control-group input[type="range"] { width: 100%; height: 4px; border-radius: 2px; background: rgba(255, 255, 255, 0.2); accent-color: var(--accent-color); }
    .control-group input[type="color"] { width: 100%; height: 35px; border: none; padding: 0; background: none; cursor: pointer; }

    /* Speed Menu */
    .speed-item { background: none; border: none; color: #ccc; font-size: 1rem; padding: 10px; width: 100%; text-align: center; cursor: pointer; border-radius: 4px; transition: background 0.2s, color 0.2s; }
    .speed-item:hover { background-color: rgba(255,255,255,0.1); color: #fff; }
    .speed-item.active { color: var(--accent-color); font-weight: 700; }

    /* Episodes Sidebar */
    #episodes-sidebar { width: 380px; max-width: 90vw; height: auto; max-height: 60vh; border-left: none; }
    #episodes-header { padding: 0 0 15px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.1); margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
    #episodes-header h3 { margin: 0; font-size: 1.1rem; font-weight: 700; color: #fff; }
    #close-episodes-btn { background: none; border: none; color: #ccc; font-size: 1.5rem; cursor: pointer; padding: 0 10px; }
    
    #episodes-content { overflow-y: auto; padding-right: 5px; }
    #episodes-content::-webkit-scrollbar { width: 6px; }
    #episodes-content::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 3px; }
    #episodes-content::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.4); }

    .episode-item { padding: 10px; border-radius: 8px; transition: background 0.2s; border: 1px solid transparent; display: flex; gap: 10px; align-items: center; }
    .episode-item:hover { background-color: rgba(255, 255, 255, 0.1); }
    .episode-item.playing { background-color: rgba(229, 9, 20, 0.15); border: 1px solid rgba(229, 9, 20, 0.5); }
    .episode-item.playing .episode-number { color: #eee; }
    
    .episode-thumbnail { width: 120px; aspect-ratio: 16/9; object-fit: cover; border-radius: 3px; background: #000; }
    .episode-info { flex: 1; display: flex; flex-direction: column; justify-content: center; }
    .episode-title { font-size: 0.95rem; font-weight: 500; margin-bottom: 4px; display: -webkit-box; line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    .episode-number { font-size: 0.8rem; color: #aaa; }
    .episode-item.playing .episode-number { color: var(--accent-color); font-weight: 700; }

    /* Settings Button Rotate */
    #settings-btn svg { transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); }
    #settings-btn.active svg { transform: rotate(90deg); fill: var(--accent-color); }

    /* ========================================= */
    /* 14. UP NEXT & SKIP OVERLAYS               */
    /* ========================================= */
    /* Skip Button */
    #skip-btn {
        position: absolute;
        bottom: 150px;
        right: 0;
        background-color: #fff;
        color: #000;
        border: none;
        padding: 10px 20px;
        font-size: 1rem;
        font-weight: 700;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        z-index: 50;
        opacity: 0;
        transform: translateX(100%);
        transition: all 0.3s ease;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    #skip-btn.visible { opacity: 1; transform: translateX(-20px); pointer-events: auto; }
    #skip-btn:hover { background-color: #e6e6e6; }

    /* Up Next Overlay */
    #up-next-overlay {
        position: absolute;
        top: auto;
        bottom: 0;
        left: 0;
        width: 100%;
        height: auto;
        min-height: 180px;
        z-index: 50;
        background: linear-gradient(to top, #000 10%, rgba(20, 20, 20, 0.95) 70%, transparent 100%);
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
        padding: 0 clamp(30px, 5vw, 60px) 40px;
        box-sizing: border-box;
        transform: translateY(100%);
        opacity: 0;
        transition: transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.5s;
        pointer-events: none;
    }
    #up-next-overlay.visible { transform: translateY(0); opacity: 1; pointer-events: auto; }

    .up-next-left { display: flex; align-items: center; gap: 20px; margin-bottom: 10px; max-width: 60%; }
    .up-next-countdown-wrapper { position: relative; width: 50px; height: 50px; display: flex; justify-content: center; align-items: center; }
    .countdown-circle { transform: rotate(-90deg); }
    #countdown-ring { transition: stroke-dashoffset 1s linear; }
    #up-next-seconds { position: absolute; font-size: 1.2rem; font-weight: 700; color: #fff; }

    .up-next-info { display: flex; flex-direction: column; }
    .up-next-label { font-size: 0.85rem; color: #aaa; font-weight: 600; letter-spacing: 1px; margin-bottom: 5px; text-transform: uppercase; }
    #up-next-title { font-size: clamp(1.2rem, 2vw, 1.8rem); font-weight: 700; color: #fff; margin: 0 0 5px 0; display: -webkit-box; line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
    #up-next-series-name { font-size: 1rem; color: #ccc; }

    .up-next-right { display: flex; align-items: flex-end; gap: 20px; }
    #up-next-card { position: relative; width: 280px; aspect-ratio: 16/9; border-radius: 8px; overflow: hidden; cursor: pointer; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5); border: 2px solid transparent; transition: transform 0.2s, border-color 0.2s; }
    #up-next-card:hover { transform: scale(1.05); border-color: var(--accent-color); }
    #up-next-thumbnail { width: 100%; height: 100%; object-fit: cover; opacity: 0.8; transition: opacity 0.2s; }
    #up-next-card:hover #up-next-thumbnail { opacity: 1; }

    .play-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 48px; height: 48px; background: rgba(0, 0, 0, 0.6); border-radius: 50%; border: 1px solid #fff; display: flex; justify-content: center; align-items: center; backdrop-filter: blur(2px); opacity: 0; transition: opacity 0.2s; }
    #up-next-card:hover .play-overlay { opacity: 1; }
    .play-overlay svg { width: 24px; height: 24px; fill: #fff; }

    #up-next-cancel-btn { background: transparent; border: none; color: #bbb; font-size: 1rem; font-weight: 600; cursor: pointer; padding: 10px 20px; transition: color 0.2s; height: fit-content; margin-bottom: 10px; }
    #up-next-cancel-btn:hover { color: #fff; text-decoration: underline; }

    @media (max-width: 768px) {
        #up-next-overlay { flex-direction: column; align-items: flex-start; padding: 20px; background: rgba(0, 0, 0, 0.95); }
        .up-next-left { width: 100%; max-width: 100%; margin-bottom: 20px; }
        .up-next-right { width: 100%; justify-content: space-between; flex-direction: row-reverse; align-items: center; }
        #up-next-card { width: 160px; }
        #up-next-title { font-size: 1.2rem; }
    }
    /* --- CSS CHO PHẦN RELATED SERIES TRONG MODAL --- */
#modal-related-section {
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    margin-top: 20px;
    padding-top: 10px;
}

#modal-related-list {
    display: flex;
    gap: 15px;
    overflow-x: auto;
    padding-bottom: 10px;
    scroll-behavior: smooth;
    /* Ẩn thanh cuộn */
    -ms-overflow-style: none;
    scrollbar-width: none;
}
#modal-related-list::-webkit-scrollbar {
    display: none;
}

/* Tái sử dụng style của video-card nhưng chỉnh lại chút cho Modal */
#modal-related-list .video-card {
    min-width: 160px; /* Nhỏ hơn card ngoài trang chủ chút */
    width: 160px;
    flex-shrink: 0;
}

/* Chỉnh nút mũi tên trong phần Related */
#modal-related-wrapper .scroll-btn {
    width: 35px;
    background: rgba(0,0,0,0.6);
}
#modal-related-wrapper:hover .scroll-btn {
    opacity: 1;
}
/* --- SEASON SELECTOR (DROPDOWN) --- */
#season-select-wrapper {
    margin-bottom: 15px;
    display: inline-block;
    position: relative;
}

#season-select {
    appearance: none;
    -webkit-appearance: none;
    background-color: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: #fff;
    padding: 8px 35px 8px 15px;
    font-size: 1rem;
    font-weight: 600;
    font-family: "Inter", sans-serif;
    border-radius: 4px;
    cursor: pointer;
    outline: none;
    transition: all 0.2s;
    min-width: 120px;
}

#season-select:hover {
    background-color: rgba(255, 255, 255, 0.2);
    border-color: #fff;
}

/* Mũi tên trỏ xuống tùy chỉnh */
#season-select-wrapper::after {
    content: "▼";
    font-size: 0.7rem;
    color: #aaa;
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
}

#season-select option {
    background-color: #141414; /* Màu nền menu khi xổ xuống */
    color: #fff;
    padding: 10px;
}
</style>
    </head>
    <body>
        <header id="page-header">
            <h1 id="main-title" onclick="location.reload()">MIZZSUB</h1>

            <div id="actions-container">
                <div id="search-box-wrapper">
                    <button id="search-trigger-btn" title="Tìm kiếm">
                        <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                            <path
                                d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z"
                            />
                        </svg>
                    </button>
                    <input
                        type="text"
                        id="search-input"
                        placeholder="Phim, diễn viên, thể loại..."
                        autocomplete="off"
                    />
                    <button id="search-clear-btn">✕</button>
                    <div id="search-suggestions"></div> 
                </div>

                <button id="add-video-btn" title="Nhập link video">
                    <svg viewBox="0 0 24 24" width="28" height="28">
                        <path d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" />
                    </svg>
                </button>
            </div>
        </header>
        <main>
            <div id="hero-section"></div>

            <div id="library-container"></div>
            <div id="library-container">
                <section class="program-row">
                    <div class="video-list">
                        <div class="video-card skeleton-card"></div>
                        <div class="video-card skeleton-card"></div>
                        <div class="video-card skeleton-card"></div>
                    </div>
                </section>
            </div>

            <div id="detail-modal-overlay" class="modal-overlay hidden">
               <div id="detail-modal-content" class="modal-content">
    <button id="detail-modal-close-btn" class="modal-close-btn" title="Đóng">
        <svg viewBox="0 0 24 24" width="24" height="24">
            <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path>
        </svg>
    </button>
    <header id="modal-header">
        <img id="modal-thumbnail" src="" alt="Video thumbnail" />

        <div id="teaser-container">
            <div class="video-background">
                <div id="teaser-player-iframe"></div>
            </div>
            <div id="teaser-subtitle"></div>
            <button id="teaser-volume-btn" title="Bật tiếng">
                <svg id="icon-mute" viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                    <path d="M16.5,12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45,2.45C16.41,12.5,16.5,12.26,16.5,12z M19,12c0,0.94-0.2,1.82-0.54,2.64l1.51,1.51C20.63,14.91,21,13.5,21,12c0-4.28-2.99-7.86-7-8.77v2.06C16.54,6.14,19,8.83,19,12z M4.27,3L3,4.27l4.56,4.57C7.51,8.91,7.5,8.95,7.5,9v6h4l5,5v-6.73l4.25,4.25c-0.67,0.52-1.42,0.93-2.25,1.18v2.06c1.38-0.31,2.63-0.95,3.69-1.81L19.73,21L21,19.73l-9-9L4.27,3z M12,4L9.91,6.09L12,8.18V4z"></path>
                </svg>
                <svg id="icon-unmute" class="hidden" viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                    <path d="M3,9v6h4l5,5V4L7,9H3z M16.5,12c0-1.77-1.02-3.29-2.5-4.03v8.05C15.48,15.29,16.5,13.77,16.5,12z M14,3.23v2.06c2.89,0.86,5,3.54,5,6.71s-2.11,5.85-5,6.71v2.06c4.01-0.91,7-4.49,7-8.77S17.01,4.14,14,3.23z"></path>
                </svg>
            </button>
        </div>

        <button id="modal-play-btn">
            <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M8,5.14V19.14L19,12.14L8,5.14Z"></path>
            </svg>
            Phát
        </button>
    </header>
    <div id="modal-body">
        <h3 id="modal-title"></h3>
        <h4 id="modal-original-title"></h4>
        <div id="modal-meta">
            <span id="modal-program"></span>
            <span id="modal-author"></span>
        </div>
        
        <div id="modal-genres-container" class="hidden">
            <ul id="modal-genres-list"></ul>
        </div>
        
        <p id="modal-description"></p>
        
        <div id="modal-episodes-section" class="hidden">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <h4 style="margin: 0;">Danh sách tập</h4>
                
                <div id="season-select-wrapper" class="hidden">
                    <select id="season-select"></select>
                </div>
                </div>
            <div class="list-wrapper" id="modal-list-wrapper">
                <button id="modal-arrow-left" class="scroll-btn left hidden-arrow">
                    <svg viewBox="0 0 24 24"><path d="M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z"/></svg>
                </button>
                <div id="modal-episodes-list"></div>
                <button id="modal-arrow-right" class="scroll-btn right">
                    <svg viewBox="0 0 24 24"><path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"/></svg>
                </button>
            </div>
        </div>
        
        <div id="modal-participants-container" class="hidden">
            <h4 id="modal-participants-title">Với sự tham gia của:</h4>
            <ul id="modal-participants-list"></ul>
        </div>

        <div id="modal-related-section" class="hidden">
            <h4 style="margin-top: 30px; margin-bottom: 15px; font-size: 1.1rem; color: #fff;">Có thể bạn sẽ thích</h4>
            <div class="list-wrapper" id="modal-related-wrapper">
                <button id="modal-related-arrow-left" class="scroll-btn left hidden-arrow">
                    <svg viewBox="0 0 24 24"><path d="M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z"/></svg>
                </button>
                
                <div id="modal-related-list" class="video-list" style="padding-left: 0;"></div>
                
                <button id="modal-related-arrow-right" class="scroll-btn right">
                    <svg viewBox="0 0 24 24"><path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"/></svg>
                </button>
            </div>
        </div>
    </div>
</div>
            </div>

            <div id="add-video-modal-overlay" class="modal-overlay hidden">
                <div id="add-video-modal-content" class="modal-content">
                    <button id="add-video-close-btn" class="modal-close-btn" title="Đóng">
                        <svg viewBox="0 0 24 24" width="24" height="24">
                            <path
                                d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
                            ></path>
                        </svg>
                    </button>
                    <form id="add-video-form">
                        <h3>Xem video từ link</h3>
                        <input type="text" id="youtube-url-input" placeholder="Dán link YouTube vào đây..." required />
                        <label for="srt-file-input" id="srt-file-label"
                            >Chọn file phụ đề (.srt)<span id="srt-file-name"></span
                        ></label>
                        <input type="file" id="srt-file-input" accept=".srt" />
                        <button type="submit" id="load-video-btn">Tải và Phát</button>
                    </form>
                </div>
            </div>

            <div id="player-wrapper" class="hidden">
                <!-- START: Cấu trúc Player HOÀN CHỈNH v5 -->
                <div id="player-container">
    <div id="youtube-player"></div>
    <div id="loading-spinner"></div>

    <div id="video-header-overlay">
        <button id="back-btn" title="Quay lại">
            <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z"></path></svg>
        </button>
        <div id="video-info-area">
            <h3 id="video-program-display"></h3>
            <p id="video-title-display"></p>
        </div>
    </div>

    <div id="interaction-overlay">
        <div id="seek-backward-zone" style="flex: 1"></div>
        <div id="play-pause-zone" style="flex: 1"></div>
        <div id="seek-forward-zone" style="flex: 1"></div>
    </div>

    <button id="center-play-pause-btn">
        <svg id="center-play-pause-icon" viewBox="0 0 24 24"><path d="M8,5.14V19.14L19,12.14L8,5.14Z"></path></svg>
    </button>

    <div id="subtitle-display"></div>

    <div id="custom-controls">
        <div class="time-row-container">
            <span id="current-time-text">00:00</span>
            <span id="duration-time-text">00:00</span>
        </div>

        <div class="progress-container">
            <input type="range" id="progress-bar" value="0" min="0" step="0.1" />
        </div>

        <div class="controls-row">
            <div class="left-controls">
                <button id="play-pause-btn">
                    <svg><path d="M8,5.14V19.14L19,12.14L8,5.14Z"></path></svg>
                </button>
                
                <button id="next-ep-btn" class="icon-btn" title="Tập tiếp theo">
                    <svg viewBox="0 0 24 24"><path d="M16,18H18V6H16M6,18L14.5,12L6,6V18Z" /></svg>
                </button>
            </div>

            <div class="right-controls">
                <button id="speed-btn" class="icon-btn" title="Tốc độ phát">
    <svg viewBox="0 0 24 24">
        <path d="M5.58,16.89l5.77-4.07c0.56-0.4,0.56-1.24,0-1.63L5.58,7.11C4.91,6.65,4,7.12,4,7.93v8.14 C4,16.88,4.91,17.35,5.58,16.89z M13.58,16.89l5.77-4.07c0.56-0.4,0.56-1.24,0-1.63l-5.77-4.07c-0.67-0.47-1.58,0-1.58,0.81v8.14 C12,16.88,12.91,17.35,13.58,16.89z"/>
    </svg>
</button>

<button id="cc-toggle-btn" class="icon-btn" title="Bật/Tắt Phụ đề">
    <svg viewBox="0 0 24 24">
        <path d="M19,4H5C3.89,4,3,4.9,3,6v12c0,1.1,0.89,2,2,2h14c1.1,0,2-0.9,2-2V6C21,4.9,20.11,4,19,4z M11,11H7v2h4v2H7 c-1.1,0-2-0.9-2-2v-4c0-1.1,0.9-2,2-2h4V11z M17,11h-4v2h4v2h-4c-1.1,0-2-0.9-2-2v-4c0-1.1,0.9-2,2-2h4V11z"/>
    </svg>
</button>

                <button id="episodes-btn" class="icon-btn hidden" title="Danh sách tập">
                    <svg viewBox="0 0 24 24"><path d="M4,10H20V12H4V10M4,6H20V8H4V6M4,14H14V16H4V14M16,13V21L22,17L16,13Z" /></svg>
                </button>

                <button id="settings-btn" class="icon-btn" title="Cài đặt">
                    <svg viewBox="0 0 24 24"><path d="M19.14,12.94C19.07,12.44 19,11.94 19,11.44C19,10.94 19.07,10.44 19.14,9.94L21.12,8.44C21.26,8.33 21.3,8.14 21.24,7.96L19.28,4.5C19.21,4.34 19.02,4.27 18.86,4.34L16.5,5.39C16,4.94 15.43,4.56 14.81,4.29L14.47,2.05C14.45,1.86 14.28,1.71 14.08,1.71H9.92C9.72,1.71 9.55,1.86 9.53,2.05L9.19,4.29C8.57,4.56 8,4.94 7.5,5.39L5.14,4.34C4.98,4.27 4.79,4.34 4.72,4.5L2.76,7.96C2.7,8.14 2.74,8.33 2.88,8.44L4.86,9.94C4.93,10.44 5,10.94 5,11.44C5,11.94 4.93,12.44 4.86,12.94L2.88,14.44C2.74,14.56 2.7,14.75 2.76,14.93L4.72,18.39C4.79,18.55 4.98,18.62 5.14,18.54L7.5,17.5C8,17.94 8.57,18.32 9.19,18.59L9.53,20.84C9.55,21.03 9.72,21.18 9.92,21.18H14.08C14.28,21.18 14.45,21.03 14.47,20.84L14.81,18.59C15.43,18.32 16,17.94 16.5,17.5L18.86,18.54C19.02,18.62 19.21,18.55 19.28,18.39L21.24,14.93C21.3,14.75 21.26,14.56 21.12,14.44L19.14,12.94M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5Z"></path></svg>
                </button>
            </div>
        </div>
    </div>

    <div id="episodes-sidebar" class="floating-menu">
        <div id="episodes-header">
            <h3>Danh sách tập</h3>
            <button id="close-episodes-btn">✕</button>
        </div>
        <div id="episodes-content"></div>
    </div>

    <div id="settings-menu" class="floating-menu">
        <div class="control-group">
            <label>Kích thước chữ</label><input type="range" id="font-size-slider" min="12" max="48" step="1" />
        </div>
        <div class="control-group">
            <label>Màu chữ</label><input type="color" id="font-color-picker" />
        </div>
        <div class="control-group">
            <label>Màu nền</label><input type="color" id="bg-color-picker" />
        </div>
        <div class="control-group">
            <label>Độ mờ nền</label><input type="range" id="bg-opacity-slider" min="0" max="1" step="0.05" />
        </div>
    </div>

    <div id="speed-menu" class="floating-menu" style="width: 150px; align-items: center;">
        <button class="speed-item" data-speed="0.25">0.25x</button>
        <button class="speed-item" data-speed="0.5">0.5x</button>
        <button class="speed-item" data-speed="0.75">0.75x</button>
        <button class="speed-item active" data-speed="1">Chuẩn (1x)</button>
        <button class="speed-item" data-speed="1.25">1.25x</button>
        <button class="speed-item" data-speed="1.5">1.5x</button>
        <button class="speed-item" data-speed="2">2x</button>
    </div>

    <button id="skip-btn" class="hidden">Bỏ qua</button>
    
    <div id="up-next-overlay">
        <div class="up-next-left">
            <div class="up-next-countdown-wrapper">
                <svg class="countdown-circle" width="50" height="50" viewBox="0 0 50 50">
                    <circle cx="25" cy="25" r="22" fill="none" stroke="#333" stroke-width="3"></circle>
                    <circle id="countdown-ring" cx="25" cy="25" r="22" fill="none" stroke="#e50914" stroke-width="3" stroke-dasharray="138" stroke-dashoffset="0"></circle>
                </svg>
                <span id="up-next-seconds">5</span>
            </div>
            <div class="up-next-info">
                <span class="up-next-label">ĐANG PHÁT TIẾP THEO</span>
                <h3 id="up-next-title"></h3>
                <span id="up-next-series-name"></span>
            </div>
        </div>
        <div class="up-next-right">
            <div id="up-next-card">
                <img id="up-next-thumbnail" src="" />
                <div class="play-overlay"><svg viewBox="0 0 24 24"><path d="M8,5.14V19.14L19,12.14L8,5.14Z"></path></svg></div>
            </div>
            <button id="up-next-cancel-btn">Hủy</button>
        </div>
    </div>
</div>
                <!-- END: Cấu trúc Player HOÀN CHỈNH v5 -->
            </div>
            <div id="notification-area"></div>
        </main>
        <div id="hover-portal" class="hidden">
            <div class="portal-card">
                <div class="portal-image-wrapper">
                    <img id="portal-img" src="" alt="" />
                </div>
                <div class="portal-info">
                    <h3 id="portal-title"></h3>
                    <div class="portal-meta">
                        <span id="portal-ep"></span>
                        <span id="portal-genre"></span>
                    </div>
                    <div class="portal-actions">
                        <button id="portal-play-btn">▶ Phát ngay</button>
                        <button id="portal-info-btn">ℹ Chi tiết</button>
                    </div>
                </div>
            </div>
        </div>

        <script>
            const doc = document;
            // --- DOM Elements ---
            const libraryContainer = doc.getElementById("library-container");
            const searchInput = doc.getElementById("search-input");

            const addVideoBtn = doc.getElementById("add-video-btn");
            const detailModalOverlay = doc.getElementById("detail-modal-overlay");
            const detailModalCloseBtn = doc.getElementById("detail-modal-close-btn");
            const modalPlayBtn = doc.getElementById("modal-play-btn");
            const modalThumbnail = doc.getElementById("modal-thumbnail");
            const modalTitle = doc.getElementById("modal-title");
            const modalProgram = doc.getElementById("modal-program");
            const modalAuthor = doc.getElementById("modal-author");
            const modalParticipantsList = doc.getElementById("modal-participants-list");
            const modalParticipantsContainer = doc.getElementById("modal-participants-container");
            const addVideoModalOverlay = doc.getElementById("add-video-modal-overlay");
            const addVideoForm = doc.getElementById("add-video-form");
            const addVideoCloseBtn = doc.getElementById("add-video-close-btn");
            const urlInput = doc.getElementById("youtube-url-input");
            const srtFileInput = doc.getElementById("srt-file-input");
            const srtFileName = doc.getElementById("srt-file-name");
            const playerWrapper = doc.getElementById("player-wrapper");
            const playerContainer = doc.getElementById("player-container");
            const clickOverlay = doc.getElementById("click-overlay");
            const backBtn = doc.getElementById("back-btn");
            const videoTitleDisplay = doc.getElementById("video-title-display");
            const videoProgramDisplay = doc.getElementById("video-program-display");
            const subtitleDisplay = doc.getElementById("subtitle-display");
            const settingsBtn = doc.getElementById("settings-btn");
            const settingsMenu = doc.getElementById("settings-menu");
            const fontSizeSlider = doc.getElementById("font-size-slider");
            const fontColorPicker = doc.getElementById("font-color-picker");
            const bgColorPicker = doc.getElementById("bg-color-picker");
            const bgOpacitySlider = doc.getElementById("bg-opacity-slider");
            const playPauseBtn = doc.getElementById("play-pause-btn");
            const progressBar = doc.getElementById("progress-bar");
            const episodesBtn = doc.getElementById("episodes-btn");
            const episodesSidebar = doc.getElementById("episodes-sidebar");
            const episodesContent = doc.getElementById("episodes-content");
            const closeEpisodesBtn = doc.getElementById("close-episodes-btn");
            const skipBtn = doc.getElementById("skip-btn");
            const modalOriginalTitle = doc.getElementById("modal-original-title");
            // --- DOM Elements cho Portal ---
            const portal = document.getElementById("hover-portal");
            const portalImg = document.getElementById("portal-img");
            const portalTitle = document.getElementById("portal-title");
            const portalEp = document.getElementById("portal-ep");
            const portalGenre = document.getElementById("portal-genre");
            const portalPlayBtn = document.getElementById("portal-play-btn");
            const portalInfoBtn = document.getElementById("portal-info-btn");
            // --- DOM Elements Teaser ---
            const teaserContainer = document.getElementById("teaser-container");
            const teaserSubtitle = document.getElementById("teaser-subtitle");
            const teaserVolumeBtn = document.getElementById("teaser-volume-btn");
            const iconMute = document.getElementById("icon-mute");
            const iconUnmute = document.getElementById("icon-unmute");
            // Helper: Lấy timestamp chuẩn nhất (Ưu tiên publishedAt_official)
const getVideoTimestamp = (v) => {
    if (v.publishedAt_official) return new Date(v.publishedAt_official).getTime();
    if (v.uploadDate_auto) return new Date(v.uploadDate_auto).getTime();
    return 0; 
};
const colorThief = new ColorThief();
            // --- State Variables ---
            let player;
            let libraryData = [];
            let subtitles = [];
            let controlsTimeout, progressInterval, subtitleCheckInterval;
            let subtitleSettings = {};
            let currentVideoData = null; // Lưu thông tin video đang phát
            let upNextTimeout, upNextInterval; // Dùng cho tính năng "Tập tiếp theo"
            let lastClickInfo = { time: 0, area: null }; // Dùng để phát hiện double-click THEO VÙNG
            let isEnding = false; // Cờ để chống lặp khi video kết thúc
            let currentSkipTarget = null; // Thời điểm bỏ qua hiện tại
            let hoverTimeout;
            let hideTimeout;
            let currentHoveredCard = null; // Card gốc đang được hover
            let isParallaxTicking = false; // Biến khóa (Flag) cho hiệu ứng parallax
            let teaserPlayer = null;
            let teaserSubtitles = [];
            let teaserSyncInterval = null;
            let isTeaserMuted = true;
            let isUpNextTriggered = false; // Cờ chặn gọi trùng lặp
            let isFiltering = false;
            let lastSubtitleEnd = 0;       // Thời gian kết thúc của dòng sub cuối cùng
            function applyThemeFromImage(imageUrl) {
    const img = new Image();
    // [QUAN TRỌNG] Cho phép tải ảnh từ domain khác (YouTube) để lấy màu
    img.crossOrigin = "Anonymous"; 
    img.src = imageUrl;

    img.onload = function() {
        try {
            // 1. Lấy màu chủ đạo (Dominant Color) -> Trả về mảng [R, G, B]
            const color = colorThief.getColor(img);
            
            // 2. Lấy bảng màu (Palette) để tìm màu tương phản làm điểm nhấn (tùy chọn)
            const palette = colorThief.getPalette(img, 5);
            
            // 3. Gán vào biến CSS
            const root = document.documentElement;
            
            // Màu nền chủ đạo (RGB)
            root.style.setProperty('--dynamic-color', `${color[0]}, ${color[1]}, ${color[2]}`);
            
            // (Tùy chọn) Đổi màu accent nếu muốn
            // root.style.setProperty('--accent-color', `rgb(${palette[1][0]}, ${palette[1][1]}, ${palette[1][2]})`);
            
        } catch (e) {
            console.log("Lỗi lấy màu (có thể do CORS):", e);
            // Fallback về màu mặc định nếu lỗi
            document.documentElement.style.setProperty('--dynamic-color', '20, 20, 20');
        }
    };
    
    img.onerror = function() {
        // Fallback nếu ảnh lỗi
        document.documentElement.style.setProperty('--dynamic-color', '20, 20, 20');
    };
}
            const DEFAULT_SUB_SETTINGS = { fontSize: "24", fontColor: "#FFFFFF", bgColor: "#000000", bgOpacity: "0.5" };
            /* --- LOGIC TEASER MỚI --- */
            function checkAndLoadTeaser(programName) {
                if (!programName) {
                    destroyTeaser();
                    return;
                }

                const teasers = libraryData.filter(
                    (v) => v.program === programName && v.genres && v.genres.some((g) => g.toUpperCase() === "TEASER")
                );

                if (teasers.length === 0) {
                    destroyTeaser();
                    return;
                }

                // Lấy teaser mới nhất
                teasers.sort((a, b) => {
                    const dateA = a.uploadDate_auto ? new Date(a.uploadDate_auto).getTime() : 0;
                    const dateB = b.uploadDate_auto ? new Date(b.uploadDate_auto).getTime() : 0;
                    return dateB - dateA;
                });

                const teaserVideo = teasers[0];

                // 1. [MỚI] Cập nhật ngay ảnh Thumbnail của Modal thành ảnh của Teaser
                // Để khi video hiện lên, nó khớp hình, không bị giật
                const thumb = teaserVideo.thumbnailUrl || teaserVideo.thumbnailUrl_auto;
                if (thumb) document.getElementById("modal-thumbnail").src = thumb.replace("hqdefault", "maxresdefault");

                // 2. Khởi tạo Player (nhưng chưa hiện container lên vội)
                initTeaserPlayer(teaserVideo);
            }
            function initTeaserPlayer(video) {
                // Reset trạng thái cũ
                teaserSubtitles = [];
                teaserSubtitle.innerHTML = "";
                clearInterval(teaserSyncInterval);

                // Đảm bảo ẩn player trước khi load cái mới
                teaserContainer.classList.remove("visible");

                // Load phụ đề (giữ nguyên)
                if (video.subtitleUrl) {
                    fetch(video.subtitleUrl)
                        .then((res) => res.text())
                        .then((text) => {
                            teaserSubtitles = parseSubtitle(text);
                            startTeaserSubtitleSync();
                        })
                        .catch((err) => console.log("Lỗi sub teaser:", err));
                }

                // Cấu hình Player
                const playerVars = {
                    autoplay: 1,
                    controls: 0,
                    disablekb: 1,
                    fs: 0,
                    iv_load_policy: 3,
                    modestbranding: 1,
                    rel: 0,
                    showinfo: 0,
                    mute: 1,
                    loop: 1,
                    playlist: video.videoId,
                };

                if (teaserPlayer) {
                    // Nếu player đã có, load video mới
                    teaserPlayer.loadVideoById(video.videoId);
                    teaserPlayer.mute();
                } else {
                    // Tạo mới
                    teaserPlayer = new YT.Player("teaser-player-iframe", {
                        videoId: video.videoId,
                        playerVars: playerVars,
                        events: {
                            onReady: (event) => {
                                event.target.mute();
                                event.target.playVideo();
                            },
                            onStateChange: (event) => {
                                // [SỬA ĐỔI QUAN TRỌNG TẠI ĐÂY]

                                // 1. Khi Video thực sự chạy -> Hiện Container (Fade in)
                                if (event.data === YT.PlayerState.PLAYING) {
                                    teaserContainer.classList.add("visible");
                                }

                                // 2. Loop thủ công nếu cần
                                if (event.data === YT.PlayerState.ENDED) {
                                    event.target.playVideo();
                                }
                            },
                        },
                    });
                }

                isTeaserMuted = true;
                updateVolumeUI();
            }

            function destroyTeaser() {
                // Ẩn container
                teaserContainer.classList.remove("visible");

                // Dừng video
                if (teaserPlayer && typeof teaserPlayer.stopVideo === "function") {
                    teaserPlayer.stopVideo();
                }

                // Xóa phụ đề
                clearInterval(teaserSyncInterval);
                teaserSubtitle.innerHTML = "";
            }

            function startTeaserSubtitleSync() {
                clearInterval(teaserSyncInterval);
                teaserSyncInterval = setInterval(() => {
                    if (!teaserPlayer || !teaserPlayer.getCurrentTime) return;
                    const c = teaserPlayer.getCurrentTime();
                    const sub = teaserSubtitles.find((s) => c >= s.start && s.end >= c);
                    teaserSubtitle.innerHTML = sub ? sub.text : "";
                }, 100);
            }

            function updateVolumeUI() {
                if (isTeaserMuted) {
                    iconMute.classList.remove("hidden");
                    iconUnmute.classList.add("hidden");
                    if (teaserPlayer) teaserPlayer.mute();
                } else {
                    iconMute.classList.add("hidden");
                    iconUnmute.classList.remove("hidden");
                    if (teaserPlayer) teaserPlayer.unMute();
                }
            }
            
            // 2. Click nút X -> Xóa sạch & Reset list & Focus lại
         
            // Hàm xóa dấu Tiếng Việt để tìm kiếm chính xác hơn
            // VD: "Đô thị" -> "do thi"
            function toNonAccentVietnamese(str) {
                if (!str) return "";
                str = str.toLowerCase();
                str = str.replace(/à|á|ạ|ả|ã|â|ầ|ấ|ậ|ẩ|ẫ|ă|ằ|ắ|ặ|ẳ|ẵ/g, "a");
                str = str.replace(/è|é|ẹ|ẻ|ẽ|ê|ề|ế|ệ|ể|ễ/g, "e");
                str = str.replace(/ì|í|ị|ỉ|ĩ/g, "i");
                str = str.replace(/ò|ó|ọ|ỏ|õ|ô|ồ|ố|ộ|ổ|ỗ|ơ|ờ|ớ|ợ|ở|ỡ/g, "o");
                str = str.replace(/ù|ú|ụ|ủ|ũ|ư|ừ|ứ|ự|ử|ữ/g, "u");
                str = str.replace(/ỳ|ý|ỵ|ỷ|ỹ/g, "y");
                str = str.replace(/đ/g, "d");
                // Loại bỏ ký tự đặc biệt nếu muốn
                str = str.replace(/\u0300-\u036f/g, "");
                return str;
            }
            // --- Initialization ---
            function onYouTubeIframeAPIReady() {
                player = new YT.Player("youtube-player", {
                    videoId: "", // chưa có video thực, khởi tạo rỗng
                    playerVars: {
                        autoplay: 0,
                        playsinline: 1,
                        rel: 0,
                        modestbranding: 1,
                        controls: 0,
                        showinfo: 0,
                        cc_load_policy: 0,
                        iv_load_policy: 3,
                        disablekb: 1,
                    },
                    events: {
                        onReady: () => {
                            // gọi sau khi player đã sẵn sàng
                        },
                        onStateChange: onPlayerStateChange,
                    },
                });
            }

            // --- LOGIC KHỞI TẠO MỚI ---
            async function initializeLibrary() {
                try {
                    const res = await fetch(`library.json?v=${new Date().getTime()}`, { cache: "no-store" });
                    if (!res.ok) throw new Error("Không thể tải thư viện.");
                    libraryData = await res.json();

                    // 1. [MỚI] Tách 6 video mới nhất để làm Hero Slider
                    // Sort theo ngày mới nhất
                    const sortedByDate = [...libraryData].sort((a, b) => {
    return getVideoTimestamp(b) - getVideoTimestamp(a);
});
const top6 = sortedByDate.slice(0, 6); 

                    // 2. Render Hero Slider
                    setupHeroSlider(top6);

                    // 3. Render phần còn lại (Danh sách bên dưới)
                    renderVideoRows(libraryData);

                    setupEventListeners();
                    loadSubtitleSettings();
                } catch (e) {
                    libraryContainer.innerHTML = `<p style="color: #ff8a8a; text-align: center;">Lỗi: ${e.message}</p>`;
                }
            }
            document.addEventListener("click", (e) => {
                if (!searchWrapper.contains(e.target) && searchWrapper.classList.contains("active")) {
                    // Chỉ đóng nếu input rỗng
                    if (searchInput.value.trim() === "") {
                        searchWrapper.classList.remove("active");
                        searchClear.classList.remove("visible");
                        pageHeader.classList.remove("search-active"); // [Mobile] Hiện lại Logo
                    }
                }
            });
            document.addEventListener("DOMContentLoaded", () => {
                initializeLibrary();
            });

           function toggleFloatingMenu(menuId) {
    const targetMenu = document.getElementById(menuId);
    if (!targetMenu) return;

    // Danh sách tất cả menu nổi
    const allMenus = ["settings-menu", "episodes-sidebar", "speed-menu"];
    
    // 1. [QUAN TRỌNG] Kiểm tra trạng thái TRƯỚC khi reset
    // Nếu nó đang có class 'visible', tức là đang mở -> User muốn đóng nó.
    const wasVisible = targetMenu.classList.contains("visible");

    // 2. Đóng TẤT CẢ menu trước (Reset về trạng thái sạch)
    allMenus.forEach(id => {
        const m = document.getElementById(id);
        if (m) {
            m.classList.remove("visible");
            // Ẩn display sau khi hết animation
            setTimeout(() => { 
                if(!m.classList.contains("visible")) m.style.display = "none"; 
            }, 300);
        }
    });
    
    // Reset active state của các nút (Bỏ sáng nút)
    document.getElementById("settings-btn").classList.remove("active");
    document.getElementById("episodes-btn").classList.remove("active");
    // (Nếu muốn nút speed cũng sáng khi mở thì thêm logic remove active cho speed-btn ở đây)

    // 3. LOGIC QUYẾT ĐỊNH:
    // Chỉ mở lại nếu TRƯỚC ĐÓ nó CHƯA mở (wasVisible === false)
    if (!wasVisible) {
        targetMenu.style.display = "flex"; // hoặc block tuỳ CSS của bạn
        
        // Render content nếu là episodes (Logic cũ của bạn)
        if (menuId === "episodes-sidebar") renderEpisodeList();

        requestAnimationFrame(() => {
            targetMenu.classList.add("visible");
        });

        // Set active icon tương ứng (Làm sáng nút đang mở)
        if (menuId === "settings-menu") document.getElementById("settings-btn").classList.add("active");
        if (menuId === "episodes-sidebar") document.getElementById("episodes-btn").classList.add("active");
    }
}
            // --- [FIXED] LOGIC HIỂN THỊ PORTAL ---
            // Thêm tham số isProgramCard để biết đây là thẻ Series hay thẻ Video lẻ
            function showPortal(card, videoData, isProgramCard = false) {
                clearTimeout(hideTimeout);
                portal.classList.remove("hidden");

                const rect = card.getBoundingClientRect();
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;

                // 1. [FIX] XỬ LÝ TIÊU ĐỀ & METADATA
                if (isProgramCard) {
                    // Nếu là Card Chương trình: Hiện tên Chương trình
                    portalTitle.textContent = videoData.program;

                    // Đếm số tập
                    const count = libraryData.filter((v) => v.program === videoData.program).length;
                    portalEp.textContent = `${count} Tập`;

                    // Thể loại chính
                    portalGenre.textContent = (videoData.genres && videoData.genres[0]) || "Series";
                } else {
                    // Nếu là Card Video lẻ: Hiện tên Video
                    portalTitle.textContent = videoData.userTitle || videoData.title;
                    portalEp.textContent = videoData.episode ? `Tập ${videoData.episode}` : "Phim lẻ";
                    portalGenre.textContent = videoData.program;
                }

                // 2. Điền ảnh (luôn lấy từ videoData truyền vào)
                portalImg.src = videoData.thumbnailUrl || videoData.thumbnailUrl_auto;

                // 3. [FIX] NÚT PHÁT (PLAY)
                portalPlayBtn.onclick = () => {
                    launchPlayer(videoData);
                    hidePortal(true);
                };

                // 4. [FIX QUAN TRỌNG] NÚT CHI TIẾT (INFO)
                // Dù là Card Video lẻ hay Card Chương trình, nếu có 'program' thì đều mở Modal Series
                portalInfoBtn.onclick = () => {
                    if (videoData.program) {
                        // Tìm tất cả các tập của chương trình này
                        const episodes = libraryData
                            .filter((v) => v.program === videoData.program)
                            .sort((a, b) => getVideoTimestamp(a) - getVideoTimestamp(b));

                        // Mở Modal Series (truyền list tập vào)
                        openDetailModal(videoData, episodes);
                    } else {
                        // Video lẻ thật sự (không thuộc program nào) -> Mở Modal lẻ
                        openDetailModal(videoData, null);
                    }
                    hidePortal(true);
                };

                // 5. Định vị & Animation (Giữ nguyên)
                portal.style.transition = "none";
                portal.classList.remove("visible");

                portal.style.width = `${rect.width}px`;
                portal.style.height = `${rect.height}px`;
                portal.style.top = `${rect.top + scrollTop}px`;
                portal.style.left = `${rect.left + scrollLeft}px`;

                void portal.offsetWidth;

                portal.style.transition = "opacity 0.2s, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.27)";
                portal.classList.add("visible");
            }

            // Hàm ẩn Portal
            // force = true: Ẩn ngay lập tức (khi click hoặc scroll)
            function hidePortal(force = false) {
                if (force) {
                    portal.classList.remove("visible");
                    portal.classList.add("hidden");
                    currentHoveredCard = null;
                    return;
                }

                // Nếu ẩn thường (do chuột rời đi), chỉ bỏ class visible
                portal.classList.remove("visible");
                currentHoveredCard = null;

                // Đợi transition mờ dần xong mới display: none
                // Lưu timeout này lại để nếu chuột quay lại kịp thì hủy nó đi (trong showPortal)
                hideTimeout = setTimeout(() => {
                    portal.classList.add("hidden");
                }, 300);
            }
            settingsBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                toggleFloatingMenu("settings-menu");
            });

            episodesBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                toggleFloatingMenu("episodes-sidebar");
            });
            // Cập nhật đoạn click ra ngoài để reset icon xoay
            playerContainer.addEventListener("click", (e) => {
                const clickedInsideMenu = e.target.closest(".floating-menu");
                const clickedButton = e.target.closest(".icon-btn");

                if (!clickedInsideMenu && !clickedButton) {
                    const menus = document.querySelectorAll(".floating-menu.visible");
                    menus.forEach((menu) => {
                        menu.classList.remove("visible");
                        setTimeout(() => {
                            if (!menu.classList.contains("visible")) menu.style.display = "none";
                        }, 300);
                    });

                    // Reset tất cả icon
                    document.getElementById("settings-btn").classList.remove("active");
                    document.getElementById("episodes-btn").classList.remove("active");
                }
            });
            // --- SỰ KIỆN HOVER ĐỂ HIỆN PORTAL (CHỈ DÀNH CHO PC) ---
            libraryContainer.addEventListener("mouseover", (e) => {
                // Check thiết bị
                const isDesktop =
                    window.matchMedia("(hover: hover) and (pointer: fine)").matches && window.innerWidth > 1024;
                if (!isDesktop) return;

                const card = e.target.closest(".video-card");
                if (!card) return;

                clearTimeout(hideTimeout);
                if (currentHoveredCard === card) return;
                clearTimeout(hoverTimeout);

                hoverTimeout = setTimeout(() => {
                    currentHoveredCard = card;
                    let videoData;
                    let isProgramCard = false; // [QUAN TRỌNG] Biến đánh dấu đây là Card Chương trình

                    // TRƯỜNG HỢP 1: Hover vào Card Chương trình (Series)
                    if (card.dataset.programName) {
                        isProgramCard = true; // Bật cờ lên
                        const videos = libraryData
                            .filter((v) => v.program === card.dataset.programName)
                            .sort((a, b) => getVideoTimestamp(b) - getVideoTimestamp(a)); 
                        videoData = videos[0]; // Lấy tập mới nhất làm đại diện ảnh bìa
                    }
                    // TRƯỜNG HỢP 2: Hover vào Card Video lẻ
                    else if (card.dataset.videoId) {
                        isProgramCard = false;
                        videoData = libraryData.find((v) => v.videoId === card.dataset.videoId);
                    }

                    if (videoData) {
                        // [FIX] Truyền biến isProgramCard vào tham số thứ 3
                        showPortal(card, videoData, isProgramCard);
                    }
                }, 200);
            });

            /* --- [FIX MỚI] SỰ KIỆN CHUỘT RỜI CARD (để chặn lướt nhanh bị dính) --- */
            libraryContainer.addEventListener("mouseout", (e) => {
                const card = e.target.closest(".video-card");
                if (!card) return;

                // e.relatedTarget là phần tử mà chuột di chuyển ĐẾN
                const moveDestination = e.relatedTarget;

                // 1. Nếu chuột chỉ di chuyển vào các thành phần con bên trong Card (ảnh, text...)
                // -> Thì vẫn tính là đang ở trong Card -> Không làm gì cả.
                if (card.contains(moveDestination)) return;

                // 2. Nếu chuột di chuyển sang cái Portal -> Kệ nó, để sự kiện của Portal lo.
                if (moveDestination && moveDestination.closest("#hover-portal")) return;

                // 3. [QUAN TRỌNG NHẤT] Hủy ngay lệnh "chuẩn bị hiện"
                // Đây là liều thuốc chữa bệnh "lướt nhanh vẫn hiện"
                clearTimeout(hoverTimeout);

                // 4. Nếu Portal ĐANG hiện cho card này rồi -> Đặt lệnh ẩn dần
                if (currentHoveredCard === card) {
                    hideTimeout = setTimeout(() => {
                        hidePortal();
                    }, 200);
                } else {
                    // Nếu Portal chưa hiện (đang đếm ngược) -> Reset biến luôn
                    currentHoveredCard = null;
                }
            });

            // --- [FIXED] LOGIC ẨN/HIỆN PORTAL MỚI ---

            // 2. Khi chuột VÀO Portal: Giữ yên, không ẩn
            // Dùng 'mouseenter' để không bị nháy khi di chuột qua các phần tử con trong Portal
            portal.addEventListener("mouseenter", () => {
                clearTimeout(hideTimeout);
                clearTimeout(hoverTimeout);
            });

            // 3. [FIX QUAN TRỌNG] Khi chuột RỜI Portal: Kích hoạt ẩn ngay
            // Sự kiện này bắt buộc phải có để Portal tự đóng khi chuột đi ra
            portal.addEventListener("mouseleave", () => {
                // Xóa timeout cũ để tránh xung đột
                clearTimeout(hideTimeout);

                // Đặt lệnh ẩn sau 200ms (đủ thời gian để quay lại nếu lỡ tay)
                hideTimeout = setTimeout(() => {
                    hidePortal();
                }, 200);
            });

            // 4. Backup: Khi chuột di chuyển bất kỳ đâu trên trang
            // Xử lý trường hợp chuột nhảy từ Card ra vùng trống (không qua Portal)
            document.addEventListener("mouseover", (e) => {
                const isOverCard = e.target.closest(".video-card");
                const isOverPortal = e.target.closest("#hover-portal");

                // Nếu chuột KHÔNG ở trên Card VÀ KHÔNG ở trên Portal
                if (!isOverCard && !isOverPortal) {
                    clearTimeout(hoverTimeout); // Hủy lệnh hiện (nếu đang chờ hiện)

                    // Nếu Portal đang hiện và chưa có lệnh ẩn nào được đặt -> Ẩn nó đi
                    if (portal.classList.contains("visible") && !hideTimeout) {
                        hideTimeout = setTimeout(() => {
                            hidePortal();
                        }, 200);
                    }
                }
            });

            /* --- HÀM 1: TẠO CARD VIDEO LẺ (Đã tích hợp thanh tiến độ) --- */
            function createVideoCardHtml(video) {
                // 1. Badge số tập
                const episodeBadge = video.episode ? `<div class="episode-badge">EP ${video.episode}</div>` : "";

                // 2. Thumbnail & Title
                const thumbUrl = video.thumbnailUrl || video.thumbnailUrl_auto;
                const title = video.userTitle || video.title;

                // 3. [QUAN TRỌNG] Logic vẽ thanh đỏ tiến độ
                const history = getWatchHistory(); // Gọi hàm lấy lịch sử
                const saved = history[video.videoId];
                let progressHtml = "";

                // Chỉ hiện nếu đã xem > 1% và chưa xong (< 95%)
                if (saved && saved.percent > 0.01 && !saved.isFinished) {
                    const percentStyle = Math.min(saved.percent * 100, 100);
                    progressHtml = `
            <div class="progress-bar-wrapper">
                <div class="watched-bar" style="width: ${percentStyle}%"></div>
            </div>
        `;
                }

                // 4. Trả về HTML (Chèn progressHtml vào trong card-image-wrapper)
                return `
    <div class="video-card" data-video-id="${video.videoId}">
        <div class="card-image-wrapper">
            ${episodeBadge}
            <img src="${thumbUrl}" alt="${title}" class="video-thumbnail" loading="lazy">
            ${progressHtml} 
        </div>
    </div>
    `;
            }

            /* --- HÀM 2: TẠO CARD CHƯƠNG TRÌNH/SERIES --- */
            function createProgramCardHtml(programName, videos) {
                // 1. Lấy tập mới nhất làm ảnh bìa
                videos.sort((a, b) => getVideoTimestamp(b) - getVideoTimestamp(a)); 
                const latest = videos[0];
                const thumbUrl = latest.thumbnailUrl || latest.thumbnailUrl_auto;
                const count = videos.length;

                // 2. Logic thanh tiến độ (Lấy của tập mới nhất user đang xem dở trong series này)
                // (Tuỳ chọn nâng cao: Bạn có thể tìm tập nào xem dở mới nhất để hiện)
                const history = getWatchHistory();
                const saved = history[latest.videoId]; // Tạm thời check tập mới nhất
                let progressHtml = "";

                if (saved && saved.percent > 0.01 && !saved.isFinished) {
                    const percentStyle = Math.min(saved.percent * 100, 100);
                    progressHtml = `
            <div class="progress-bar-wrapper">
                <div class="watched-bar" style="width: ${percentStyle}%"></div>
            </div>
        `;
                }

                // 3. Trả về HTML
                return `
    <div class="video-card program-card" data-program-name="${programName}">
        <div class="card-image-wrapper">
            <div class="episode-badge" style="background: var(--accent-color);">${count} Tập</div>
            <img src="${thumbUrl}" alt="${programName}" class="video-thumbnail" loading="lazy">
            ${progressHtml}
        </div>
    </div>
    `;
            }
            /* --- LOGIC RENDER MỚI: GROUP BY PROGRAM & CAROUSEL --- */

            // Helper: Lấy điểm thời gian (để sort)
            const getDateScore = (v) => {
                if (v.uploadDate_auto) return new Date(v.uploadDate_auto).getTime();
                return 0;
            };

            /* --- LOGIC RENDER MỚI: CHUẨN SERIES (GOM GỌN) --- */
            function renderVideoRows(videoArray) {
                libraryContainer.innerHTML = ""; // Reset

                // [THÊM LOGIC RENDER HÀNG CONTINUE WATCHING]
                const history = getWatchHistory();
                // Lấy danh sách ID các video đang xem dở (chưa finish)
                const continueList = Object.values(history)
                    .filter((item) => !item.isFinished && item.percent > 0.01)
                    .sort((a, b) => b.lastUpdated - a.lastUpdated); // Mới xem nhất xếp trước

                if (continueList.length > 0) {
                    // Map từ history item sang video object đầy đủ
                    const continueVideos = [];
                    continueList.forEach((h) => {
                        const vid = videoArray.find((v) => v.videoId === h.videoId);
                        if (vid) continueVideos.push(vid);
                    });

                    if (continueVideos.length > 0) {
                        // Tạo hàng "Xem tiếp"
                        const cards = continueVideos.map((v) => createVideoCardHtml(v));
                        createCarouselSection("👀 Xem tiếp", cards);
                    }
                }

                if (!videoArray || videoArray.length === 0) {
                    libraryContainer.innerHTML = `<p style="text-align: center; margin-top: 50px; color: #777;">Chưa có nội dung.</p>`;
                    return;
                }

                // --- BƯỚC 1: PHÂN LOẠI DỮ LIỆU ---
                const programsMap = {}; // Chứa các Series (có tên program)
                const participantsMap = {}; // Chứa Idol
                const genresMap = {}; // Chứa Thể loại
                const singles = []; // Video lẻ (không thuộc program nào)

                videoArray.forEach((video) => {
                    // 1. Gom Program
                    if (video.program) {
                        if (!programsMap[video.program]) programsMap[video.program] = [];
                        programsMap[video.program].push(video);
                    } else {
                        singles.push(video);
                    }

                    // 2. Gom Participants
                    if (video.participants && Array.isArray(video.participants)) {
                        video.participants.forEach((person) => {
                            if (!participantsMap[person]) participantsMap[person] = [];
                            participantsMap[person].push(video);
                        });
                    }

                    // 3. Gom Genre
                    if (video.genres && Array.isArray(video.genres)) {
                        video.genres.forEach((g) => {
                            if (!genresMap[g]) genresMap[g] = [];
                            genresMap[g].push(video);
                        });
                    }
                });

                // --- BƯỚC 2: RENDER GIAO DIỆN ---

                // 1. HÀNG: MỚI PHÁT HÀNH (Video lẻ hoặc tập mới nhất)
                const latestVideos = [...videoArray]
                    .sort((a, b) => getVideoTimestamp(b) - getVideoTimestamp(a))
                    .slice(0, 10);
                // Ở hàng này vẫn hiện video lẻ để người dùng biết có cái mới
                createCarouselSection(
                    "🔥 Mới phát hành",
                    latestVideos.map((v) => createVideoCardHtml(v))
                );

                // 2. [QUAN TRỌNG] HÀNG: SERIES & CHƯƠNG TRÌNH (GOM GỌN)
                // Thay vì tạo mỗi program 1 hàng, ta tạo 1 hàng chứa TẤT CẢ program
                const programCardsHtml = [];
                Object.keys(programsMap).forEach((progName) => {
                    const videos = programsMap[progName];
                    // Chỉ coi là Series nếu có >= 2 tập HOẶC có tên program rõ ràng
                    if (videos.length >= 1) {
                        // Gọi hàm tạo Card Series (đã thêm ở trên)
                        programCardsHtml.push(createProgramCardHtml(progName, videos));
                    }
                });

                if (programCardsHtml.length > 0) {
                    createCarouselSection("📺 Series & Chương trình", programCardsHtml);
                }

                // 3. HÀNG: IDOL / DIỄN VIÊN (Vẫn hiện video lẻ để chọn xem ngay)
                Object.keys(participantsMap).forEach((person) => {
                    const videos = participantsMap[person];
                    if (videos.length >= 2) {
                        const uniqueVideos = [...new Set(videos)];
                        // Logic: Nếu muốn hiện Card Series trong hàng Idol thì dùng createProgramCardHtml
                        // Nhưng thường user muốn xem Idol diễn tập nào, nên để Video Card là hợp lý
                        const cards = uniqueVideos.map((v) => createVideoCardHtml(v));
                        createCarouselSection(`Tuyển tập ${person}`, cards);
                    }
                });

                // 4. HÀNG: THỂ LOẠI
                Object.keys(genresMap).forEach((genre) => {
                    if (programsMap[genre] || participantsMap[genre]) return; // Tránh trùng
                    const videos = genresMap[genre];
                    if (videos.length >= 2) {
                        const cards = videos.map((v) => createVideoCardHtml(v));
                        createCarouselSection(`Thể loại: ${genre}`, cards);
                    }
                });
            }

            /* --- HÀM TẠO CAROUSEL CÓ MŨI TÊN --- */
            /* --- HÀM TẠO CAROUSEL VỚI MŨI TÊN THÔNG MINH --- */
            function createCarouselSection(title, cardsHtmlArray) {
                if (cardsHtmlArray.length === 0) return;
                const section = document.createElement("section");
                section.className = "program-row";

                section.innerHTML = `
        <h2 class="program-title">${title}</h2>
        <div class="list-wrapper">
            <button class="scroll-btn left hidden-arrow"> <svg viewBox="0 0 24 24"><path d="M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z"/></svg>
            </button>
            
            <div class="video-list">
                ${cardsHtmlArray.join("")}
            </div>

            <button class="scroll-btn right">
                <svg viewBox="0 0 24 24"><path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"/></svg>
            </button>
        </div>
    `;

                const list = section.querySelector(".video-list");
                const btnLeft = section.querySelector(".scroll-btn.left");
                const btnRight = section.querySelector(".scroll-btn.right");

                // --- [MỚI] Hàm kiểm tra ẩn/hiện mũi tên ---
                const checkArrows = () => {
                    const scrollLeft = list.scrollLeft;
                    const maxScroll = list.scrollWidth - list.clientWidth;

                    // 1. Nút Trái: Ẩn nếu đang ở sát lề trái (scrollLeft <= 0)
                    if (scrollLeft <= 10) {
                        // Dư ra 10px cho chắc
                        btnLeft.classList.add("hidden-arrow");
                    } else {
                        btnLeft.classList.remove("hidden-arrow");
                    }

                    // 2. Nút Phải: Ẩn nếu đã cuộn hết sang phải
                    if (scrollLeft >= maxScroll - 10) {
                        btnRight.classList.add("hidden-arrow");
                    } else {
                        btnRight.classList.remove("hidden-arrow");
                    }
                };

                // Gọi kiểm tra ngay lập tức và mỗi khi cuộn
                // Timeout nhỏ để đợi render layout xong mới tính chính xác
                setTimeout(checkArrows, 100);
                list.addEventListener("scroll", checkArrows);
                window.addEventListener("resize", checkArrows); // Check lại khi co giãn màn hình

                // --- Logic Click ---
                btnLeft.onclick = () => {
                    list.scrollBy({ left: -window.innerWidth * 0.8, behavior: "smooth" });
                };

                btnRight.onclick = () => {
                    list.scrollBy({ left: window.innerWidth * 0.8, behavior: "smooth" });
                };

                // Logic lăn chuột
                list.addEventListener(
                    "wheel",
                    (evt) => {
                        if (list.scrollWidth > list.clientWidth) {
                            evt.preventDefault();
                            list.scrollLeft += evt.deltaY * 8;
                        }
                    },
                    { passive: false }
                );

                libraryContainer.appendChild(section);
            }

            // Hàm tạo HTML thẻ Program (Khác thẻ Video một chút)
            function createProgramCard(program) {
                const video = program.thumbnailVideo; // Dùng video mới nhất làm ảnh bìa
                const thumbUrl = video.thumbnailUrl || video.thumbnailUrl_auto;
                // Hiển thị số lượng tập
                const episodeCount = program.videos.length;
                const badge = `<div class="episode-badge">${episodeCount} Tập</div>`;
                const displayGenre = program.genres.size > 0 ? Array.from(program.genres)[0] : "";

                // Lưu program-name vào data attribute để click handler xử lý
                return `
    <div class="video-card program-card" data-program-name="${program.title}">
        <div class="card-image-wrapper">
            ${badge}
            <img src="${thumbUrl}" alt="${program.title}" class="video-thumbnail" loading="lazy">
        </div>
       
    </div>
    `;
            }
            /* ========================================= */
            /* START: HERO SLIDER LOGIC (REFINED)        */
            /* ========================================= */

            let heroTimer;
            let currentHeroIndex = 1; // Bắt đầu từ 1 vì có Clone đầu
            let isHeroTransitioning = false;
            let totalHeroSlides = 0; // Tổng số slide (bao gồm clones)

            function setupHeroSlider(videos) {
                const heroSection = document.getElementById("hero-section");
                if (!heroSection || videos.length === 0) return;

                // 1. Clone Loop Logic
                // Tạo Clone cuối vào đầu, và Clone đầu vào cuối
                const firstClone = videos[0];
                const lastClone = videos[videos.length - 1];
                const displayList = [lastClone, ...videos, firstClone];
                totalHeroSlides = displayList.length;

                // 2. Render HTML Slide
                let html = `<div class="hero-track" style="transform: translateX(-100%)">`;

                displayList.forEach((video, index) => {
                    const isActive = index === 1 ? "active" : "";
                    const thumbUrl = (video.thumbnailUrl || video.thumbnailUrl_auto).replace("hqdefault", "maxresdefault");
                    const programName = video.program ? `<div class="hero-program">${video.program}</div>` : "";
                    
                    // FIX 3: Đổi Text Badge
                    const badgeText = "Nổi bật"; 

                    html += `
                        <div class="hero-slide ${isActive}" data-index="${index}">
                            <div class="hero-bg-wrapper">
                                <img src="${thumbUrl}" class="hero-bg" alt="bg">
                            </div>
                            <div class="hero-overlay"></div>
                            <div class="hero-content">
                                <span class="hero-badge">${badgeText}</span>
                                ${programName}
                                <h1 class="hero-title">${video.userTitle || video.title}</h1>
                                <div class="hero-actions">
                                    <button class="hero-btn hero-btn-primary" onclick="launchPlayerByVideoId('${video.videoId}')">
                                        <svg viewBox="0 0 24 24" width="24" height="24"><path d="M8,5.14V19.14L19,12.14L8,5.14Z" fill="currentColor"/></svg>
                                        Phát ngay
                                    </button>
                                    <button class="hero-btn hero-btn-secondary" onclick="openDetailModalByVideoId('${video.videoId}')">
                                        <svg viewBox="0 0 24 24" width="24" height="24" fill="#fff"><path d="M11,9H13V7H11M11,20H13V11H11M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" /></svg>
                                        Thông tin
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                });
                html += `</div>`; // Đóng track

                // 3. Render Mũi tên
                html += `
                    <button class="hero-nav-btn prev" onclick="moveHeroSlide(-1)">
                        <svg viewBox="0 0 24 24"><path d="M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z"/></svg>
                    </button>
                    <button class="hero-nav-btn next" onclick="moveHeroSlide(1)">
                        <svg viewBox="0 0 24 24"><path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"/></svg>
                    </button>
                `;

                // 4. FIX 4: Render Ảnh Nhỏ (Thumbnails) thay vì chấm tròn
                html += `<div class="hero-thumb-nav">`;
                videos.forEach((video, i) => {
                    const thumbSmall = video.thumbnailUrl || video.thumbnailUrl_auto;
                    html += `
                        <div class="hero-thumb-item ${i === 0 ? "active" : ""}" onclick="goToHeroSlide(${i + 1})">
                            <img src="${thumbSmall}" alt="thumb">
                        </div>
                    `;
                });
                html += `</div>`;

                heroSection.innerHTML = html;
                const firstVideo = videos[0];
    const firstThumb = (firstVideo.thumbnailUrl || firstVideo.thumbnailUrl_auto).replace("hqdefault", "maxresdefault");
    applyThemeFromImage(firstThumb);

                // Khởi động
                startHeroTimer();
                
                // Parallax Effect
                window.addEventListener("scroll", handleHeroParallax);
                
                // Dừng auto khi chuột vào để dễ đọc, rời ra thì chạy tiếp
                heroSection.addEventListener("mouseenter", () => clearInterval(heroTimer));
                heroSection.addEventListener("mouseleave", startHeroTimer);
            }

            function startHeroTimer() {
                clearInterval(heroTimer);
                heroTimer = setInterval(() => {
                    moveHeroSlide(1, true); // True = auto move
                }, 6000); 
            }
            
            function moveHeroSlide(direction, isAuto = false) {
                if (isHeroTransitioning) return;

                // FIX 1: Nếu người dùng tự bấm (không phải auto), reset timer ngay lập tức
                // Để tránh việc vừa bấm xong thì timer cũ kích hoạt gây nhảy hình/đen hình
                if (!isAuto) startHeroTimer();

                const track = document.querySelector(".hero-track");
                const slides = document.querySelectorAll(".hero-slide");
                const thumbs = document.querySelectorAll(".hero-thumb-item");

                if (!track || slides.length === 0) return;

                isHeroTransitioning = true;
                currentHeroIndex += direction;

                track.style.transition = "transform 0.7s cubic-bezier(0.25, 1, 0.5, 1)";
                track.style.transform = `translateX(-${currentHeroIndex * 100}%)`;

                // Update class active cho slide (để chạy animation chữ)
                slides.forEach(s => s.classList.remove("active"));
                if (slides[currentHeroIndex]) {
                const activeSlide = slides[currentHeroIndex];
                activeSlide.classList.add("active");
                
                // [FIX MỚI] Reset vị trí ảnh ngay khi slide hiện lên
                resetParallaxForSlide(activeSlide); 
                 const bgImg = activeSlide.querySelector(".hero-bg");
    if (bgImg) {
        // Gọi hàm đổi màu
        applyThemeFromImage(bgImg.src);
    }
            }

                // Xử lý Infinite Loop khi animation kết thúc
                track.ontransitionend = () => {
                    isHeroTransitioning = false;
                    track.ontransitionend = null; // Clear event để tránh gọi lặp

                    // Nếu đi quá slide cuối (vào Clone đầu) -> Nhảy về Slide 1 thật
                    if (currentHeroIndex >= totalHeroSlides - 1) {
                        track.style.transition = "none"; 
                        currentHeroIndex = 1;
                        track.style.transform = `translateX(-${currentHeroIndex * 100}%)`;
                        // Re-add active class
                        slides.forEach(s => s.classList.remove("active"));
                        slides[currentHeroIndex].classList.add("active");
                    }
                    // Nếu đi lùi quá slide đầu (vào Clone cuối) -> Nhảy về Slide cuối thật
                    else if (currentHeroIndex <= 0) {
                        track.style.transition = "none";
                        currentHeroIndex = totalHeroSlides - 2;
                        track.style.transform = `translateX(-${currentHeroIndex * 100}%)`;
                        // Re-add active class
                        slides.forEach(s => s.classList.remove("active"));
                        slides[currentHeroIndex].classList.add("active");
                    }

                    // Update Thumbnails Active State
                    updateActiveThumb(thumbs);
                };
            }

            function goToHeroSlide(index) {
                if (index === currentHeroIndex || isHeroTransitioning) return;
                
                // FIX 1: Reset timer khi click chọn ảnh
                startHeroTimer();

                const track = document.querySelector(".hero-track");
                const slides = document.querySelectorAll(".hero-slide");
                const thumbs = document.querySelectorAll(".hero-thumb-item");

                currentHeroIndex = index;
                isHeroTransitioning = true;

                track.style.transition = "transform 0.7s cubic-bezier(0.25, 1, 0.5, 1)";
                track.style.transform = `translateX(-${currentHeroIndex * 100}%)`;

                slides.forEach(s => s.classList.remove("active"));
                if (slides[currentHeroIndex]) {
                const activeSlide = slides[currentHeroIndex];
                activeSlide.classList.add("active");
                
                // [FIX MỚI] Reset vị trí ảnh ngay khi slide hiện lên
                resetParallaxForSlide(activeSlide);
            }
                
                // Khi click trực tiếp, ta update thumb ngay (hoặc đợi transitionEnd tùy ý, ở đây update luôn cho nhanh)
                updateActiveThumb(thumbs);
                
                track.ontransitionend = () => {
                    isHeroTransitioning = false;
                    track.ontransitionend = null;
                };
            }

            function updateActiveThumb(thumbs) {
                // Tính toán index thật (trừ đi 1 do clone đầu)
                let realIndex = currentHeroIndex - 1;
                // Xử lý biên (nếu đang ở clone)
                if (realIndex < 0) realIndex = thumbs.length - 1;
                if (realIndex >= thumbs.length) realIndex = 0;

                thumbs.forEach(t => t.classList.remove("active"));
                if (thumbs[realIndex]) thumbs[realIndex].classList.add("active");
            }
            // Hàm này sẽ đưa ảnh nền về vị trí 0 (chuẩn) ngay lập tức
function resetParallaxForSlide(slideElement) {
    const bg = slideElement.querySelector(".hero-bg");
    if (bg) {
        // Xóa inline style transform do parallax tạo ra
        bg.style.transform = ""; 
        // Hoặc set cứng về 0 nếu muốn chắc chắn hơn:
        // bg.style.transform = "translate3d(0, 0, 0)";
    }
}
            // [PARALLAX] Fix nhẹ: kiểm tra phần tử tồn tại trước khi style
            function handleHeroParallax() {
                if (!isParallaxTicking) {
                    window.requestAnimationFrame(() => {
                        const scrollY = window.scrollY;
                        // Chỉ tính toán khi đang ở trong vùng Hero (70vh ~ 700px)
                        if (scrollY <= window.innerHeight) {
                            const activeSlideBg = document.querySelector(".hero-slide.active .hero-bg");
                            if (activeSlideBg) {
                                // Di chuyển ảnh xuống 1 nửa tốc độ cuộn
                                activeSlideBg.style.transform = `translate3d(0, ${scrollY * 0.5}px, 0)`;
                            }
                        }
                        isParallaxTicking = false;
                    });
                    isParallaxTicking = true;
                }
            }
            // Helper: Gọi player từ ID (do button trong HTML string không truyền obj được)
            function launchPlayerByVideoId(vid) {
                const video = libraryData.find((v) => v.videoId === vid);
                if (video) launchPlayer(video);
            }
            function openDetailModalByVideoId(vid) {
                const video = libraryData.find((v) => v.videoId === vid);
                if (video) {
                    if (video.program) {
                        const eps = libraryData
                            .filter((v) => v.program === video.program)
                            .sort((a, b) => getVideoTimestamp(b) - getVideoTimestamp(a)); 
                        openDetailModal(video, eps);
                    } else {
                        openDetailModal(video, null);
                    }
                }
            }
            // --- Event Handling ---

function setupEventListeners() {
    // --- 1. SCROLL HEADER ---
    const header = document.getElementById("page-header");
    window.addEventListener("scroll", () => {
        if (window.scrollY > 50) header.classList.add("scrolled");
        else header.classList.remove("scrolled");
        hidePortal(true);
        clearTimeout(hoverTimeout);
    });

    // --- 2. FIX TÌM KIẾM (SEARCH) ---
    const searchWrapper = document.getElementById("search-box-wrapper");
    const searchTrigger = document.getElementById("search-trigger-btn");
    const searchClear = document.getElementById("search-clear-btn");
    const searchInput = document.getElementById("search-input");
    const pageHeader = document.getElementById("page-header");

    // Click icon kính lúp
    searchTrigger.addEventListener("click", (e) => {
        e.stopPropagation(); // Ngăn chặn sự kiện click lan ra document
        
        // Toggle class active
        const isActive = searchWrapper.classList.toggle("active");

        if (isActive) {
            pageHeader.classList.add("search-active");
            // Chờ animation CSS 1 chút rồi focus để bàn phím ảo (mobile) hiện lên
            setTimeout(() => {
                searchInput.focus(); 
            }, 100);
        } else {
            // Chỉ đóng nếu rỗng
            if (searchInput.value.trim() === "") {
                pageHeader.classList.remove("search-active");
                searchInput.blur();
            }
        }
    });

    // Click nút X (Clear)
    // Click nút X (Clear)
    searchClear.addEventListener("click", (e) => {
        e.stopPropagation();
        searchInput.value = "";
        searchInput.focus();
        
        // [MỚI] Hiện lại Hero và ẩn gợi ý
        const heroSection = document.getElementById("hero-section");
        const suggestionsBox = document.getElementById("search-suggestions");
        if(heroSection) heroSection.classList.remove("hidden");
        if(suggestionsBox) suggestionsBox.classList.remove("visible");

        // Render lại trang chủ
        renderVideoRows(libraryData);
        
        searchClear.classList.remove("visible");
    });

// [CẬP NHẬT] Nhập liệu tìm kiếm
    searchInput.addEventListener("input", () => {
        const val = searchInput.value.trim();
        const heroSection = document.getElementById("hero-section");
        const suggestionsBox = document.getElementById("search-suggestions");
        const clearBtn = document.getElementById("search-clear-btn");

        if (val.length > 0) {
            // 1. Hiện nút X và ẨN HERO SECTION
            clearBtn.classList.add("visible");
            if(heroSection) heroSection.classList.add("hidden"); 

            // 2. LOGIC AUTOCOMPLETE (GỢI Ý)
            const keyword = toNonAccentVietnamese(val);
            suggestionsBox.innerHTML = ""; // Xóa gợi ý cũ
            
            // Tìm kiếm: Lấy cả Program (Series) lẫn Video lẻ
            // A. Lọc Program trùng tên
            const matchedPrograms = [];
            const programSet = new Set();
            
            libraryData.forEach(v => {
                if(v.program) {
                    const pNameNorm = toNonAccentVietnamese(v.program);
                    if(pNameNorm.includes(keyword) && !programSet.has(v.program)) {
                        programSet.add(v.program);
                        matchedPrograms.push({
                            type: 'Series',
                            title: v.program,
                            thumb: v.thumbnailUrl || v.thumbnailUrl_auto,
                            data: v // Lấy video này làm đại diện để click vào
                        });
                    }
                }
            });

            // B. Lọc Video lẻ hoặc Video có tiêu đề khớp
            const matchedVideos = libraryData.filter(v => {
                const titleNorm = toNonAccentVietnamese(v.userTitle || v.title);
                // Chỉ lấy nếu tiêu đề khớp, và không phải là video đã đại diện cho program ở trên (để đỡ trùng lặp quá nhiều)
                return titleNorm.includes(keyword);
            }).map(v => ({
                type: 'Video',
                title: v.userTitle || v.title,
                thumb: v.thumbnailUrl || v.thumbnailUrl_auto,
                data: v
            }));

            // Gộp lại (Series lên trước, Video sau), lấy tối đa 5-7 kết quả
            const allSuggestions = [...matchedPrograms, ...matchedVideos].slice(0, 7);

            if (allSuggestions.length > 0) {
                suggestionsBox.classList.add("visible");
                
                allSuggestions.forEach(item => {
                    const div = document.createElement("div");
                    div.className = "suggestion-item";
                    div.innerHTML = `
                        <img src="${item.thumb}" class="suggestion-thumb" loading="lazy">
                        <div class="suggestion-info">
                            <span class="suggestion-title">${item.title}</span>
                            <span class="suggestion-type">${item.type}</span>
                        </div>
                    `;
                    
                    // Sự kiện click vào gợi ý
                    div.onclick = (e) => {
                        e.stopPropagation();
                        // 1. Điền text vào ô input
                        searchInput.value = item.title;
                        // 2. Ẩn gợi ý
                        suggestionsBox.classList.remove("visible");
                        // 3. Thực hiện lọc trang chủ
                        handleSearchAndFilter();
                        // 4. Nếu là Series, có thể mở luôn Modal (tùy chọn), ở đây ta chỉ lọc ra Grid View
                    };
                    suggestionsBox.appendChild(div);
                });
            } else {
                suggestionsBox.classList.remove("visible");
            }
            
            // Gọi hàm lọc chính của trang (để render Grid View bên dưới)
            handleSearchAndFilter();

        } else {
            // Rỗng -> Ẩn nút X, HIỆN LẠI HERO, Ẩn gợi ý, Về trang chủ
            clearBtn.classList.remove("visible");
            if(heroSection) heroSection.classList.remove("hidden");
            suggestionsBox.classList.remove("visible");
            
            renderVideoRows(libraryData);
        }
    });

    // Bổ sung: Ẩn gợi ý khi click ra ngoài
    document.addEventListener("click", (e) => {
        const suggestionsBox = document.getElementById("search-suggestions");
        const searchWrapper = document.getElementById("search-box-wrapper");
        if (!searchWrapper.contains(e.target)) {
            suggestionsBox.classList.remove("visible");
        }
    });
    // Click ra ngoài để đóng tìm kiếm
    document.addEventListener("click", (e) => {
        // Nếu click KHÔNG nằm trong searchWrapper VÀ searchWrapper đang mở
        if (searchWrapper.classList.contains("active") && !searchWrapper.contains(e.target)) {
            // Chỉ đóng nếu input rỗng
            if (searchInput.value.trim() === "") {
                searchWrapper.classList.remove("active");
                searchClear.classList.remove("visible");
                pageHeader.classList.remove("search-active");
                searchInput.blur();
            }
        }
    });

    // --- 3. FIX CLICK LIST TRONG MODAL (RELATED CONTENT) ---
    // [QUAN TRỌNG] Thêm lắng nghe sự kiện cho danh sách "Có thể bạn sẽ thích"
    const relatedList = document.getElementById("modal-related-list");
    if (relatedList) {
        relatedList.addEventListener("click", (e) => {
            // Tái sử dụng hàm handleCardClick có sẵn
            // Vì handleCardClick dựa vào e.target.closest('.video-card') nên dùng lại được luôn
            handleCardClick(e); 
            
            // Tùy chọn: Cuộn modal lên đầu sau khi bấm chuyển phim
            document.getElementById("detail-modal-content").scrollTop = 0;
        });
    }

    // --- 4. CLICK LIBRARY CHÍNH ---
    const libraryContainer = document.getElementById("library-container");
    libraryContainer.addEventListener("click", handleCardClick);
    
    // --- 5. SỰ KIỆN HOVER/SCROLL (Giữ nguyên logic cũ) ---
    const videoLists = document.querySelectorAll(".video-list");
    videoLists.forEach((list) => {
        list.addEventListener("wheel", (evt) => {
            if (list.scrollWidth > list.clientWidth) {
                evt.preventDefault();
                list.scrollLeft += evt.deltaY * 5;
            }
        }, { passive: false });
    });
    
    // Scroll cho list tập trong Modal
    const modalEpList = document.getElementById("modal-episodes-list");
    if (modalEpList) {
        modalEpList.addEventListener("wheel", (evt) => {
            if (modalEpList.scrollWidth > modalEpList.clientWidth) {
                evt.preventDefault();
                modalEpList.scrollLeft += evt.deltaY * 3;
            }
        }, { passive: false });
    }
    
    // Scroll cho list Related trong Modal
    if (relatedList) {
        relatedList.addEventListener("wheel", (evt) => {
            if (relatedList.scrollWidth > relatedList.clientWidth) {
                 evt.preventDefault();
                 relatedList.scrollLeft += evt.deltaY * 3;
            }
        }, { passive: false });
    }

    // --- 6. PORTAL HOVER EVENTS ---
    libraryContainer.addEventListener("mouseover", (e) => {
        const isDesktop = window.matchMedia("(hover: hover) and (pointer: fine)").matches && window.innerWidth > 1024;
        if (!isDesktop) return;

        const card = e.target.closest(".video-card");
        if (!card) return;

        clearTimeout(hideTimeout);
        if (currentHoveredCard === card) return;
        clearTimeout(hoverTimeout);

        hoverTimeout = setTimeout(() => {
            currentHoveredCard = card;
            let videoData;
            let isProgramCard = false;

            if (card.dataset.programName) {
                isProgramCard = true;
                const videos = libraryData.filter((v) => v.program === card.dataset.programName)
                                          .sort((a, b) => getVideoTimestamp(b) - getVideoTimestamp(a)); 
                videoData = videos[0];
            } else if (card.dataset.videoId) {
                isProgramCard = false;
                videoData = libraryData.find((v) => v.videoId === card.dataset.videoId);
            }

            if (videoData) {
                showPortal(card, videoData, isProgramCard);
            }
        }, 200);
    });

    libraryContainer.addEventListener("mouseout", (e) => {
        const card = e.target.closest(".video-card");
        if (!card) return;
        const moveDestination = e.relatedTarget;
        if (card.contains(moveDestination)) return;
        if (moveDestination && moveDestination.closest("#hover-portal")) return;

        clearTimeout(hoverTimeout);
        if (currentHoveredCard === card) {
            hideTimeout = setTimeout(() => hidePortal(), 200);
        } else {
            currentHoveredCard = null;
        }
    });

    // Portal Mouse Events
    const portal = document.getElementById("hover-portal");
    portal.addEventListener("mouseenter", () => {
        clearTimeout(hideTimeout);
        clearTimeout(hoverTimeout);
    });
    portal.addEventListener("mouseleave", () => {
        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(() => hidePortal(), 200);
    });
    portal.addEventListener("wheel", (e) => {
        if (!currentHoveredCard) return;
        const list = currentHoveredCard.closest(".video-list");
        if (list) {
            e.preventDefault();
            list.scrollLeft += e.deltaY * 8;
            hidePortal();
        }
    }, { passive: false });


    // --- 7. PLAYER & MODAL BUTTONS (Back, Close, etc.) ---
    document.getElementById("back-btn").addEventListener("click", goHome);
    
    // Add Video Modal
    const addVideoBtn = document.getElementById("add-video-btn");
    const addVideoModalOverlay = document.getElementById("add-video-modal-overlay");
    const addVideoCloseBtn = document.getElementById("add-video-close-btn");
    const addVideoForm = document.getElementById("add-video-form");
    const srtFileInput = document.getElementById("srt-file-input");
    const srtFileName = document.getElementById("srt-file-name");

    addVideoBtn.addEventListener("click", () => openModal(addVideoModalOverlay));
    addVideoCloseBtn.addEventListener("click", () => closeModal(addVideoModalOverlay));
    addVideoModalOverlay.addEventListener("click", (e) => {
        if (e.target === addVideoModalOverlay) closeModal(addVideoModalOverlay);
    });
    addVideoForm.addEventListener("submit", handleAddVideoSubmit);
    srtFileInput.addEventListener("change", () => {
        srtFileName.textContent = srtFileInput.files.length > 0 ? srtFileInput.files[0].name : "";
    });

    // Detail Modal Close
    const detailModalOverlay = document.getElementById("detail-modal-overlay");
    const detailModalCloseBtn = document.getElementById("detail-modal-close-btn");
    detailModalCloseBtn.addEventListener("click", () => closeModal(detailModalOverlay));
    detailModalOverlay.addEventListener("click", (e) => {
        if (e.target === detailModalOverlay) closeModal(detailModalOverlay);
    });
    document.getElementById("modal-play-btn").addEventListener("click", handleModalPlay);

    // Teaser Volume
    document.getElementById("teaser-volume-btn").addEventListener("click", (e) => {
        e.stopPropagation();
        isTeaserMuted = !isTeaserMuted;
        updateVolumeUI();
    });

    // --- 8. PLAYER CONTROLS ---
    // Play/Pause Center
    document.getElementById("center-play-pause-btn").addEventListener("click", (e) => {
        e.stopPropagation();
        togglePlayPause();
    });
    // Play/Pause Bottom
    document.getElementById("play-pause-btn").addEventListener("click", togglePlayPause);
    // Seek
    document.getElementById("progress-bar").addEventListener("input", handleSeek);
    // Interaction Overlay
    document.getElementById("interaction-overlay").addEventListener("pointerup", handleInteraction);
    // Show controls on move
    document.getElementById("player-container").addEventListener("pointermove", (e) => {
        if (e.pointerType === "mouse") showControlsAndSetHideTimeout();
    });
    
    // Skip Button
    document.getElementById("skip-btn").addEventListener("click", handleSkipClick);
    
    // Keyboard
    document.addEventListener("keydown", handleKeyboardShortcuts);
    
    // Fullscreen
    document.addEventListener("fullscreenchange", () => {
        if (!document.fullscreenElement) goHome();
    });
    
    // Drag Drop Subtitle
    document.body.addEventListener("dragover", (e) => {
        if (document.getElementById("player-wrapper").classList.contains("hidden")) return;
        e.preventDefault();
        e.dataTransfer.dropEffect = "copy";
    });
    document.body.addEventListener("drop", (e) => {
        if (document.getElementById("player-wrapper").classList.contains("hidden")) return;
        e.preventDefault();
        handleFileDrop(e);
    });

    // --- 9. PLAYER EXTRA BUTTONS (Next, CC, Speed, EpList, Settings) ---
    // Nút Next
    const nextEpBtn = document.getElementById("next-ep-btn");
    if (nextEpBtn) {
        nextEpBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            handleVideoEnd(true);
        });
    }
    // Nút CC
    const ccBtn = document.getElementById("cc-toggle-btn");
    if (ccBtn) {
        ccBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            const subDisplay = document.getElementById("subtitle-display");
            if (subDisplay.style.display === "none") {
                subDisplay.style.display = "block";
                ccBtn.classList.remove("off");
            } else {
                subDisplay.style.display = "none";
                ccBtn.classList.add("off");
            }
        });
    }
    // Nút Speed
    const speedBtn = document.getElementById("speed-btn");
    if (speedBtn) {
        speedBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            toggleFloatingMenu("speed-menu");
        });
    }
    // Speed Items
    document.querySelectorAll(".speed-item").forEach(item => {
        item.addEventListener("click", (e) => {
            const speed = parseFloat(e.target.dataset.speed);
            if (player && typeof player.setPlaybackRate === 'function') player.setPlaybackRate(speed);
            document.querySelectorAll(".speed-item").forEach(b => b.classList.remove("active"));
            e.target.classList.add("active");
            toggleFloatingMenu("speed-menu");
        });
    });
    // Episode List Sidebar
    const episodesBtn = document.getElementById("episodes-btn");
    episodesBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        toggleFloatingMenu("episodes-sidebar");
    });
    const closeEpisodesBtn = document.getElementById("close-episodes-btn");
    if (closeEpisodesBtn) {
        closeEpisodesBtn.addEventListener("click", () => {
            document.getElementById("episodes-sidebar").classList.remove("visible");
            episodesBtn.classList.remove("active");
        });
    }
    // Settings
    const settingsBtn = document.getElementById("settings-btn");
    settingsBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        toggleFloatingMenu("settings-menu");
    });

    // Close floating menus on click outside
    document.getElementById("player-container").addEventListener("click", (e) => {
        const clickedMenu = e.target.closest(".floating-menu");
        const clickedBtn = e.target.closest(".icon-btn");
        if (!clickedMenu && !clickedBtn) {
            const menus = document.querySelectorAll(".floating-menu.visible");
            menus.forEach(menu => {
                menu.classList.remove("visible");
                setTimeout(() => { if (!menu.classList.contains("visible")) menu.style.display = "none"; }, 300);
            });
            settingsBtn.classList.remove("active");
            episodesBtn.classList.remove("active");
        }
    });

    // Setting Sliders
    document.getElementById("font-size-slider").addEventListener("input", (e) => {
        subtitleSettings.fontSize = e.target.value;
        applyAndSaveSubtitleStyles();
    });
    document.getElementById("font-color-picker").addEventListener("input", (e) => {
        subtitleSettings.fontColor = e.target.value;
        applyAndSaveSubtitleStyles();
    });
    document.getElementById("bg-color-picker").addEventListener("input", (e) => {
        subtitleSettings.bgColor = e.target.value;
        applyAndSaveSubtitleStyles();
    });
    document.getElementById("bg-opacity-slider").addEventListener("input", (e) => {
        subtitleSettings.bgOpacity = e.target.value;
        applyAndSaveSubtitleStyles();
    });

    // --- 10. MOBILE DRAG MODAL ---
    const mobileModals = [document.getElementById("detail-modal-content"), document.getElementById("add-video-modal-content")];
    mobileModals.forEach(content => {
        if (!content) return;
        let startY = 0; let currentY = 0; let isDragging = false;
        if (!content.querySelector(".modal-drag-handle")) {
            const handle = document.createElement("div");
            handle.className = "modal-drag-handle";
            content.insertBefore(handle, content.firstChild);
        }
        content.addEventListener("touchstart", (e) => {
            if (content.scrollTop <= 0) {
                startY = e.touches[0].clientY;
                isDragging = true;
                content.classList.remove("snapping");
            }
        }, { passive: true });
        content.addEventListener("touchmove", (e) => {
            if (!isDragging) return;
            const delta = e.touches[0].clientY - startY;
            if (delta > 0) {
                if (e.cancelable) e.preventDefault();
                content.style.transform = `translateY(${delta}px)`;
                currentY = delta;
            }
        }, { passive: false });
        content.addEventListener("touchend", () => {
            if (!isDragging) return;
            isDragging = false;
            content.classList.add("snapping");
            if (currentY > 150) {
                const parentOverlay = content.closest(".modal-overlay");
                closeModal(parentOverlay);
                setTimeout(() => { content.style.transform = ""; }, 300);
            } else {
                content.style.transform = "";
            }
            currentY = 0;
        });
    });
}
            // 3. Hàm logic mới
            function toggleEpisodesSidebar() {
                const isVisible = episodesSidebar.classList.contains("visible");
                if (isVisible) {
                    episodesSidebar.classList.remove("visible");
                } else {
                    renderEpisodeList();
                    episodesSidebar.classList.add("visible");
                }
            }

            function renderEpisodeList() {
                episodesContent.innerHTML = "";

                // Nếu không có video đang phát hoặc không thuộc chương trình nào -> Báo lỗi hoặc ẩn
                if (!currentVideoData || !currentVideoData.program) {
                    episodesContent.innerHTML =
                        "<p style='padding:20px; text-align:center; color:#777'>Không có danh sách tập.</p>";
                    return;
                }

                // Lọc các tập cùng chương trình
                const episodes = libraryData
                    .filter((v) => v.program === currentVideoData.program)
                    .sort((a, b) => (a.episode || 0) - (b.episode || 0)); // Sắp xếp theo số tập

                if (episodes.length <= 1) {
                    episodesContent.innerHTML =
                        "<p style='padding:20px; text-align:center; color:#777'>Đây là video lẻ.</p>";
                    return;
                }

                episodes.forEach((ep) => {
                    const isCurrent = ep.videoId === currentVideoData.videoId;

                    const item = document.createElement("div");
                    item.className = `episode-item ${isCurrent ? "playing" : ""}`;

                    // Thumbnail tập
                    const thumbUrl = ep.thumbnailUrl || ep.thumbnailUrl_auto;

                    item.innerHTML = `
            <img src="${thumbUrl}" class="episode-thumbnail" loading="lazy" />
            <div class="episode-info">
                <span class="episode-number">Tập ${ep.episode || "?"}</span>
                <span class="episode-title">${ep.userTitle || ep.title}</span>
            </div>
        `;

                    item.onclick = () => {
                        if (isCurrent) return; // Đang xem tập này rồi thì thôi
                        episodesSidebar.classList.remove("visible"); // Đóng sidebar
                        launchPlayer(ep); // Phát tập mới
                    };

                    episodesContent.appendChild(item);
                });
            }
            /* --- [CẬP NHẬT] Logic lọc mới --- */
            function handleSearchAndFilter() {
                const rawSearchTerm = searchInput.value.trim();
                const searchTerm = toNonAccentVietnamese(rawSearchTerm); // Chuyển từ khóa sang không dấu

                // Kiểm tra xem có đang tìm kiếm hay lọc không
                const isSearching = rawSearchTerm.length > 0;

                const filteredData = libraryData.filter((video) => {
                    // 1. LOGIC TÌM KIẾM (Quét sạch mọi ngóc ngách dữ liệu)
                    let matchesSearch = true;
                    if (isSearching) {
                        // Gom tất cả dữ liệu text vào 1 chuỗi để tìm 1 lần cho tiện
                        const participantsStr = (video.participants || []).join(" ");
                        const genresStr = (video.genres || []).join(" ");

                        // Tạo nguồn tìm kiếm phong phú (User title, Original title, Author, Desc, Program, Cast...)
                        const searchableText = `
                ${video.userTitle || ""} 
                ${video.title || ""} 
                ${video.originalTitle_auto || ""} 
                ${video.program || ""} 
                ${video.description || ""} 
                ${video.authorName || video.authorName_auto || ""} 
                ${participantsStr}
                ${genresStr}
            `;

                        // So sánh chuỗi không dấu
                        matchesSearch = toNonAccentVietnamese(searchableText).includes(searchTerm);
                    }

                    // 2. LOGIC LỌC THẺ
                    let matchesFilter = true;

                    return matchesSearch && matchesFilter;
                });

                // --- QUYẾT ĐỊNH CÁCH RENDER ---
                // Nếu đang tìm kiếm hoặc đang lọc thẻ -> Dùng GRID VIEW (Dễ nhìn)
                // Nếu đang ở trang chủ (Tất cả, không search) -> Dùng CAROUSEL VIEW (Đẹp, discovery)
                if (isSearching || isFiltering) {
                    renderGridView(filteredData, isSearching ? `Kết quả cho "${rawSearchTerm}"` : "Kết quả lọc");
                } else {
                    renderVideoRows(libraryData); // Quay về giao diện trang chủ
                }
            }
            function renderGridView(videoArray, titleText) {
                libraryContainer.innerHTML = ""; // Xóa sạch

                if (videoArray.length === 0) {
                    libraryContainer.innerHTML = `<p style="text-align: center; margin-top: 50px; color: #777;">Không tìm thấy nội dung phù hợp.</p>`;
                    return;
                }

                // Tạo tiêu đề
                const title = document.createElement("h2");
                title.className = "program-title"; // Tái sử dụng class style
                title.style.marginTop = "0";
                title.textContent = titleText;
                libraryContainer.appendChild(title);

                // Tạo container lưới
                const grid = document.createElement("div");
                grid.className = "grid-view-container";

                // Render từng video
                videoArray.forEach((video) => {
                    // Tái sử dụng logic tạo HTML card cũ
                    // Lưu ý: Grid View ta ưu tiên hiện Video lẻ hơn là gộp vào Program
                    // Nhưng nếu muốn gộp thì tùy bạn. Ở đây tôi để hiện tất cả video ra để dễ chọn.

                    let cardHTML = createVideoCardHtml(video);

                    // Convert chuỗi HTML thành DOM Node để append
                    const tempDiv = document.createElement("div");
                    tempDiv.innerHTML = cardHTML.trim();
                    const card = tempDiv.firstChild;

                    grid.appendChild(card);
                });

                libraryContainer.appendChild(grid);
            }

            function handleCardClick(e) {
                const card = e.target.closest(".video-card");
                if (!card) return;

                // Check PC (Giữ nguyên)
                const isDesktop =
                    window.matchMedia("(hover: hover) and (pointer: fine)").matches || window.innerWidth > 1024;
                if (isDesktop) return;

                // [MOBILE] LOGIC CLICK
                let videoData = null;

                if (card.dataset.programName) {
                    // Click vào Card Chương trình
                    const progName = card.dataset.programName;
                    const videos = libraryData
                        .filter((v) => v.program === progName)
                        .sort((a, b) => getVideoTimestamp(b) - getVideoTimestamp(a)); 
                    videoData = videos[0];
                } else if (card.dataset.videoId) {
                    // Click vào Card Video lẻ
                    videoData = libraryData.find((v) => v.videoId === card.dataset.videoId);
                }

                if (videoData) {
                    // [FIX] Kiểm tra xem video này có thuộc chương trình nào không
                    if (videoData.program) {
                        // Có -> Mở Modal Series
                        const episodes = libraryData
                            .filter((v) => v.program === videoData.program)
                            .sort((a, b) => getVideoTimestamp(b) - getVideoTimestamp(a)); 
                        openDetailModal(videoData, episodes);
                    } else {
                        // Không -> Mở Modal lẻ
                        openDetailModal(videoData, null);
                    }
                }
            }

            function handleModalPlay() {
                const videoId = modalPlayBtn.dataset.videoId;
                const videoData = libraryData.find((v) => v.videoId === videoId);
                if (videoData) {
                    closeModal(detailModalOverlay);

                    launchPlayer(videoData).then(() => {
                        if (player && typeof player.playVideo === "function") {
                            player.playVideo(); // <-- phát ngay vì là user gesture
                        }
                    });
                }
            }

            function handleAddVideoSubmit(e) {
                e.preventDefault();
                const videoId = extractVideoID(urlInput.value);
                if (!videoId) {
                    alert("Link YouTube không hợp lệ.");
                    return;
                }
                const srtFile = srtFileInput.files[0];
                if (srtFile) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        launchPlayer({ videoId }, parseSubtitle(event.target.result));
                    };
                    reader.readAsText(srtFile);
                } else {
                    launchPlayer({ videoId });
                }
                closeModal(addVideoModalOverlay);
                urlInput.value = "";
                srtFileInput.value = "";
                srtFileName.textContent = "";
            }

            function handleFileDrop(e) {
                const file = e.dataTransfer.files[0];
                if (file && file.name.endsWith(".srt")) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        subtitles = parseSubtitle(event.target.result);
                        if (player && player.getPlayerState() === YT.PlayerState.PLAYING) startSubtitleSync();
                    };
                    reader.readAsText(file);
                }
            }
            function openModal(modal) {
                // 1. Gỡ bỏ display: none để trình duyệt render ra trước
                modal.classList.remove("hidden");

                // 2. Sử dụng requestAnimationFrame để chờ 1 frame (đảm bảo CSS nhận diện sự thay đổi)
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        modal.classList.add("visible");
                    });
                });

                // Ngăn cuộn trang web nền khi modal mở (UX tốt hơn)
                document.body.style.overflow = "hidden";
            }

            function closeModal(modal) {
                // 1. Gỡ class visible để kích hoạt animation ẩn đi (Fade out / Slide down)
                modal.classList.remove("visible");
                if (modal.id === "detail-modal-overlay") {
                    destroyTeaser();
                }
                // 2. Đợi animation chạy xong (300ms) mới thêm display: none
                setTimeout(() => {
                    modal.classList.add("hidden");
                    // Reset cuộn trang web nền
                    document.body.style.overflow = "";

                    // Reset nội dung modal về đầu (để lần sau mở không bị đang ở giữa trang)
                    const content = modal.querySelector(".modal-content");
                    if (content) content.scrollTop = 0;
                }, 300); // Thời gian này khớp với transition trong CSS
            if (modal.id === "detail-modal-overlay") {
        const activeHeroImg = document.querySelector(".hero-slide.active .hero-bg");
        if (activeHeroImg) {
            applyThemeFromImage(activeHeroImg.src);
        } else {
            // Hoặc về màu đen mặc định
            document.documentElement.style.setProperty('--dynamic-color', '20, 20, 20');
        }
    }
}
            teaserVolumeBtn.addEventListener("click", (e) => {
                e.stopPropagation(); // Tránh click xuyên qua làm đóng modal hay play
                isTeaserMuted = !isTeaserMuted;
                updateVolumeUI();
            });
            /**
             * Mở modal chi tiết, có thể hiển thị danh sách tập nếu là một PROGRAM (Series).
             * @param {Object} videoData Dữ liệu của video/tập mới nhất được chọn.
             * @param {Array<Object> | null} programEpisodes Danh sách các tập của chương trình, nếu là Program Card.
             */
            /**
 * Mở modal chi tiết, có thể hiển thị danh sách tập theo MÙA nếu là một PROGRAM (Series).
 */
function openDetailModal(videoData, programEpisodes = null) {
    // 1. Lấy DOM
    const modalThumbnail = document.getElementById("modal-thumbnail");
    const modalTitle = document.getElementById("modal-title");
    const modalOriginalTitle = document.getElementById("modal-original-title");
    const modalProgram = document.getElementById("modal-program");
    const modalAuthor = document.getElementById("modal-author");
    const modalDescription = document.getElementById("modal-description");
    const modalPlayBtn = document.getElementById("modal-play-btn");

    const modalParticipantsList = document.getElementById("modal-participants-list");
    const modalParticipantsContainer = document.getElementById("modal-participants-container");
    const modalGenresList = document.getElementById("modal-genres-list");
    const modalGenresContainer = document.getElementById("modal-genres-container");
    
    const modalEpisodeSection = document.getElementById("modal-episodes-section");
    const modalEpisodesList = document.getElementById("modal-episodes-list");
    
    // [MỚI] DOM cho Season
    const seasonSelectWrapper = document.getElementById("season-select-wrapper");
    const seasonSelect = document.getElementById("season-select");

    // 2. Xử lý thumbnail
    const thumbnailUrl = videoData.thumbnailUrl || videoData.thumbnailUrl_auto;
    modalThumbnail.src = thumbnailUrl.replace("hqdefault", "maxresdefault");
    modalThumbnail.onerror = () => { modalThumbnail.src = thumbnailUrl; };

    // 3. Xử lý TIÊU ĐỀ
    if (programEpisodes) {
        modalTitle.textContent = videoData.program;
        modalOriginalTitle.textContent = videoData.userTitle || videoData.title;
        modalOriginalTitle.style.display = "block";
    } else {
        modalTitle.textContent = videoData.userTitle || videoData.title;
        modalOriginalTitle.style.display = videoData.originalTitle_auto ? "block" : "none";
        if (videoData.originalTitle_auto) modalOriginalTitle.textContent = videoData.originalTitle_auto;
    }

    // 4. Thông tin cơ bản
    modalProgram.textContent = videoData.program || "";
    modalAuthor.textContent = videoData.authorName || videoData.authorName_auto || "";
    modalDescription.textContent = videoData.description || "Chưa có mô tả chi tiết.";

    // 5. GENRES
    modalGenresList.innerHTML = "";
    if (videoData.genres && videoData.genres.length > 0) {
        modalGenresList.innerHTML = `<span style="font-weight: 700; color: #fff; margin-right: 5px;">Thể loại:</span>` + videoData.genres.map((g) => `<span class="genre-tag">${g}</span>`).join(" ");
        modalGenresContainer.classList.remove("hidden");
    } else {
        modalGenresContainer.classList.add("hidden");
    }

    // 6. PARTICIPANTS
    modalParticipantsList.innerHTML = "";
    if (videoData.participants && videoData.participants.length > 0) {
        modalParticipantsList.innerHTML = videoData.participants.map((p) => `<li class="participant-tag">${p}</li>`).join("");
        modalParticipantsContainer.classList.remove("hidden");
    } else {
        modalParticipantsContainer.classList.add("hidden");
    }

    // 7. [LOGIC MỚI] XỬ LÝ DANH SÁCH TẬP & MÙA (SEASONS)
    modalEpisodesList.innerHTML = "";
    seasonSelect.innerHTML = "";
    
    if (programEpisodes && programEpisodes.length > 0) {
        modalEpisodeSection.classList.remove("hidden");

        // --- BƯỚC 7A: GOM NHÓM THEO MÙA ---
        const seasonsMap = {};
        programEpisodes.forEach(ep => {
            const s = ep.season || 1; // Mặc định là Mùa 1 nếu không ghi
            if (!seasonsMap[s]) seasonsMap[s] = [];
            seasonsMap[s].push(ep);
        });

        // Lấy danh sách số mùa và sắp xếp tăng dần
        const seasonKeys = Object.keys(seasonsMap).sort((a, b) => parseInt(a) - parseInt(b));

        // --- BƯỚC 7B: XỬ LÝ DROPDOWN ---
       // --- BƯỚC 7B: XỬ LÝ DROPDOWN ---
        // SỬA: Hiện dropdown nếu có > 1 mùa HOẶC (chỉ có 1 mùa NHƯNG đó không phải Mùa 1)
        if (seasonKeys.length > 1 || (seasonKeys.length === 1 && String(seasonKeys[0]) !== "1")) {
            seasonSelectWrapper.classList.remove("hidden");
            
            // Tạo options cho select
            seasonKeys.forEach(s => {
                const option = document.createElement("option");
                option.value = s;
                // Đếm số tập trong mùa đó
                const count = seasonsMap[s].length;
                option.textContent = `Mùa ${s} (${count} tập)`;
                seasonSelect.appendChild(option);
            });

            // Chọn mùa của video đang hiển thị (nếu có), nếu không thì chọn mùa đầu tiên tìm thấy
            const currentSeason = videoData.season || seasonKeys[0];
            if (seasonsMap[currentSeason]) {
                seasonSelect.value = currentSeason;
            } else {
                seasonSelect.value = seasonKeys[0];
            }

        } else {
            // Chỉ ẩn khi có duy nhất 1 mùa VÀ đó là Mùa 1 (Mặc định)
            seasonSelectWrapper.classList.add("hidden");
        }

        // --- BƯỚC 7C: HÀM RENDER TẬP THEO MÙA ---
        const renderEpisodes = (seasonNum) => {
            modalEpisodesList.innerHTML = "";
            const episodes = seasonsMap[seasonNum] || [];
            
            episodes.sort((a, b) => getVideoTimestamp(a) - getVideoTimestamp(b)); 

            episodes.forEach((ep) => {
                const el = document.createElement("div");
                el.className = "modal-episode-item";
                const epThumb = ep.thumbnailUrl || ep.thumbnailUrl_auto;
                
                const isPlayingBorder = ep.videoId === videoData.videoId ? ' border: 1px solid var(--accent-color);' : '';
                if (ep.videoId === videoData.videoId) el.style.cssText = isPlayingBorder;

                const numStyle = ep.videoId === videoData.videoId ? 'style="color: var(--accent-color)"' : '';

                el.innerHTML = `
                    <img src="${epThumb}" class="modal-ep-thumb" loading="lazy">
                    <div class="modal-ep-info">
                        <span class="modal-ep-number" ${numStyle}>Tập ${ep.episode || "Lẻ"}</span>
                        <span class="modal-ep-title">${ep.userTitle || ep.title}</span>
                    </div>
                `;
                el.onclick = () => {
                    closeModal(document.getElementById("detail-modal-overlay"));
                    launchPlayer(ep);
                };
                modalEpisodesList.appendChild(el);
            });
            
            // Reset scroll
            modalEpisodesList.scrollLeft = 0;
            if (window.updateModalArrows) window.updateModalArrows();
        };

        // Render lần đầu (dựa trên value hiện tại của select hoặc mùa 1)
        const initialSeason = seasonKeys.length > 1 ? seasonSelect.value : (seasonKeys[0] || 1);
        renderEpisodes(initialSeason);

        // Sự kiện khi chọn mùa khác
        seasonSelect.onchange = (e) => {
            renderEpisodes(e.target.value);
        };

        modalPlayBtn.onclick = () => {
            closeModal(document.getElementById("detail-modal-overlay"));
            launchPlayer(videoData);
        };
    } else {
        // VIDEO LẺ (Không có danh sách tập)
        modalEpisodeSection.classList.add("hidden");
        modalPlayBtn.onclick = handleModalPlay;
        modalPlayBtn.dataset.videoId = videoData.videoId;
    }

    // 8. RENDER SERIES LIÊN QUAN (Giữ nguyên)
    renderRelatedContent(videoData);

    const prog = videoData.program || null;
    const thumbUrl = videoData.thumbnailUrl || videoData.thumbnailUrl_auto;
    applyThemeFromImage(thumbUrl.replace("hqdefault", "maxresdefault"));
    openModal(document.getElementById("detail-modal-overlay"));

    if (prog) {
        setTimeout(() => {
            if (!document.getElementById("detail-modal-overlay").classList.contains("hidden")) {
                checkAndLoadTeaser(prog);
            }
        }, 100);
    } else {
        destroyTeaser();
    }
}
            // [THAY THẾ] Hàm vẽ vạch bookmark lên thanh tiến trình
            function renderBookmarksOverlay(bookmarks) {
                // 1. Xóa các marker cũ trên thanh progress
                const oldMarkers = document.querySelectorAll(".timeline-marker");
                oldMarkers.forEach((m) => m.remove());

                // 2. Ẩn nút skip cũ nếu có
                skipBtn.classList.remove("visible");

                const duration = player.getDuration?.() || 0;
                if (!duration || !bookmarks || bookmarks.length === 0) return;

                const progressContainer = document.querySelector(".progress-container");

                bookmarks.forEach((b) => {
                    const timeSec = srtTimeToSeconds(b.time);
                    const percent = (timeSec / duration) * 100;

                    // Tạo vạch trắng nhỏ trên thanh bar
                    const marker = document.createElement("div");
                    marker.className = "timeline-marker";
                    marker.style.left = `${percent}%`;
                    marker.setAttribute("data-label", b.label); // Để hover hiện tên

                    progressContainer.appendChild(marker);
                });
            }
            function renderRelatedContent(currentData) {
    const relatedSection = document.getElementById("modal-related-section");
    const relatedList = document.getElementById("modal-related-list");
    relatedList.innerHTML = "";

    // 1. Tạo danh sách ứng viên (Loại bỏ chính chương trình/video hiện tại)
    // Nếu đang xem Series -> Loại bỏ các tập cùng Series
    // Nếu xem lẻ -> Loại bỏ chính nó
    const currentProgramName = currentData.program;
    
    let candidates = [];
    
    // Lấy đại diện mỗi Program một cái thôi (để không bị trùng series)
    const programRep = {}; 
    const singles = [];

    libraryData.forEach(v => {
        if (currentProgramName && v.program === currentProgramName) return; // Bỏ qua chương trình hiện tại
        if (v.videoId === currentData.videoId) return; // Bỏ qua video hiện tại

        if (v.program) {
            // Nếu là series, chỉ lấy 1 tập đại diện (tập mới nhất)
            if (!programRep[v.program] || (v.episode > programRep[v.program].episode)) {
                programRep[v.program] = v;
            }
        } else {
            singles.push(v);
        }
    });

    // Gộp lại thành danh sách cần lọc
    const pool = [...Object.values(programRep), ...singles];

    // 2. Chấm điểm sự liên quan
    const scored = pool.map(v => {
        let score = 0;
        
        // Trùng thể loại: +2 điểm mỗi thể loại
        if (currentData.genres && v.genres) {
            const intersection = currentData.genres.filter(g => v.genres.includes(g));
            score += intersection.length * 2;
        }

        // Trùng tác giả/diễn viên: +1 điểm
        if (currentData.participants && v.participants) {
             const intersection = currentData.participants.filter(p => v.participants.includes(p));
             score += intersection.length * 1;
        }

        return { v, score };
    });

    // 3. Sắp xếp điểm cao xuống thấp & Lấy Top 10
    scored.sort((a, b) => b.score - a.score);
    const finalRelated = scored.slice(0, 10).map(item => item.v);

    // 4. Render
    if (finalRelated.length > 0) {
        relatedSection.classList.remove("hidden");
        finalRelated.forEach(video => {
            // Tái sử dụng hàm createProgramCardHtml hoặc createVideoCardHtml tùy loại
            // Ở đây ta dùng createVideoCardHtml cho đơn giản, nhưng sửa class để không bị vỡ layout
            
            let html = "";
            if (video.program) {
                 // Nếu là series thì hiện kiểu card series
                 // Đếm số tập trong library gốc
                 const count = libraryData.filter(x => x.program === video.program).length;
                 const thumb = video.thumbnailUrl || video.thumbnailUrl_auto;
                 html = `
                    <div class="video-card" data-program-name="${video.program}">
                        <div class="card-image-wrapper">
                            <div class="episode-badge" style="background: var(--accent-color);">${count} Tập</div>
                            <img src="${thumb}" class="video-thumbnail" loading="lazy">
                        </div>
                    </div>`;
            } else {
                 html = createVideoCardHtml(video); // Hàm cũ của bạn
            }

            // Chuyển string thành DOM
            const div = document.createElement("div");
            div.innerHTML = html.trim();
            const card = div.firstChild;
            
            // Fix lại style width inline để đè CSS grid nếu cần
            card.style.width = "160px"; 
            
            relatedList.appendChild(card);
        });
        // Reset scroll
        relatedList.scrollLeft = 0;
    } else {
        relatedSection.classList.add("hidden");
    }
}
            // [MỚI] Hàm xử lý click nút Skip
            function handleSkipClick(e) {
                e.stopPropagation();
                if (currentSkipTarget !== null) {
                    player.seekTo(currentSkipTarget, true);
                    skipBtn.classList.remove("visible");
                    // Update UI thanh bar ngay lập tức
                    updateProgressBarUI(currentSkipTarget, player.getDuration());
                }
            }

            async function launchPlayer(videoData, preloadedSubtitles = null) {
                return new Promise((resolve) => {
                    if (!videoData || !videoData.videoId) return;
                    isUpNextTriggered = false; 
        isEnding = false;
        lastSubtitleEnd = 0; // Reset tạm, sẽ được cập nhật khi load sub
                    // [FIX] KIỂM TRA AN TOÀN: Nếu player chưa sẵn sàng thì tạo lại
                    if (!player || typeof player.loadVideoById !== "function") {
                        console.log("Player chưa sẵn sàng, đang khởi tạo lại...");
                        player = new YT.Player("youtube-player", {
                            videoId: videoData.videoId,
                            playerVars: {
                                autoplay: 1,
                                playsinline: 1,
                                rel: 0,
                                modestbranding: 1,
                                controls: 0,
                                showinfo: 0,
                                cc_load_policy: 0,
                                iv_load_policy: 3,
                                disablekb: 1,
                            },
                            events: {
                                onReady: (event) => {
                                    event.target.playVideo();
                                    onPlayerReady(event); // Gọi lại các logic setup
                                    resolve(); // Xong việc
                                },
                                onStateChange: onPlayerStateChange,
                            },
                        });
                        // Sau khi new Player thì code dưới chạy tiếp sẽ cập nhật UI
                    }

                    currentVideoData = videoData;
                    const hasEpisodes = libraryData.some(
                        (v) => v.program === videoData.program && v.videoId !== videoData.videoId
                    );
                    if (hasEpisodes || (videoData.program && videoData.episode)) {
                        episodesBtn.classList.remove("hidden");
                    } else {
                        episodesBtn.classList.add("hidden");
                    }
                    isEnding = false;
                    hideUpNextOverlay();

                    subtitles = preloadedSubtitles || [];
                    subtitleDisplay.innerHTML = "";

                    // --- RESET UI TRƯỚC KHI PHÁT ---
                    playerWrapper.classList.remove("hidden");

                    const spinner = document.getElementById("loading-spinner");
                    spinner.style.display = "block";

                    const iframe = document.getElementById("youtube-player");
                    iframe.classList.remove("ready");

                    const centerBtn = document.getElementById("center-play-pause-btn");
                    centerBtn.style.opacity = "0";
                    centerBtn.style.pointerEvents = "none";

                    videoTitleDisplay.textContent = videoData.userTitle || videoData.title || "Đang tải...";
                    videoProgramDisplay.textContent = videoData.program || "";

                    updateProgressBarUI(0, 0);
                    

                    renderBookmarksOverlay(videoData.bookmarks || []);

                    enterCinematicMode().then(() => {
                        if (videoData.subtitleUrl) {
                            loadRemoteSubtitle(videoData.subtitleUrl);
                        } else if (subtitles.length > 0) {
                            startSubtitleSync();
                        }

                        // [FIX] Chỉ gọi loadVideoById nếu player ĐÃ TỒN TẠI (tránh lỗi undefined)
                        if (player && typeof player.loadVideoById === "function") {
                            // [SỬA ĐOẠN NÀY]
                            // 1. Lấy thời gian đã lưu
                            const savedTime = getSavedTime(videoData.videoId);

                            // 2. Nếu có savedTime > 0, thông báo nhỏ (tùy chọn) hoặc cứ thế phát
                            if (savedTime > 0) {
                                console.log(`Tiếp tục phát từ: ${savedTime}`);
                            }

                            // 3. Load video tại giây thứ savedTime
                            player.loadVideoById(videoData.videoId, savedTime);

                            resolve();
                        }
                    });
                });
            }

            async function enterCinematicMode() {
                try {
                    if (playerContainer.requestFullscreen) await playerContainer.requestFullscreen();
                    if (screen.orientation && screen.orientation.lock) await screen.orientation.lock("landscape");
                } catch (err) {
                    console.warn("Lỗi cinematic:", err);
                }
            }
            function goHome() {
                if (player && typeof player.stopVideo === "function") {
                    player.stopVideo();
                }
                playerWrapper.classList.add("hidden");
                if (document.fullscreenElement) document.exitFullscreen();

                // --- LOGIC GIỮ VỊ TRÍ CUỘN MƯỢT MÀ ---
                // 1. Lưu vị trí đang đứng ở trang chủ
                const currentScroll = window.scrollY;

                // 2. Vẽ lại giao diện (để hiện hàng Xem tiếp mới)
                renderVideoRows(libraryData);

                // 3. Nếu trước đó đang ở tít dưới sâu, trả lại vị trí cũ
                // (Trừ khi bạn muốn user luôn thấy hàng Xem tiếp ở trên cùng thì bỏ dòng này)
                window.scrollTo(0, currentScroll);
            }

            function onPlayerReady(event) {
                const apiData = event.target.getVideoData();
                videoTitleDisplay.textContent = apiData.title;
                // FIX: Force playVideo() call to maximize autoplay success
                event.target.playVideo();
                event.target.unloadModule("captions");
            }

           function onPlayerStateChange(event) {
    const centerBtn = doc.getElementById("center-play-pause-btn");
    const centerIcon = doc.getElementById("center-play-pause-icon");
    const spinner = document.getElementById("loading-spinner");
    const iframe = document.getElementById("youtube-player");

    // Icon SVG Paths
    const playPath = "M8,5.14V19.14L19,12.14L8,5.14Z";
    const pausePath = "M14,19H18V5H14M6,19H10V5H6V19Z";

    // 1. XỬ LÝ TRẠNG THÁI LOADING
    if (event.data === YT.PlayerState.BUFFERING || event.data === YT.PlayerState.UNSTARTED) {
        spinner.style.display = "block"; 
        centerBtn.style.opacity = "0";
        centerBtn.style.pointerEvents = "none";
    }
    // 2. XỬ LÝ KHI ĐANG PHÁT (PLAYING)
    else if (event.data === YT.PlayerState.PLAYING) {
        spinner.style.display = "none"; 
        iframe.classList.add("ready"); 

        centerBtn.style.opacity = "0";
        centerBtn.style.pointerEvents = "none";

        playerContainer.classList.add("playing");

        playPauseBtn.querySelector("svg path").setAttribute("d", pausePath);
        if (centerIcon) centerIcon.setAttribute("d", pausePath);

        startSyncing();
        
        // [FIX QUAN TRỌNG TẠI ĐÂY]
        // Chỉ ẩn bảng "Tiếp theo" nếu chưa đến giờ kích hoạt.
        // Nếu biến cờ đang True (tức là bạn vừa tua đến đoạn cuối), thì ĐỪNG ẩn nó.
        if (!isUpNextTriggered) {
            hideUpNextOverlay();
        }

        showControlsAndSetHideTimeout();
    }
    // 3. XỬ LÝ KHI TẠM DỪNG HOẶC KẾT THÚC
    else {
        spinner.style.display = "none"; 

        centerBtn.style.opacity = "1";
        centerBtn.style.pointerEvents = "auto";

        playerContainer.classList.remove("playing");

        playPauseBtn.querySelector("svg path").setAttribute("d", playPath);
        if (centerIcon) centerIcon.setAttribute("d", playPath);

        stopSyncing();
        clearTimeout(controlsTimeout);
        playerContainer.classList.add("controls-active");
        playerContainer.classList.remove("no-cursor");
    }

    if (event.data === YT.PlayerState.ENDED && !isEnding) {
        handleVideoEnd(false); // Video hết hẳn -> Force đếm ngược 5s
    }
}
            // Gọi hàm này trong onPlayerStateChange hoặc setInterval check mỗi 5s
            function updateQualityBadge() {
                // Các giá trị trả về: 'highres', 'hd1080', 'hd720', 'large', 'medium', 'small'
                const quality = player.getPlaybackQuality();

                const badge = document.getElementById("quality-badge"); // Tạo cái span này ở UI
                if (quality === "hd1080" || quality === "highres") {
                    badge.textContent = "HD"; // Hoặc 4K
                    badge.style.display = "inline-block";
                } else {
                    badge.style.display = "none"; // Mờ quá thì giấu đi cho đỡ ngại
                }
            }
            function handleInteraction(e) {
                const now = new Date().getTime();
                const timeSinceLastClick = now - lastClickInfo.time;
                const area = e.target.id;

                // Logic Double Click để tua
                if (timeSinceLastClick < 350 && area === lastClickInfo.area) {
                    const currentTime = player.getCurrentTime();
                    const duration = player.getDuration();
                    let newTime = currentTime;

                    if (area === "seek-backward-zone") {
                        newTime = Math.max(0, currentTime - 5);
                        player.seekTo(newTime, true);
                        startSubtitleSync();
                        updateProgressBarUI(newTime, duration); // Cập nhật UI ngay
                    } else if (area === "seek-forward-zone") {
                        newTime = Math.min(duration, currentTime + 5);
                        player.seekTo(newTime, true);
                        startSubtitleSync();
                        updateProgressBarUI(newTime, duration); // Cập nhật UI ngay
                    }
                    lastClickInfo = { time: 0, area: null }; // Reset
                }
                // Logic Single Click để hiện/ẩn controls
                else {
                    if (playerContainer.classList.contains("controls-active")) {
                        hideControls();
                    } else {
                        showControlsAndSetHideTimeout();
                    }
                }
                lastClickInfo = { time: now, area: area };
            }

            // FIX: Added function to handle seek
            function handleSeek() {
                const seekTime = parseFloat(progressBar.value);

                player.seekTo(seekTime, true);
                // Cập nhật UI ngay lập tức
                updateProgressBarUI(seekTime, player.getDuration());
            }
            // FIX: Added dedicated toggle function for the button
            function togglePlayPause() {
                if (player && player.getPlayerState)
                    player.getPlayerState() === YT.PlayerState.PLAYING ? player.pauseVideo() : player.playVideo();
            }

            function showControlsAndSetHideTimeout() {
    // [FIX] Kiểm tra kỹ: player phải tồn tại VÀ hàm getPlayerState phải khả dụng
    if (!player || typeof player.getPlayerState !== "function") return;

    playerContainer.classList.add("controls-active");
    playerContainer.classList.remove("no-cursor");

    clearTimeout(controlsTimeout);
    
    // Bây giờ gọi hàm này mới an toàn
    if (player.getPlayerState() === YT.PlayerState.PLAYING) {
        controlsTimeout = setTimeout(hideControls, 3500);
    }
}

            function hideControls() {
                clearTimeout(controlsTimeout);
                const menu = doc.getElementById("settings-menu");
                if (menu.classList.contains("visible")) return;

                playerContainer.classList.remove("controls-active");
                if (player.getPlayerState() === YT.PlayerState.PLAYING) {
                    playerContainer.classList.add("no-cursor");
                }
            }
            function handleKeyboardShortcuts(e) {
                if (
                    doc.activeElement === searchInput ||
                    doc.activeElement === urlInput ||
                    playerWrapper.classList.contains("hidden")
                )
                    return;
                switch (e.code) {
                    case "Space":
                        e.preventDefault();
                        togglePlayPause();
                        break;
                    case "Escape":
                        e.preventDefault();
                        goHome();
                        break;
                    case "ArrowLeft":
                        player.seekTo(player.getCurrentTime() - 5, true);
                        break;
                    case "ArrowRight":
                        player.seekTo(player.getCurrentTime() + 5, true);
                        break;
                }
            }

            function applyAndSaveSubtitleStyles() {
                applySubtitleStyles();
                saveSubtitleSettings();
            }
            function applySubtitleStyles() {
                function hexToRgba(hex, op) {
                    let r = "0x" + hex[1] + hex[2],
                        g = "0x" + hex[3] + hex[4],
                        b = "0x" + hex[5] + hex[6];
                    return `rgba(${+r},${+g},${+b},${op})`;
                }
                subtitleDisplay.style.fontSize = `clamp(1.2rem, ${subtitleSettings.fontSize * 0.08}vw, ${subtitleSettings.fontSize}px)`;
                subtitleDisplay.style.color = subtitleSettings.fontColor;
                subtitleDisplay.style.backgroundColor = hexToRgba(subtitleSettings.bgColor, subtitleSettings.bgOpacity);
            }
            function saveSubtitleSettings() {
                localStorage.setItem("youtubeVODPlayerSubSettings", JSON.stringify(subtitleSettings));
            }
            function loadSubtitleSettings() {
                const saved = localStorage.getItem("youtubeVODPlayerSubSettings");
                subtitleSettings = saved ? JSON.parse(saved) : { ...DEFAULT_SUB_SETTINGS };
                fontSizeSlider.value = subtitleSettings.fontSize;
                fontColorPicker.value = subtitleSettings.fontColor;
                bgColorPicker.value = subtitleSettings.bgColor;
                bgOpacitySlider.value = subtitleSettings.bgOpacity;
                applySubtitleStyles();
            }

            function startSyncing() {
                startProgressSync();
                if (subtitles.length > 0) startSubtitleSync();
            }
            function stopSyncing() {
                stopProgressSync();
                stopSubtitleSync();
            }
            function stopProgressSync() {
                clearInterval(progressInterval);
            }
            function stopSubtitleSync() {
                clearInterval(subtitleCheckInterval);
            }
function startProgressSync() {
    stopProgressSync();
    // Lấy 2 element hiển thị giờ mới
    const currTimeEl = document.getElementById("current-time-text");
    const durTimeEl = document.getElementById("duration-time-text");

    progressInterval = setInterval(() => {
        if (!player || typeof player.getDuration !== "function") return;

        const d = player.getDuration();
        const c = player.getCurrentTime();

        if (isNaN(d) || d <= 0) {
            updateProgressBarUI(0, 0);
            return;
        }

        updateProgressBarUI(c, d);

        if (currentVideoData) saveWatchProgress(currentVideoData.videoId, c, d);

        // Logic check Skip & End (Giữ nguyên logic cũ của bạn)
        checkSkipLogic(c, d);
        
        // ... Logic End trigger giữ nguyên ...
        if (currentVideoData.bookmarks && !isUpNextTriggered) {
             const creditMark = currentVideoData.bookmarks.find(b => {
                const bTime = srtTimeToSeconds(b.time);
                const label = (b.label || "").toLowerCase();
                return c >= bTime && (label.includes("credit") || label.includes("end"));
            });
            if (creditMark) { isUpNextTriggered = true; handleVideoEnd(true); }
        }
        let triggerTime = (lastSubtitleEnd > 0 && lastSubtitleEnd < d) ? lastSubtitleEnd + 0.5 : d - 1;
        if (c >= triggerTime && !isUpNextTriggered && c > 1) {
            isUpNextTriggered = true; handleVideoEnd(true);
        }

        // FORMAT TIME FUNCTION
        const formatTime = (s) => {
            const t = Math.round(s);
            if (isNaN(t)) return "00:00";
            const min = String(Math.floor(t / 60)).padStart(2, "0");
            const sec = String(t % 60).padStart(2, "0");
            // Xử lý nếu > 1 tiếng (tùy chọn)
            if (t >= 3600) {
                const h = String(Math.floor(t / 3600)).padStart(2, "0");
                const m = String(Math.floor((t % 3600) / 60)).padStart(2, "0");
                return `${h}:${m}:${sec}`;
            }
            return `${min}:${sec}`;
        };

        // CẬP NHẬT TEXT
        if (currTimeEl) currTimeEl.textContent = formatTime(c);
        if (durTimeEl) durTimeEl.textContent = formatTime(d);

    }, 250);
}

function updateProgressBarUI(currentTime, duration) {
    const progressBar = document.getElementById("progress-bar");
    if (!duration || isNaN(duration) || duration <= 0) {
        progressBar.max = 0;
        progressBar.value = 0;
        progressBar.style.setProperty("--progress-percent", "0%");
        return;
    }
    progressBar.max = duration;
    progressBar.value = currentTime;
    const percent = (currentTime / duration) * 100;
    progressBar.style.setProperty("--progress-percent", `${percent}%`);
}
            // [MỚI] Logic tính toán xem có hiện nút Skip không
            function checkSkipLogic(currentTime, duration) {
                if (!currentVideoData || !currentVideoData.bookmarks) return;

                // Sắp xếp bookmark theo thời gian
                const bookmarks = currentVideoData.bookmarks
                    .map((b) => ({ ...b, sec: srtTimeToSeconds(b.time) }))
                    .sort((a, b) => a.sec - b.sec);

                let foundSkip = null;

                for (let i = 0; i < bookmarks.length; i++) {
                    const currentB = bookmarks[i];
                    const nextB = bookmarks[i + 1];

                    // Xác định điểm kết thúc của đoạn này
                    // Nếu có đoạn sau thì end là start đoạn sau. Nếu không thì coi như hết video hoặc +60s
                    const endTime = nextB ? nextB.sec : currentB.sec + 80;

                    // Nếu đang nằm trong vùng của bookmark này VÀ nó có skip=true
                    if (currentTime >= currentB.sec && currentTime < endTime && currentB.skip) {
                        foundSkip = {
                            label: currentB.label,
                            target: endTime, // Nhảy tới đầu đoạn sau
                        };
                        break;
                    }
                }

                if (foundSkip) {
                    skipBtn.innerHTML = `Bỏ qua ${foundSkip.label} <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z"></path></svg>`;
                    skipBtn.classList.remove("hidden");
                    // setTimeout nhẹ để kích hoạt animation CSS
                    setTimeout(() => skipBtn.classList.add("visible"), 10);
                    currentSkipTarget = foundSkip.target;
                } else {
                    skipBtn.classList.remove("visible");
                    setTimeout(() => skipBtn.classList.add("hidden"), 300); // Chờ animation ẩn xong mới hidden
                    currentSkipTarget = null;
                }
            }

            function startSubtitleSync() {
                stopSubtitleSync();
                subtitleCheckInterval = setInterval(() => {
                    if (!player || typeof player.getCurrentTime !== "function") return;
                    const c = player.getCurrentTime();
                    const sub = subtitles.find((s) => c >= s.start && s.end >= c);
                    subtitleDisplay.innerHTML = sub ? sub.text : "";
                }, 100);
            }
            /* --- [CẬP NHẬT] TẢI SUBTITLE KHÔNG CACHE --- */
            async function loadRemoteSubtitle(url) {
                if (!url) return;
                try {
                    // 1. Kiểm tra URL đã có tham số chưa để thêm dấu ? hoặc & cho đúng
                    const separator = url.includes("?") ? "&" : "?";

                    // 2. Gắn thêm timestamp để đảm bảo URL luôn mới
                    const noCacheUrl = `${url}${separator}v=${new Date().getTime()}`;

                    // 3. Gọi fetch với tùy chọn cấm cache (cache: 'no-store')
                    const res = await fetch(noCacheUrl, { cache: "no-store" });

                    if (!res.ok) throw new Error(`Could not fetch SRT`);
                    const srt = await res.text();

                    // Cập nhật biến toàn cục subtitles
                    subtitles = parseSubtitle(srt);

                    // Kích hoạt đồng bộ ngay lập tức
                    if (subtitles.length > 0) startSubtitleSync();
                } catch (e) {
                    console.error("Could not load subtitle:", e);
                }
            }
            /* --- [CẬP NHẬT] BỘ ĐỌC SUBTITLE ĐA NĂNG (SRT & VTT) --- */
            /* --- [CẬP NHẬT] BỘ ĐỌC SUBTITLE ĐA NĂNG (SRT & VTT) --- */
function parseSubtitle(text) {
    if (!text) return [];

    // 1. Chuẩn hóa dòng mới
    text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");

    const blocks = text.split("\n\n");
    const subs = [];

    // [MỚI] Reset thời gian kết thúc sub
    lastSubtitleEnd = 0;

    for (const block of blocks) {
        // Bỏ qua block rỗng hoặc block header VTT
        if (!block.trim() || block.trim() === "WEBVTT") continue;

        const lines = block.split("\n");

        // Tìm dòng chứa mũi tên thời gian
        const timeIdx = lines.findIndex((l) => l.includes("-->"));

        if (timeIdx !== -1) {
            // Regex bắt thời gian
            const match = lines[timeIdx].match(
                /(\d{1,2}:\d{2}:\d{2}[,.]\d{1,3})\s*-->\s*(\d{1,2}:\d{2}:\d{2}[,.]\d{1,3})/
            );

            if (match) {
                // [FIX LỖI TẠI ĐÂY] Phải tính toán start/end trước khi dùng
                const start = timeToSeconds(match[1]);
                const end = timeToSeconds(match[2]);

                // Nội dung là các dòng sau dòng thời gian
                const txt = lines.slice(timeIdx + 1).join("<br>");

                if (txt) {
                    subs.push({
                        start,
                        end,
                        text: txt
                    });

                    // [MỚI] Cập nhật thời gian kết thúc lớn nhất
                    if (end > lastSubtitleEnd) {
                        lastSubtitleEnd = end;
                    }
                }
            }
        }
    }
    
    // [MỚI] Sắp xếp lại sub theo thời gian
    subs.sort((a, b) => a.start - b.start);

    return subs;
}

            function timeToSeconds(t) {
                // Thay dấu phẩy (SRT) thành dấu chấm (chuẩn JS) để tính toán
                t = t.replace(",", ".");
                const p = t.split(":");

                let s = 0;
                if (p.length === 3) {
                    // hh:mm:ss.ms
                    s = parseFloat(p[0]) * 3600 + parseFloat(p[1]) * 60 + parseFloat(p[2]);
                } else if (p.length === 2) {
                    // mm:ss.ms (VTT có thể lược bỏ giờ)
                    s = parseFloat(p[0]) * 60 + parseFloat(p[1]);
                }
                return s;
            }
            

            function srtTimeToSeconds(t) {
                const p = t.split(/[:,]/).reverse();
                return (
                    (parseInt(p[3], 10) || 0) * 3600 +
                    (parseInt(p[2], 10) || 0) * 60 +
                    (parseInt(p[1], 10) || 0) +
                    (parseInt(p[0], 10) || 0) / 1000
                );
            }
            function extractVideoID(url) {
                const regex = /(?:watch\?v=|youtu\.be\/|embed\/|v\/|e\/|shorts\/)([a-zA-Z0-9_-]{11})/;
                const match = url.match(regex);
                return match ? match[1] : null;
            }
// Thay thế toàn bộ hàm cũ
function handleVideoEnd(isCreditTrigger = false) {
    // 1. Chống spam lệnh gọi
    if (isEnding && !isCreditTrigger) return; 
    // Nếu là Credit Trigger thì cho phép chạy để hiện overlay đè lên, 
    // nhưng đánh dấu isEnding để khi video thực sự hết nó không gọi lại lần nữa.
    isEnding = true;

    if (!currentVideoData) return;

    let nextVideo = null;
    let isSuggestion = false;

    // 2. [QUAN TRỌNG] Ưu tiên tìm tập tiếp theo trong Series
    // Logic: Nếu video có tên chương trình (program) và số tập (episode)
    if (currentVideoData.program && typeof currentVideoData.episode !== "undefined") {
        const currentEpisode = Number(currentVideoData.episode);
        
        // Quét toàn bộ thư viện để tìm tập tiếp theo (episode + 1) cùng program
        nextVideo = libraryData.find(
            (v) => v.program === currentVideoData.program && Number(v.episode) === currentEpisode + 1
        );
    }

    // 3. Nếu KHÔNG tìm thấy tập tiếp theo (Hết series hoặc Video lẻ)
    if (!nextVideo) {
        isSuggestion = true; // Đánh dấu là gợi ý ngẫu nhiên
        
        // Tìm video khác cùng thể loại hoặc ngẫu nhiên (trừ video đang xem)
        const candidates = libraryData.filter(
            (v) => v.videoId !== currentVideoData.videoId && v.program !== currentVideoData.program
        );
        
        if (candidates.length > 0) {
            // Lấy ngẫu nhiên 1 cái
            nextVideo = candidates[Math.floor(Math.random() * candidates.length)];
        }
    }

    // 4. Gọi Overlay nếu tìm được video tiếp theo (Dù là tập sau hay gợi ý)
    if (nextVideo) {
        // Nếu là Suggestion (hết phim) thì hiện con trỏ chuột lại
        if (isSuggestion) {
            playerContainer.classList.remove("no-cursor");
            playerContainer.classList.add("controls-active");
        }
        
        showUpNextOverlay(nextVideo, isSuggestion, isCreditTrigger);
    }
}  
         
        
            function showUpNextOverlay(videoData, isSuggestion = false, isCreditTrigger = false) {
                const overlay = document.getElementById("up-next-overlay");
                const thumbnail = document.getElementById("up-next-thumbnail");
                const title = document.getElementById("up-next-title");
                const seriesName = document.getElementById("up-next-series-name");
                const label = document.querySelector(".up-next-label");
                const secondsSpan = document.getElementById("up-next-seconds");
                const countdownRing = document.getElementById("countdown-ring");
                const card = document.getElementById("up-next-card");
    const cancelBtn = document.getElementById("up-next-cancel-btn");
    const countdownWrapper = document.querySelector(".up-next-countdown-wrapper");

    // 1. Điền thông tin video
    const thumbUrl = (videoData.thumbnailUrl || videoData.thumbnailUrl_auto).replace("hqdefault", "maxresdefault");
    thumbnail.src = thumbUrl;
    // Fallback ảnh lỗi
    thumbnail.onerror = () => { thumbnail.src = videoData.thumbnailUrl || videoData.thumbnailUrl_auto; };
    
    title.textContent = videoData.userTitle || videoData.title;
    seriesName.textContent = videoData.program || "";

    // 2. Reset timer cũ
    clearInterval(upNextInterval);
    clearTimeout(upNextTimeout);

    // 3. Xử lý UI dựa trên loại (Suggestion hay Next Ep)
    // [SỬA] Cả 2 trường hợp ĐỀU HIỆN ĐẾM NGƯỢC
    countdownWrapper.style.display = "flex"; 
    
    if (isSuggestion) {
        label.textContent = "GỢI Ý CHO BẠN";
        cancelBtn.textContent = "Đóng"; // Gợi ý thì nút là Đóng
    } else {
        label.textContent = "ĐANG PHÁT TIẾP THEO";
        cancelBtn.textContent = "Hủy"; // Tập tiếp theo thì là Hủy
    }

    // 4. [LOGIC ĐẾM NGƯỢC CHUẨN]
    let countdownTime = 5; // Mặc định 5s

    // Nếu kích hoạt bởi Credit/Sub và Player đang chạy
    if (isCreditTrigger && player && typeof player.getDuration === "function") {
        const remaining = player.getDuration() - player.getCurrentTime();
        
        // Logic: Nếu thời gian còn lại > 5s thì dùng thời gian thực.
        // Nếu còn <= 5s (gần hết hẳn) thì ép về 5s để người dùng kịp nhìn.
        if (remaining > 5) {
            countdownTime = Math.ceil(remaining);
        } else {
            countdownTime = 5;
        }
    } else {
        // Trường hợp Video đã hết hẳn (Suggestion) -> Luôn đếm 5s
        countdownTime = 5;
    }

    // 5. Setup vòng tròn & Số giây
    let currentCount = countdownTime;
    const totalDash = 138; // Chu vi vòng tròn SVG (2 * PI * r) với r=22
    
    const updateTimerUI = () => {
        secondsSpan.textContent = currentCount;
        // Tính offset: chạy từ 0 (full vòng) đến 138 (biến mất) hoặc ngược lại
        // Ở đây làm kiểu đồng hồ cát: vơi dần
        const offset = totalDash - ((currentCount / countdownTime) * totalDash);
        countdownRing.style.strokeDashoffset = -offset;
    };

    updateTimerUI(); // Render số ban đầu

    // 6. Hàm chạy video tiếp theo
    const playNext = () => {
        hideUpNextOverlay();
        launchPlayer(videoData);
    };

    // Gán sự kiện click
    card.onclick = playNext;
    cancelBtn.onclick = hideUpNextOverlay;

    // 7. Chạy Interval đếm ngược
    upNextInterval = setInterval(() => {
        currentCount--;

        // Đồng bộ lại với thời gian thực của video nếu đang chạy credit
        // Để tránh việc đồng hồ đếm lệch so với video
        if (isCreditTrigger && player && !player.paused) {
             const realRemaining = Math.ceil(player.getDuration() - player.getCurrentTime());
             // Nếu realRemaining > 5, ưu tiên dùng nó để khớp timeline
             if (realRemaining > 5) {
                 currentCount = realRemaining;
             }
        }

        if (currentCount < 0) currentCount = 0;
        updateTimerUI();

        if (currentCount <= 0) {
            clearInterval(upNextInterval);
            playNext(); // [QUAN TRỌNG] Tự động chuyển
        }
    }, 1000);

    // 8. Hiện Overlay
    overlay.style.display = "flex";
    requestAnimationFrame(() => { overlay.classList.add("visible"); });
}

function hideUpNextOverlay() {
                clearTimeout(upNextTimeout);
                clearInterval(upNextInterval);

                const overlay = document.getElementById("up-next-overlay");
                if (overlay) {
                    overlay.classList.remove("visible"); // Slide xuống

                    // Đợi animation CSS (0.5s) chạy xong mới ẩn display
                    setTimeout(() => {
                        if (!overlay.classList.contains("visible")) {
                            overlay.style.display = "none";
                        }
                    }, 500);
                }

                const card = document.getElementById("up-next-card");
                if (card) card.onclick = null;
            }
            function enableSiteProtection() {
                // 1. Chặn Menu Chuột Phải (Context Menu)
                document.addEventListener("contextmenu", (e) => {
                    e.preventDefault();
                    // Có thể hiện thông báo nhỏ nếu muốn, hoặc im lặng luôn
                    return false;
                });
            }

            // Gọi hàm bảo vệ ngay khi chạy
            enableSiteProtection();

            /* ========================================= */
            /* START: QUẢN LÝ TRẠNG THÁI NGƯỜI XEM       */
            /* ========================================= */

            const WATCH_HISTORY_KEY = "mizzsub_watch_history";

            // 1. Hàm lấy toàn bộ lịch sử
            function getWatchHistory() {
                try {
                    return JSON.parse(localStorage.getItem(WATCH_HISTORY_KEY)) || {};
                } catch {
                    return {};
                }
            }

            // 2. Hàm lưu tiến độ (Gọi liên tục khi xem)
            function saveWatchProgress(videoId, currentTime, duration) {
                if (!videoId) return;

                // Chỉ lưu khi đã xem được trên 5 giây
                if (currentTime < 5) return;

                const history = getWatchHistory();

                // Tính phần trăm đã xem
                const percent = duration > 0 ? currentTime / duration : 0;

                // Nếu xem > 95% thì coi như đã xong -> Xóa khỏi danh sách xem dở (hoặc reset về 0)
                // Ở đây mình giữ lại nhưng đánh dấu finished để vẽ UI khác nếu muốn
                const isFinished = percent > 0.95;

                history[videoId] = {
                    videoId: videoId,
                    time: currentTime,
                    duration: duration,
                    percent: percent,
                    lastUpdated: new Date().getTime(), // Để sắp xếp cái nào mới xem thì hiện đầu
                    isFinished: isFinished,
                };

                localStorage.setItem(WATCH_HISTORY_KEY, JSON.stringify(history));

                // Update lại UI nếu đang mở menu tập phim (để hiện thanh đỏ realtime - nâng cao)
            }

            // 3. Hàm lấy thời gian đã lưu của 1 video
            function getSavedTime(videoId) {
                const history = getWatchHistory();
                const data = history[videoId];
                // Nếu đã xem xong (isFinished) hoặc chưa xem bao giờ -> Trả về 0
                if (!data || data.isFinished) return 0;
                return data.time;
            }
function setupModalScrolling() {
    // Helper function để setup cho 1 cặp list + buttons
    const setupOneList = (listId, leftBtnId, rightBtnId) => {
        const list = document.getElementById(listId);
        const btnLeft = document.getElementById(leftBtnId);
        const btnRight = document.getElementById(rightBtnId);

        if (!list || !btnLeft || !btnRight) return () => {}; // Return no-op

        const checkArrows = () => {
            const scrollLeft = list.scrollLeft;
            const maxScroll = list.scrollWidth - list.clientWidth - 2;

            if (scrollLeft <= 0) btnLeft.classList.add("hidden-arrow");
            else btnLeft.classList.remove("hidden-arrow");

            if (scrollLeft >= maxScroll) btnRight.classList.add("hidden-arrow");
            else btnRight.classList.remove("hidden-arrow");
        };

        btnLeft.onclick = (e) => {
            e.stopPropagation();
            list.scrollBy({ left: -300, behavior: "smooth" });
        };

        btnRight.onclick = (e) => {
            e.stopPropagation();
            list.scrollBy({ left: 300, behavior: "smooth" });
        };

        list.addEventListener("wheel", (evt) => {
            if (list.scrollWidth > list.clientWidth) {
                evt.preventDefault();
                list.scrollLeft += evt.deltaY * 3;
            }
        }, { passive: false });

        list.addEventListener("scroll", checkArrows);
        
        // Trả về hàm check để gọi từ bên ngoài
        return checkArrows;
    };

    // Setup cho danh sách Tập
    const checkEpisodes = setupOneList("modal-episodes-list", "modal-arrow-left", "modal-arrow-right");
    
    // Setup cho danh sách Related (Mới)
    const checkRelated = setupOneList("modal-related-list", "modal-related-arrow-left", "modal-related-arrow-right");

    // Tạo hàm global để update cả 2 (dùng trong openDetailModal)
    window.updateModalArrows = () => {
        if(checkEpisodes) checkEpisodes();
        if(checkRelated) checkRelated();
    };
}
// GỌI HÀM NÀY NGAY KHI KHỞI TẠO (Trong setupEventListeners hoặc cuối file)
setupModalScrolling();
        </script>
        
        <script src="https://www.youtube.com/iframe_api"></script>
    </body>
</html>
