<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>B·∫£ng ƒëi·ªÅu khi·ªÉn Th∆∞ vi·ªán</title>
  <!-- Th∆∞ vi·ªán SortableJS ƒë·ªÉ k√©o th·∫£ (gi·ªØ nguy√™n) -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>

  <script src="https://www.youtube.com/iframe_api"></script>
  <!-- Google Fonts ƒë·ªÉ c√≥ font ch·ªØ ƒë·∫πp -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <svg width="0" height="0" style="position:absolute">
    <symbol id="icon-plus" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" /></symbol>
    <symbol id="icon-trash" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></symbol>
    <symbol id="icon-edit" viewBox="0 0 20 20" fill="currentColor"><path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" /><path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd" /></symbol>
    <symbol id="icon-refresh" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm12 8a1 1 0 011 1v2.101a7.002 7.002 0 01-11.601 2.566 1 1 0 111.885-.666A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h4a1 1 0 011 1z" clip-rule="evenodd" /></symbol>
    <symbol id="icon-save" viewBox="0 0 20 20" fill="currentColor"><path d="M7.707 10.293a1 1 0 10-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 11.586V6a1 1 0 10-2 0v5.586L7.707 10.293zM3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" /></symbol>
    <symbol id="icon-tag" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A1 1 0 012 10V5a1 1 0 011-1h5a1 1 0 01.707.293l7 7zM6 6a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd" /></symbol>
    <symbol id="icon-config" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.532 1.532 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.532 1.532 0 01-.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" /></symbol>
    <symbol id="icon-close" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></symbol>
    <symbol id="icon-drag" viewBox="0 0 20 20" fill="currentColor"><path d="M5 3a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 5h10v10H5V5z" /><path d="M7 7h2v2H7V7zM7 11h2v2H7v-2zM11 7h2v2h-2V7zM11 11h2v2h-2v-2z" /></symbol>
  </svg>
<style>
    :root {
        --bg-main: #f8f9fa;
        --bg-panel: #ffffff;
        --bg-input: #f1f3f4;
        --text-primary: #202124;
        --text-secondary: #5f6368;
        --border-color: #dee2e6;
        --accent-blue: #1a73e8;
        --accent-green: #1e8e3e;
        --accent-red: #d93025;
        --shadow-sm: 0 1px 2px 0 rgba(60,64,67,0.1);
        --shadow-md: 0 1px 3px 0 rgba(60,64,67,0.2), 0 2px 6px 2px rgba(60,64,67,0.15);
    }
    
    *, *::before, *::after { box-sizing: border-box; }
    
    /* --- B·ªë c·ª•c to√†n trang (No-Scroll) --- */
    html, body { height: 100vh; margin: 0; overflow: hidden; }
    body { font-family: 'Inter', sans-serif; background-color: var(--bg-main); color: var(--text-primary); display: flex; flex-direction: column; }
    main { flex-grow: 1; padding: 20px; display: flex; flex-direction: column; min-height: 0; }
    .panel { background-color: var(--bg-panel); padding: 25px 30px; border-radius: 12px; border: 1px solid var(--border-color); box-shadow: var(--shadow-sm); }

    /* --- Typography & Icons --- */
    h1, h2, h3 { margin-top: 0; font-weight: 600; color: var(--text-primary); }
    h1 { font-size: 1.8rem; }
    h2 { font-size: 1.4rem; padding-bottom: 0; border: none; }
    h3 { font-size: 1.1rem; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); margin-bottom: 15px; }
    .icon { width: 1.25em; height: 1.25em; vertical-align: middle; }

    /* --- Form Elements --- */
    .form-group { margin-bottom: 20px; }
    label { display: block; font-weight: 500; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem; }
    input, textarea, select { width: 100%; padding: 12px; font-size: 1rem; border: 1px solid var(--border-color); border-radius: 8px; background-color: var(--bg-input); color: var(--text-primary); transition: box-shadow 0.2s; }
    input:focus, textarea:focus, select:focus { outline: none; box-shadow: 0 0 0 2px var(--accent-blue); border-color: var(--accent-blue); }
    
    /* --- Buttons --- */
    button { padding: 12px 24px; font-size: 1rem; font-weight: 600; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
    button:disabled { background-color: #bdc1c6 !important; cursor: not-allowed; transform: none !important; color: #80868b; box-shadow: none !important; }
    .btn-primary { background-color: var(--accent-blue); color: white; }
    .btn-primary:hover:not(:disabled) { box-shadow: 0 1px 3px 1px rgba(66,133,244,.3); background-color: #297be6; }
    .btn-secondary { background-color: var(--accent-green); color: white; }
    .btn-secondary:hover:not(:disabled) { box-shadow: 0 1px 3px 1px rgba(30,142,62,.3); }
    .btn-danger { background-color: var(--accent-red); color: white; }
    .btn-danger:hover:not(:disabled) { box-shadow: 0 1px 3px 1px rgba(217,48,37,.3); }
    .btn-neutral { background-color: #f1f3f4; color: var(--text-secondary); border: 1px solid var(--border-color); }
    .btn-neutral:hover:not(:disabled) { background-color: #e8eaed; color: var(--text-primary); }

    /* --- Utility --- */
    .hidden { display: none !important; }
    .spinner { animation: spin 1s linear infinite; width: 20px; height: 20px; }
    @keyframes spin { 100% { transform: rotate(360deg); } }

    /* --- Tag Input Component (Original + Refined) --- */
    .tag-input-container { display: flex; flex-wrap: wrap; align-items: center; gap: 8px; background-color: var(--bg-input); border: 1px solid var(--border-color); border-radius: 8px; padding: 8px; }
    .tag-pill { display: flex; align-items: center; background-color: var(--accent-blue); color: white; padding: 4px 10px; border-radius: 16px; font-size: 0.9rem; white-space: nowrap; }
    .tag-remove-btn { margin-left: 8px; background: none; border: none; color: white; opacity: 0.7; cursor: pointer; padding: 0; font-weight: bold; line-height: 1; }
    .tag-remove-btn:hover { opacity: 1; }
    .tag-editor-input { flex-grow: 1; border: none; background: none; padding: 4px; min-width: 120px; outline: none; font-size: 1rem; }
    .autocomplete-suggestions { position: relative; }
    .autocomplete-list { position: absolute; top: 100%; left: 0; right: 0; background-color: var(--bg-panel); border: 1px solid var(--border-color); border-radius: 0 0 8px 8px; max-height: 200px; overflow-y: auto; z-index: 10; box-shadow: 0 4px 6px rgba(32,33,36,.28); margin-top: -1px; }
    .suggestion-item { padding: 10px; cursor: pointer; }
    .suggestion-item:hover, .suggestion-item.active { background-color: #e8f0fe; color: var(--accent-blue); }

    /* --- C·∫•u tr√∫c Layout ch√≠nh --- */
    #config-panel { max-width: 600px; margin: auto; }
   /* --- LAYOUT CH√çNH (SPA) --- */
    #uploader-panel { 
        flex-grow: 1; /* Chi·∫øm h·∫øt kho·∫£ng tr·ªëng c√≤n l·∫°i */
        display: flex; 
        flex-direction: column; 
        min-height: 0; /* Quan tr·ªçng ƒë·ªÉ con scroll ƒë∆∞·ª£c */
        gap: 10px; 
        overflow: hidden; /* NgƒÉn scroll body */
    }
    
    #dashboard-layout { flex-grow: 1; display: grid; grid-template-columns: minmax(400px, 2fr) 1fr; gap: 20px; min-height: 0; }
    @media (max-width: 1200px) { #dashboard-layout { grid-template-columns: 1fr; } }
    
    /* --- Panel b√™n trong Dashboard --- */
    #library-list-panel, #editor-panel { display: flex; flex-direction: column; min-height: 0; }
    .panel-header { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; padding-bottom: 20px; margin-bottom: 20px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
    .panel-header .actions { display: flex; gap: 10px; }

    /* --- Library List --- */
    #library-list-container { flex-grow: 1; overflow-y: auto; padding: 5px; margin: 0 -5px; }
    .program-group { background-color: #f1f3f4; border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 20px; }
    .program-group-header { padding: 15px; font-size: 1.1rem; font-weight: 600; cursor: grab; display: flex; align-items: center; gap: 10px; color: var(--text-primary); border-bottom: 1px solid var(--border-color); }
    .program-group-header .icon-drag { color: var(--text-secondary); }
    .video-card-list { padding: 15px; }
    .video-card-item { display: flex; align-items: center; gap: 15px; background-color: var(--bg-panel); padding: 12px; border-radius: 8px; margin-bottom: 10px; cursor: grab; border: 1px solid var(--border-color); transition: all 0.2s ease; }
    .video-card-item:hover { transform: translateY(-2px); box-shadow: var(--shadow-md); border-color: #cdd2d6; }
    .video-card-item.active { box-shadow: 0 0 0 3px var(--accent-blue); border-color: var(--accent-blue); }
    .video-card-thumbnail-wrapper { position: relative; width: 120px; height: 67px; flex-shrink: 0; }
    .video-card-thumbnail { width: 100%; height: 100%; object-fit: cover; border-radius: 4px; }
    .video-card-duration { position: absolute; bottom: 5px; right: 5px; background-color: rgba(0,0,0,0.75); color: white; font-size: 0.75rem; padding: 2px 5px; border-radius: 4px; }
    .video-card-info { flex-grow: 1; overflow: hidden; min-width: 0; }
    .video-card-title { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .video-card-meta { font-size: 0.85rem; color: var(--text-secondary); }
    .video-card-actions { display: flex; gap: 8px; opacity: 0; transition: opacity 0.2s; }
    .video-card-item:hover .video-card-actions { opacity: 1; }
    .video-card-actions button { width: 32px; height: 32px; padding: 0; background: var(--bg-input); color: var(--text-secondary); border: 1px solid transparent; }
    .video-card-actions button:hover { background: #e8eaed; color: var(--text-primary); border-color: var(--border-color); }

    /* --- Editor Panel --- */
    .editor-content-wrapper { flex-grow: 1; overflow-y: auto; margin: 0 -15px; padding: 0 15px; }
    .editor-actions { margin-top: auto; padding-top: 20px; display: flex; flex-direction: column; gap: 10px; }

   /* --- Status Log (Ghim ƒë√°y) --- */
    #status-log { 
        flex-shrink: 0; 
        height: 40px; /* Chi·ªÅu cao c·ªë ƒë·ªãnh nh·ªè g·ªçn */
        background-color: #3c4043; 
        color: white; 
        padding: 0 15px; 
        border-radius: 8px; 
        font-family: monospace; 
        font-size: 0.85rem; 
        display: flex; 
        align-items: center; /* CƒÉn gi·ªØa ch·ªØ theo chi·ªÅu d·ªçc */
        white-space: nowrap; 
        overflow: hidden; 
        text-overflow: ellipsis; 
        margin-top: 10px; 
    }


    /* --- Modal Qu·∫£n l√Ω Tag --- */
    .modal-overlay { position: fixed; inset: 0; background-color: rgba(32,33,36,0.5); z-index: 999; backdrop-filter: blur(4px); }
    #tag-manager-modal { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; width: 90%; max-width: 900px; }
    #tag-manager-close-btn { position: absolute; top: 15px; right: 15px; width: 40px; height: 40px; padding: 0; background: none; border: none; color: var(--text-secondary); }
    #tag-manager-close-btn:hover { color: var(--text-primary); background: var(--bg-input); }
    .tag-manager-layout { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
    .tag-list { list-style: none; padding: 0; max-height: 300px; overflow-y: auto; background-color: var(--bg-main); border: 1px solid var(--border-color); padding: 10px; border-radius: 6px; }
    .tag-list li { display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid var(--border-color); }
    .tag-list li:last-child { border-bottom: none; }
    .tag-list-actions button { width: auto; height: auto; padding: 5px; margin-left: 5px; }
    .tag-add-group { display: flex; gap: 5px; }
    .tag-add-group input { flex-grow: 1; }
    .tag-add-group button { width: 44px; flex-shrink: 0; padding: 10px; }
    #form-title {
    max-height: 4.5rem;   /* Gi·ªõi h·∫°n chi·ªÅu cao c·ªßa ti√™u ƒë·ªÅ, t∆∞∆°ng ƒë∆∞∆°ng kho·∫£ng 2-3 d√≤ng ch·ªØ */
    overflow-y: auto;     /* T·ª± ƒë·ªông hi·ªÉn th·ªã thanh cu·ªôn d·ªçc KHI n·ªôi dung d√†i h∆°n chi·ªÅu cao tr√™n */
    padding-right: 10px;  /* T·∫°o m·ªôt ch√∫t kho·∫£ng tr·ªëng b√™n ph·∫£i ƒë·ªÉ thanh cu·ªôn kh√¥ng d√≠nh v√†o ch·ªØ */
    line-height: 1.4;     /* Gi√∫p vƒÉn b·∫£n hi·ªÉn th·ªã ƒë·∫πp h∆°n khi c√≥ nhi·ªÅu d√≤ng */
    text-align: left;     /* ƒê·∫£m b·∫£o vƒÉn b·∫£n lu√¥n cƒÉn tr√°i */

}
/* --- S·ª¨A: Header Navigation (Tabs + Repo Info) --- */
    .nav-header-wrapper {
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 2px solid var(--border-color); /* Chuy·ªÉn g·∫°ch ch√¢n xu·ªëng ƒë√¢y */
        margin-bottom: 20px;
        padding-bottom: 10px;
        flex-wrap: wrap; /* Xu·ªëng d√≤ng n·∫øu m√†n h√¨nh qu√° nh·ªè */
        gap: 15px;
    }

    .nav-tabs { 
        display: flex; 
        gap: 10px; 
        /* X√≥a border v√† margin c≈© ƒëi v√¨ ƒë√£ chuy·ªÉn sang wrapper */
        margin-bottom: 0; 
        border-bottom: none; 
        padding-bottom: 0;
    }
    
    .nav-tab { 
        padding: 8px 16px; /* Ch·ªânh l·∫°i ch√∫t cho g·ªçn */
        font-weight: 600; 
        color: var(--text-secondary); 
        cursor: pointer; 
        border-radius: 6px; 
        transition: background 0.2s;
    }
    .nav-tab:hover { background-color: #f1f3f4; }
    .nav-tab.active { background-color: #e8f0fe; color: var(--accent-blue); }

    /* Ch·ªânh l·∫°i Repo Info cho g·ªçn ƒë·ªÉ nh√©t v·ª´a b√™n ph·∫£i */
    #repo-info { 
        flex-shrink: 0; 
        font-size: 0.85rem; 
        color: var(--text-secondary); 
        background: var(--bg-panel); 
        padding: 6px 12px; 
        border-radius: 20px; /* Bo tr√≤n ki·ªÉu pill cho ƒë·∫πp */
        border: 1px solid var(--border-color); 
        margin: 0; /* X√≥a margin c≈© */
    }
   /* --- Subtitle Editor Layout (ƒê√£ t·ªëi ∆∞u: B·ªè Waveform) --- */
    /* --- VIEW 2: SUBTITLE EDITOR (LAYOUT 40/60) --- */
    #subtitle-editor-panel { 
        display: flex; 
        flex-direction: row; /* Chia ngang */
        height: 100%; 
        min-height: 0; 
        gap: 15px; 
        overflow: hidden;
    }
    
    /* C·ªòT TR√ÅI (40%) */
    .editor-left-panel {
        width: 40%;
        display: flex;
        flex-direction: column;
        gap: 15px;
        min-width: 320px;
    }

    /* Khung Video & Overlay */
    .video-wrapper {
        position: relative;
        width: 100%;
        padding-top: 56.25%; /* T·ª∑ l·ªá 16:9 */
        background: #000;
        border-radius: 8px;
        overflow: hidden;
        flex-shrink: 0;
    }
    #editor-player {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
    }
    /* Ph·ª• ƒë·ªÅ ƒë√® l√™n video */
    #video-overlay-text {
        position: absolute;
        bottom: 20px;
        left: 10px; right: 10px;
        text-align: center;
        color: #fff;
        font-size: 1.1rem;
        font-weight: 600;
        text-shadow: 0 0 4px rgba(0,0,0,0.9), 0 1px 2px black;
        pointer-events: none; /* ƒê·ªÉ click xuy√™n qua video */
        z-index: 10;
        background: rgba(0,0,0,0.4);
        padding: 5px;
        border-radius: 4px;
        min-height: 1.5em;
    }

    /* Khu v·ª±c n√∫t b·∫•m b√™n d∆∞·ªõi video */
    .editor-controls-area {
        flex-grow: 1;
        background: var(--bg-input);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 15px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    .control-box {
        background: #fff;
        padding: 10px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
    }
    .control-box h4 { margin: 0 0 10px 0; font-size: 0.9rem; color: var(--accent-blue); border-bottom: 1px solid #eee; padding-bottom: 5px; }
    .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

    /* C·ªòT PH·∫¢I (60%) - B·∫£ng Nh·∫≠p Li·ªáu */
    .editor-right-panel {
        width: 60%;
        display: flex;
        flex-direction: column;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background: #fff;
    }
    .subtitle-grid-wrapper {
        flex-grow: 1;
        overflow-y: auto;
    }
    
    .editor-top-section { 
        
        flex-shrink: 0; 
        display: flex; /* D√πng Flex thay v√¨ Grid */
        justify-content: center;
        background: #000;
        border-radius: 8px;
        overflow: hidden;
    }
    
    .video-preview-box { width: 100%; height: 100%; position: relative; max-width: 800px; /* Gi·ªõi h·∫°n chi·ªÅu r·ªông video cho ƒë·ª° v·ª° h√¨nh */ }
    #editor-player { width: 100%; height: 100%; }

    /* X√ìA class .waveform-box, #waveform, #wave-timeline v√¨ kh√¥ng d√πng n·ªØa */

    .editor-controls { 
        flex-shrink: 0;
        display: flex; justify-content: space-between; align-items: center; 
        padding: 8px 12px; background: var(--bg-input); border-radius: 8px; border: 1px solid var(--border-color);
    }
    
    .editor-controls .group { display: flex; gap: 5px; }

    .subtitle-grid-wrapper { flex-grow: 1; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 8px; background: white; position: relative; }
    .view-content { 
        flex-grow: 1; 
        min-height: 0; /* Quan tr·ªçng */
        display: flex; 
        flex-direction: column; 
        overflow: hidden; /* ƒê·ªÉ scroll b√™n trong */
    }
    /* Table Styling */
    .sub-table { width: 100%; border-collapse: collapse; table-layout: fixed; }
    .sub-table th { position: sticky; top: 0; background: #f8f9fa; z-index: 2; padding: 10px; text-align: left; border-bottom: 2px solid var(--border-color); font-size: 0.9rem; color: var(--text-secondary); }
    .sub-table td { border-bottom: 1px solid #eee; padding: 5px; vertical-align: top; }
    
    .col-id { width: 50px; text-align: center; color: #aaa; }
    .col-time { width: 200px; }
    .col-text { width: auto; }
    .col-action { width: 60px; text-align: center; }

    .time-input { font-family: monospace; width: 100%; padding: 5px; border: 1px solid transparent; border-radius: 4px; background: #f8f9fa; font-size: 0.9rem; }
    .time-input:focus { border-color: var(--accent-blue); background: white; }
    .time-input.error { border-color: var(--accent-red); background: #fff0f0; }

    .text-input { width: 100%; padding: 8px; border: 1px solid transparent; border-radius: 4px; resize: none; overflow: hidden; font-family: inherit; line-height: 1.4; min-height: 38px; }
    .text-input:focus { border-color: var(--accent-blue); background: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }

    .sub-row.active { background-color: #e8f0fe; }
    .sub-row:hover { background-color: #f8f9fa; }
    
    .btn-icon { padding: 6px; width: 32px; height: 32px; border-radius: 4px; color: var(--text-secondary); background: none; }
    .btn-icon:hover { background: #e0e0e0; color: var(--text-primary); }
    .btn-icon.delete:hover { background: #fce8e6; color: var(--accent-red); }

    /* Custom Scrollbar for editor */
    .subtitle-grid-wrapper::-webkit-scrollbar { width: 8px; }
    .subtitle-grid-wrapper::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }

    /* --- CSS M·ªöI CHO EDITOR N√ÇNG CAO --- */

/* 1. Style cho d√≤ng ƒë∆∞·ª£c ch·ªçn nhi·ªÅu (Multi-select) */
.sub-row.multi-selected {
    background-color: #ffe0b2 !important; /* M√†u cam nh·∫°t ƒë·ªÉ kh√°c v·ªõi m√†u active xanh */
    border-left: 4px solid #fb8c00;
}

/* 2. Style cho Modal Find/Replace v√† Offset (nh·ªè g·ªçn, n·ªïi l√™n tr√™n) */
.editor-modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.4); z-index: 2000;
    display: none; justify-content: center; align-items: center;
}
.editor-modal {
    background: #fff; padding: 20px; border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3); width: 400px;
    display: flex; flex-direction: column; gap: 15px;
}
.editor-modal h3 { margin: 0; border-bottom: 1px solid #eee; padding-bottom: 10px; }
.editor-modal .row { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
.editor-modal label { margin: 0; min-width: 80px; }

/* 3. Button tr√™n thanh c√¥ng c·ª• editor */
.editor-toolbar-btn {
    padding: 6px 12px; font-size: 0.9rem; background: #fff; 
    border: 1px solid #ccc; border-radius: 4px; cursor: pointer;
}
.editor-toolbar-btn:hover { background: #f1f1f1; }
/* --- Season Divider Style --- */
.season-divider {
    width: 100%;
    padding: 8px 12px;
    margin-top: 15px;
    margin-bottom: 10px;
    background-color: #e8f0fe; /* M√†u xanh nh·∫°t */
    color: var(--accent-blue);
    font-weight: 700;
    font-size: 0.95rem;
    border-radius: 6px;
    border-left: 4px solid var(--accent-blue);
    display: flex;
    align-items: center;
}
/* ·∫®n divider n·∫øu l√† ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n trong list (t√πy ch·ªçn, ·ªü ƒë√¢y ta c·ª© hi·ªán cho r√µ) */
.video-card-list .season-divider:first-child {
    margin-top: 0;
}
</style>
</head>
<body>
<main>
  <!-- Panel C·∫•u H√¨nh Ban ƒê·∫ßu -->
    <div class="panel" id="config-panel">
    <h1><svg class="icon" style="vertical-align: -3px; margin-right: 8px;"><use xlink:href="#icon-config"></use></svg>C·∫•u h√¨nh K·∫øt n·ªëi</h1>
    <p style="margin-top: -15px; margin-bottom: 25px; color: var(--text-secondary);">Nh·∫≠p th√¥ng tin kho l∆∞u tr·ªØ GitHub c·ªßa b·∫°n ƒë·ªÉ b·∫Øt ƒë·∫ßu.</p>
    <div class="form-group"><label for="gh-username">T√™n ng∆∞·ªùi d√πng GitHub</label><input type="text" id="gh-username" placeholder="v√≠ d·ª•: ten-cua-ban"></div>
    <div class="form-group"><label for="gh-repo">T√™n Kho l∆∞u tr·ªØ</label><input type="text" id="gh-repo" placeholder="v√≠ d·ª•: du-an-video"></div>
    <div class="form-group">
      <label for="gh-app-path">ƒê∆∞·ªùng d·∫´n G·ªëc App (ƒë·ªÉ tr·ªëng n·∫øu ·ªü th∆∞ m·ª•c g·ªëc)</label>
      <input type="text" id="gh-app-path" placeholder="v√≠ d·ª•: my-app/">
    </div>
    <div class="form-group">
      <label for="gh-srt-path">ƒê∆∞·ªùng d·∫´n Th∆∞ m·ª•c Ph·ª• ƒë·ªÅ</label>
      <input type="text" id="gh-srt-path" value="subtitles/">
    </div>
    <div class="form-group"><label for="gh-token">Personal Access Token (PAT)</label><input type="password" id="gh-token" placeholder="d√°n token c·ªßa b·∫°n v√†o ƒë√¢y"></div>

<div class="form-group"><label for="yt-api-key">YouTube API Key (ƒê·ªÉ l·∫•y ng√†y ƒëƒÉng ch√≠nh x√°c)</label><input type="password" id="yt-api-key" placeholder="AIzaSy..."></div>
    <button id="save-config-btn" class="btn-primary" style="width: 100%;">L∆∞u v√† B·∫Øt ƒë·∫ßu</button>
  </div>

  <div class="hidden" id="uploader-panel">
    
    <div class="nav-header-wrapper">
        <div class="nav-tabs">
            <button class="nav-tab active" data-target="library-view">üìÇ Th∆∞ vi·ªán Video</button>
            <button class="nav-tab" data-target="editor-view" id="nav-editor-btn">üé¨ Ch·ªânh s·ª≠a Ph·ª• ƒë·ªÅ</button>
        </div>

        <div id="repo-info"></div>
    </div>
    <div id="library-view" class="view-content">
        <div id="dashboard-layout">
            <div id="library-list-panel" class="panel">
                <div class="panel-header">
                    <h2>Th∆∞ vi·ªán Video</h2>
                    <div class="actions">
                        <button id="manage-tags-btn" class="btn-neutral"><svg class="icon"><use xlink:href="#icon-tag"></use></svg> Qu·∫£n l√Ω Tags</button>
                        <button id="batch-refresh-btn" class="btn-neutral" title="C·∫≠p nh·∫≠t l·∫°i ·∫£nh, ng√†y ƒëƒÉng, t√™n g·ªëc cho to√†n b·ªô video"><svg class="icon"><use xlink:href="#icon-refresh"></use></svg> Update All</button>
                        <button id="save-order-btn" class="btn-secondary hidden"><svg class="icon"><use xlink:href="#icon-save"></use></svg> L∆∞u Th·ª© t·ª±</button>
                        <button id="reset-config-btn" class="btn-danger"><svg class="icon"><use xlink:href="#icon-config"></use></svg> ƒê·ªïi C·∫•u h√¨nh</button>
                    </div>
                </div>
                <div id="library-list-container"></div>
            </div>

            <div id="editor-panel" class="panel">
                <div class="panel-header"><h2 id="form-title">Th√™m Video M·ªõi</h2></div>
                <div class="editor-content-wrapper">
                    <div class="form-group"><label for="youtube-url">Link YouTube</label><input type="text" id="youtube-url"></div>
                    <div class="form-group"><label for="user-title">T√™n hi·ªÉn th·ªã</label><input type="text" id="user-title"></div>
<div class="form-group" style="display: flex; gap: 15px;">
    <div style="flex: 1;">
        <label for="season-number">M√πa (Season)</label>
        <input type="number" id="season-number" placeholder="VD: 1 (ƒê·ªÉ tr·ªëng n·∫øu ko c√≥)">
    </div>
    <div style="flex: 1;">
        <label for="episode-number">S·ªë t·∫≠p</label>
        <input type="number" id="episode-number" placeholder="VD: 5">
    </div>
</div>                    
<div class="form-group"><label for="program-select">Ch∆∞∆°ng tr√¨nh</label><select id="program-select"></select></div>
                    <div class="form-group">
                        <label>Ng∆∞·ªùi tham gia</label>
                        <div class="tag-input-container"><div id="participants-tags-container"></div><input type="text" class="tag-editor-input" id="participants-input" placeholder="Th√™m..."></div>
                        <div class="autocomplete-suggestions"><div id="participants-autocomplete-list" class="autocomplete-list"></div></div>
                    </div>
                    <div class="form-group">
                        <label>Th·ªÉ lo·∫°i</label>
                        <div class="tag-input-container"><div id="genres-tags-container"></div><input type="text" class="tag-editor-input" id="genres-input" placeholder="Th√™m..."></div>
                        <div class="autocomplete-suggestions"><div id="genres-autocomplete-list" class="autocomplete-list"></div></div>
                    </div>
                    <div class="form-group"><label for="description">M√¥ t·∫£</label><textarea id="description" rows="4"></textarea></div>
                    <div class="form-group"><label>Ph√¢n ƒëo·∫°n (Bookmark)</label><div id="bookmarks-list"></div><button type="button" class="btn-neutral" onclick="addBookmarkRow()">‚ûï Th√™m ph√¢n ƒëo·∫°n</button></div>
                    <div class="form-group"><label for="srt-file">File ph·ª• ƒë·ªÅ (.srt)</label><input type="file" id="srt-file" accept=".srt"></div>
                </div>
                <div class="editor-actions">
                    <button id="deploy-btn" class="btn-primary">Th√™m Video</button>
                    <button id="cancel-edit-btn" class="btn-neutral hidden">H·ªßy</button>
                </div>
            </div>
        </div>
    </div>

    <div id="editor-view" class="view-content hidden">
        <div id="subtitle-editor-panel">
            
            <div class="editor-left-panel">
                <div class="video-wrapper">
                    <div id="editor-player"></div>
                    <div id="video-overlay-text"></div> </div>

                <div class="editor-controls-area">
                    <div class="control-box">
                        <h4 id="editor-video-title">T√™n Video...</h4>
                        <div id="video-current-time-display" style="font-family:monospace; font-size:1.5rem; font-weight:700; color:var(--accent-blue); text-align:center; margin-bottom:10px; background:#f1f3f4; padding:5px; border-radius:4px;">00:00:00</div>
                        <div class="btn-grid">
                            <button class="btn-primary" id="editor-play-btn">‚ñ∂ Play / Pause</button>
                            <button class="btn-neutral" onclick="SubEditor.insertRow()">‚ûï Th√™m d√≤ng m·ªõi</button>
                        </div>
                    </div>

                    <div class="control-box">
                        <h4>CƒÉn ch·ªânh d√≤ng ƒëang ch·ªçn (<span id="current-row-idx">#</span>)</h4>
                        <div class="btn-grid">
                            <button class="btn-secondary" onclick="SubEditor.snapStart()" title="Start = End d√≤ng tr∆∞·ªõc">‚èÆ Start = End tr∆∞·ªõc</button>
                            <button class="btn-secondary" onclick="SubEditor.snapEnd()" title="End = Start d√≤ng sau">‚è≠ End = Start sau</button>
                        </div>
                        <div style="margin-top: 10px; font-size: 0.8rem; color: #666;">
                            <i>M·∫πo: LƒÉn chu·ªôt v√†o √¥ th·ªùi gian ƒë·ªÉ ch·ªânh gi√¢y. Click v√†o s·ªë th·ª© t·ª± ƒë·ªÉ tua.</i>
                        </div>
                    </div>
                    <div class="control-box">
    <h4>C√¥ng c·ª• h√†ng lo·∫°t</h4>
    <div class="btn-grid">
        <button class="editor-toolbar-btn" onclick="SubEditor.openFindReplace()">üîç T√¨m / Thay th·∫ø</button>
        <button class="editor-toolbar-btn" onclick="SubEditor.openOffset()">‚è±Ô∏è Offset (D·ªãch sub)</button>
        <button class="editor-toolbar-btn" onclick="SubEditor.deleteSelectedRows()" style="grid-column: span 2; color: #d93025; border-color: #d93025;">
                                üóë X√≥a c√°c d√≤ng ƒëang ch·ªçn
                            </button>
    </div>
    <div style="margin-top:5px; font-size: 0.8rem; color:#555;">
        <ul>
            <li><b>Ctrl + Click s·ªë th·ª© t·ª±:</b> Ch·ªçn nhi·ªÅu d√≤ng.</li>
            <li><b>Ctrl + Alt + Click s·ªë:</b> Ch·ªçn ƒë·∫øn h·∫øt.</li>
            <li><b>Ctrl + Click √¥ Start:</b> N·ªëi ƒëu√¥i d√≤ng tr∆∞·ªõc.</li>
            <li><b>Ctrl + Click √¥ End:</b> N·ªëi ƒë·∫ßu d√≤ng sau.</li>
        </ul>
    </div>
</div>

                    <div class="control-box" style="margin-top: auto;">
                        <div class="btn-grid">
                            <button class="btn-primary" id="save-srt-gh-btn">üíæ L∆∞u GitHub</button>
                            <button class="btn-danger" onclick="SubEditor.close()">‚ùå ƒê√≥ng</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="editor-right-panel subtitle-grid-wrapper">
                <table class="sub-table">
                    <thead>
                        <tr>
                            <th class="col-id">#</th>
                            <th class="col-time">Timing (Start ‚ûú End)</th>
                            <th class="col-text">N·ªôi dung</th>
                            <th class="col-action"></th>
                        </tr>
                    </thead>
                    <tbody id="subtitle-tbody"></tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="status-log"></div>
  </div>

  <div id="tag-manager-modal-wrapper" class="hidden">
    <div class="modal-overlay"></div>
    <div id="tag-manager-modal" class="panel">
      <button id="tag-manager-close-btn" class="btn-neutral">
        <svg class="icon"><use xlink:href="#icon-close"></use></svg>
      </button>
      <h2 style="padding-bottom: 15px; border-bottom: 1px solid var(--border-color); margin-bottom: 20px;">Qu·∫£n l√Ω Tags</h2>
      <div class="tag-manager-layout">
          <div>
              <h3>Ch∆∞∆°ng tr√¨nh</h3>
              <div class="form-group tag-add-group">
                <input id="new-program-input" placeholder="Th√™m ch∆∞∆°ng tr√¨nh..."><button id="add-program-btn" class="btn-secondary"><svg class="icon"><use xlink:href="#icon-plus"></use></svg></button>
              </div>
              <ul id="programs-tag-list" class="tag-list"></ul>
          </div>
          <div>
              <h3>Ng∆∞·ªùi tham gia</h3>
              <div class="form-group tag-add-group">
                <input id="new-participant-input" placeholder="Th√™m ng∆∞·ªùi tham gia..."><button id="add-participant-btn" class="btn-secondary"><svg class="icon"><use xlink:href="#icon-plus"></use></svg></button>
              </div>
              <ul id="participants-tag-list" class="tag-list"></ul>
          </div>
          <div>
              <h3>Th·ªÉ lo·∫°i</h3>
              <div class="form-group tag-add-group">
                <input id="new-genre-input" placeholder="Th√™m th·ªÉ lo·∫°i..."><button id="add-genre-btn" class="btn-secondary"><svg class="icon"><use xlink:href="#icon-plus"></use></svg></button>
              </div>
              <ul id="genres-tag-list" class="tag-list"></ul>
          </div>
      </div>
      <button id="save-tags-btn" class="btn-primary" style="margin-top: 20px; width: 100%;">L∆∞u v√† ƒê·ªìng b·ªô Thay ƒë·ªïi</button>
    </div>
  </div>
  <div id="find-replace-modal" class="editor-modal-overlay">
    <div class="editor-modal">
        <h3>T√¨m ki·∫øm & Thay th·∫ø (Ctrl+H)</h3>
        <div class="row">
            <label>T√¨m:</label>
            <input type="text" id="find-input" placeholder="T·ª´ kh√≥a...">
        </div>
        <div class="row">
            <label>Thay th·∫ø:</label>
            <input type="text" id="replace-input" placeholder="Thay th√†nh...">
        </div>
        <div class="row">
            <label>Ph·∫°m vi:</label>
            <select id="fr-scope">
                <option value="all">T·∫•t c·∫£ c√°c d√≤ng</option>
                <option value="selected">Ch·ªâ d√≤ng ƒëang ch·ªçn</option>
            </select>
        </div>
        <div class="row" style="justify-content: flex-end;">
            <button class="btn-neutral" onclick="SubEditor.closeModal('find-replace-modal')">ƒê√≥ng</button>
            <button class="btn-primary" onclick="SubEditor.performFindReplace()">Th·ª±c thi</button>
        </div>
    </div>
</div>

<div id="time-offset-modal" class="editor-modal-overlay">
    <div class="editor-modal">
        <h3>D·ªãch chuy·ªÉn th·ªùi gian (Offset)</h3>
        <p style="font-size:0.85rem; color:#666;">D√πng cho c√°c d√≤ng ƒëang ƒë∆∞·ª£c ch·ªçn (Multi-select).</p>
        <div class="row">
            <label>Th·ªùi gian (ms):</label>
            <input type="number" id="offset-input" placeholder="VD: 500 ho·∫∑c -1000">
        </div>
        <p style="font-size:0.8rem; color:#888;">* S·ªë d∆∞∆°ng: tr·ªÖ ƒëi (sub hi·ªán mu·ªôn h∆°n)<br>* S·ªë √¢m: s·ªõm h∆°n (sub hi·ªán s·ªõm h∆°n)</p>
        <div class="row" style="justify-content: flex-end;">
            <button class="btn-neutral" onclick="SubEditor.closeModal('time-offset-modal')">ƒê√≥ng</button>
            <button class="btn-primary" onclick="SubEditor.performOffset()">√Åp d·ª•ng</button>
        </div>
    </div>
</div>
</main>
<script>
    // JavaScript s·∫Ω ƒë∆∞·ª£c th√™m ·ªü ƒë√¢y.
	const doc = document;
// --- DOM Element Cache ---
const ui = {
    configPanel: doc.getElementById("config-panel"),
    uploaderPanel: doc.getElementById("uploader-panel"),
    saveConfigBtn: doc.getElementById("save-config-btn"),
    resetConfigBtn: doc.getElementById("reset-config-btn"),
    deployBtn: doc.getElementById("deploy-btn"),
    statusLog: doc.getElementById("status-log"),
    libraryListContainer: doc.getElementById("library-list-container"),
    formTitle: doc.getElementById("form-title"),
    cancelEditBtn: doc.getElementById("cancel-edit-btn"),
    saveOrderBtn: doc.getElementById("save-order-btn"),
    participantsTagsContainer: doc.getElementById("participants-tags-container"),
    autocompleteList: doc.getElementById("autocomplete-list"),
    manageTagsBtn: doc.getElementById("manage-tags-btn"),
    tagManagerModal: doc.getElementById("tag-manager-modal"),
    tagManagerCloseBtn: doc.getElementById("tag-manager-close-btn"),
    programsTagList: doc.getElementById("programs-tag-list"),
    participantsTagList: doc.getElementById("participants-tag-list"),
    genresTagList: doc.getElementById("genres-tag-list"),
    newProgramInput: doc.getElementById("new-program-input"),
    addProgramBtn: doc.getElementById("add-program-btn"),
    newParticipantInput: doc.getElementById("new-participant-input"),
    addParticipantBtn: doc.getElementById("add-participant-btn"),
    newGenreInput: doc.getElementById("new-genre-input"),
    addGenreBtn: doc.getElementById("add-genre-btn"),
    saveTagsBtn: doc.getElementById("save-tags-btn"),
    repoInfo: doc.getElementById("repo-info"), // FIX: Added back the missing reference
    inputs: {
        username: doc.getElementById("gh-username"),
        repo: doc.getElementById("gh-repo"),
        token: doc.getElementById("gh-token"),
        ytApiKey: doc.getElementById("yt-api-key"),
        appPath: doc.getElementById("gh-app-path"),
        srtPath: doc.getElementById("gh-srt-path"),
        youtubeUrl: doc.getElementById("youtube-url"),
        userTitle: doc.getElementById("user-title"),
        seasonNumber: doc.getElementById("season-number"),
        episodeNumber: doc.getElementById("episode-number"),
        programSelect: doc.getElementById("program-select"),
        participantsInput: doc.getElementById("participants-input"),
        participantsTagsContainer: doc.getElementById("participants-tags-container"),
        participantsAutocompleteList: doc.getElementById("participants-autocomplete-list"),
        genresInput: doc.getElementById("genres-input"),
        genresTagsContainer: doc.getElementById("genres-tags-container"),
        genresAutocompleteList: doc.getElementById("genres-autocomplete-list"),
        description: doc.getElementById("description"),
        srtFile: doc.getElementById("srt-file"),
    }
};

// --- State Management ---
let config = {}, currentLibrary = [], tagsData = { programs: [], participants: [], genres: [] },
    editingVideoId = null, isDirty = false, selectedParticipants = [], selectedGenres = [];
let sortableGroups, sortableVideos = [];

// --- Utility Functions ---
const log = (msg, isError = false) => { ui.statusLog.style.display = "block"; const el = doc.createElement("div"); el.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`; if (isError) el.style.color = "var(--accent-red)"; ui.statusLog.prepend(el); };
const toBase64 = (file) => new Promise((resolve, reject) => { const r = new FileReader(); r.readAsDataURL(file); r.onload = () => resolve(r.result.split(",")[1]); r.onerror = reject; });
const toBase64Str = (str) => btoa(unescape(encodeURIComponent(str)));
const fromBase64 = (str) => decodeURIComponent(escape(atob(str)));
const extractVideoID = (url) => (url.match(/(?:watch\?v=|youtu\.be\/|embed\/|v\/|e\/|shorts\/)([a-zA-Z0-9_-]{11})/) || [])[1] || null;
// --- ƒê√É S·ª¨A: H·ªó tr·ª£ YouTube Data API v3 ---
const getOEmbedData = async (videoId) => { 
    let apiData = {};
    
    // 1. N·∫øu c√≥ API Key, g·ªçi ch√≠nh ch·ªß Google ƒë·ªÉ l·∫•y ng√†y ƒëƒÉng chu·∫©n (publishedAt)
    if (config.youtubeApiKey) {
        try {
            const ytUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoId}&key=${config.youtubeApiKey}`;
            const ytRes = await fetch(ytUrl);
            const ytJson = await ytRes.json();
            if (ytJson.items && ytJson.items.length > 0) {
                // ƒê√¢y l√† c√°i b·∫°n c·∫ßn: Ng√†y gi·ªù ƒëƒÉng ch√≠nh x√°c
                apiData.publishedAt_official = ytJson.items[0].snippet.publishedAt; 
            }
        } catch (e) { console.warn("L·ªói YouTube API:", e); }
    }

    // 2. V·∫´n g·ªçi oEmbed/NoEmbed ƒë·ªÉ l·∫•y c√°c th√¥ng tin kh√°c (ƒë·ª° t·ªën quota Google)
    try { 
        const res = await fetch(`https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=${videoId}&format=json`); 
        if (!res.ok) throw new Error(); 
        const data = await res.json(); 
        
        const res2 = await fetch(`https://noembed.com/embed?url=https://www.youtube.com/watch?v=${videoId}`); 
        const data2 = await res2.json(); 
        
        // Tr·∫£ v·ªÅ d·ªØ li·ªáu g·ªôp: C≈© + M·ªõi (publishedAt_official)
        return {
            ...data, 
            upload_date: data2.upload_date, // C√°i c≈© (ch·ªâ c√≥ ng√†y)
            duration: data2.duration,
            ...apiData // Th√™m m·ª•c m·ªõi v√†o JSON tr·∫£ v·ªÅ
        }; 
    } catch (e) { throw new Error(`oEmbed failed for ${videoId}.`); } 
};
const showSpinner = (btn, text = "...") => { btn.disabled = true; btn.innerHTML = `<svg class="spinner" viewBox="0 0 50 50"><circle cx="25" cy="25" r="20" fill="none" stroke-width="5" stroke="currentColor" stroke-linecap="round"></circle></svg> ${text}`; };
const hideSpinner = (btn, text) => { btn.disabled = false; btn.innerHTML = text; };
function parseBookmarksInput(rawText) {
  return rawText.trim().split('\n').map(line => {
    const match = line.match(/^(.+?):\s*(\d{1,2}:\d{2}:\d{2}(?:,\d{3})?)\s*(\[skip\])?$/i);
    if (!match) return null;
    return {
      label: match[1].trim(),
      time: match[2].trim(),
      ...(match[3] ? { skip: true } : {})
    };
  }).filter(Boolean);
}

// --- GitHub API Communication ---
// START: D√°n ƒëo·∫°n m√£ n√†y v√†o ƒë·ªÉ thay th·∫ø h√†m ghAPI c≈©

async function ghAPI(path, method = "GET", body = null, isSrtFile = false) {
    // ‚úÖ T·ª± ƒë·ªông g·ªôp appPath + srtPath n·∫øu l√† SRT
    let basePath = config.appPath || '';
    if (isSrtFile) {
        basePath += config.srtPath || '';
    }

    // üîß Gh√©p path v√† l√†m s·∫°ch d·∫•u //
    const fullPath = `${basePath}${path}`.replace(/\/\/+/g, '/').replace(/^\//, '');

    const url = `https://api.github.com/repos/${config.username}/${config.repo}/contents/${fullPath}`;
    const options = {
        method,
        headers: {
            Authorization: `token ${config.token}`,
            Accept: "application/vnd.github.v3+json"
        }
    };

    if (body) options.body = JSON.stringify(body);
    const res = await fetch(url, options);

    if (!res.ok && res.status !== 404) {
        const err = await res.json();
        throw new Error(`GitHub API (${res.status}): ${err.message}`);
    }

    return res.status === 404 ? { notFound: true } : { success: true, data: await res.json() };
}


// END: D√°n ƒëo·∫°n m√£ n√†y v√†o
async function commitFile(path, message, content, sha) { log(`Committing ${path}...`); await ghAPI(path, "PUT", { message: `[DeployTool] ${message}`, content, sha }); }

// --- UI Rendering ---
function renderLibraryList() {
    ui.libraryListContainer.innerHTML = '';
    
    // 1. Gom nh√≥m theo Program (Gi·ªØ nguy√™n logic c≈©)
    const grouped = currentLibrary.reduce((acc, video) => { 
        const program = video.program || 'Kh√°c'; 
        if (!acc[program]) acc[program] = []; 
        acc[program].push(video); 
        return acc; 
    }, {});

    const groupKeys = Object.keys(grouped).sort((a,b) => { 
        const aIndex = currentLibrary.findIndex(v => (v.program || 'Kh√°c') === a); 
        const bIndex = currentLibrary.findIndex(v => (v.program || 'Kh√°c') === b); 
        return aIndex - bIndex; 
    });
    
    groupKeys.forEach(programName => {
        const groupEl = doc.createElement('div'); 
        groupEl.className = 'program-group'; 
        groupEl.dataset.program = programName;
        
        // Th√™m Header cho Program
        const headerHtml = `<div class="program-group-header"><div class="icon-drag-wrapper"><svg class="icon icon-drag"><use xlink:href="#icon-drag"></use></svg></div>${programName}</div>`;
        groupEl.innerHTML = headerHtml + `<div class="video-card-list"></div>`;
        
        const videoListEl = groupEl.querySelector('.video-card-list');
        
        // 2. LOGIC M·ªöI: S·∫Øp x·∫øp theo M√πa -> T·∫≠p
        const sortedVideos = grouped[programName].sort((a,b) => {
            const seasonA = a.season || 0;
            const seasonB = b.season || 0;
            if (seasonA !== seasonB) return seasonA - seasonB; // M√πa nh·ªè tr∆∞·ªõc
            return (a.episode || 0) - (b.episode || 0);      // T·∫≠p nh·ªè tr∆∞·ªõc
        });

        let currentSeasonTracker = -1; // Bi·∫øn theo d√µi ƒë·ªÉ ch√®n ti√™u ƒë·ªÅ M√πa

        sortedVideos.forEach(video => {
            const vidSeason = video.season || 0;

            // N·∫øu ph√°t hi·ªán M√πa m·ªõi (v√† M√πa ƒë√≥ > 0), ch√®n ti√™u ƒë·ªÅ
            if (vidSeason > 0 && vidSeason !== currentSeasonTracker) {
                const seasonDiv = doc.createElement('div');
                seasonDiv.className = 'season-divider';
                seasonDiv.innerHTML = `M√πa ${vidSeason}`;
                videoListEl.appendChild(seasonDiv);
                currentSeasonTracker = vidSeason;
            } else if (vidSeason === 0 && currentSeasonTracker !== 0 && currentSeasonTracker !== -1) {
                // Tr∆∞·ªùng h·ª£p video l·∫ª kh√¥ng c√≥ m√πa n·∫±m l·∫´n (√≠t x·∫£y ra do ƒë√£ sort, nh∆∞ng c·ª© handle)
                // Kh√¥ng l√†m g√¨ ho·∫∑c th√™m divider "Video l·∫ª" n·∫øu mu·ªën
            }

            // Render Video Card (Gi·ªØ nguy√™n style c≈©)
            const card = doc.createElement('div'); 
            card.className = 'video-card-item';
            if (video.videoId === editingVideoId) card.classList.add('active');
            card.dataset.videoId = video.videoId;
            
            // Format t√™n hi·ªÉn th·ªã: [M√πa X - T·∫≠p Y] ho·∫∑c [T·∫≠p Y]
            let prefix = '';
            if (video.season) prefix += `S${video.season} `;
            if (video.episode) prefix += `E${String(video.episode).padStart(2,'0')} `;
            if (prefix) prefix = `[${prefix.trim()}] `;

            const duration = video.duration_auto ? new Date(video.duration_auto * 1000).toISOString().substr(14, 5) : '';
            
            card.innerHTML = `
                <div class="video-card-thumbnail-wrapper">
                    <img src="${video.thumbnailUrl_auto}" class="video-card-thumbnail" loading="lazy">
                    ${duration ? `<span class="video-card-duration">${duration}</span>` : ''}
                </div>
                <div class="video-card-info">
                    <div class="video-card-title">${prefix}${video.userTitle}</div>
                    <div class="video-card-meta">${video.program || video.authorName_auto}</div>
                </div>
                <div class="video-card-actions">
                    <button class="edit-sub-btn" title="Ch·ªânh s·ª≠a Ph·ª• ƒë·ªÅ" onclick="event.stopPropagation(); SubEditor.load('${video.videoId}')">üé¨</button>
                    <button class="edit-btn" title="S·ª≠a"><svg class="icon"><use xlink:href="#icon-edit"></use></svg></button>
                    <button class="refresh-btn" title="L√†m m·ªõi"><svg class="icon"><use xlink:href="#icon-refresh"></use></svg></button>
                    <button class="delete-btn" title="X√≥a"><svg class="icon"><use xlink:href="#icon-trash"></use></svg></button>
                </div>`;
            
            videoListEl.appendChild(card);
        });
        
        ui.libraryListContainer.appendChild(groupEl);
    });
    
    initSortable(); // K√≠ch ho·∫°t l·∫°i k√©o th·∫£
}

function initSortable() { if(sortableGroups) sortableGroups.destroy(); sortableVideos.forEach(s => s.destroy()); sortableVideos = []; sortableGroups = new Sortable(ui.libraryListContainer, { animation: 150, handle: '.program-group-header', onEnd: () => setDirty(true) }); doc.querySelectorAll('.video-card-list').forEach(el => { sortableVideos.push(new Sortable(el, { group: 'videos', animation: 150, onEnd: () => setDirty(true) })); }); }
function populateProgramSelect() { ui.inputs.programSelect.innerHTML = `<option value="">(Kh√¥ng c√≥)</option>`; tagsData.programs.sort().forEach(p => ui.inputs.programSelect.innerHTML += `<option value="${p}">${p}</option>`); ui.inputs.programSelect.innerHTML += `<option value="--new--">-- Th√™m ch∆∞∆°ng tr√¨nh m·ªõi --</option>`; }
function renderTagEditor(type, selectedArray) { const container = ui.inputs[`${type}TagsContainer`]; container.innerHTML = selectedArray.map(p => `<span class="tag-pill">${p}<button class="tag-remove-btn" data-type="${type}" data-name="${p}">x</button></span>`).join(''); }
function showAutocomplete(type, query, selectedArray) { const listEl = ui.inputs[`${type}AutocompleteList`]; if (!query) { listEl.innerHTML = ''; return; } const suggestions = tagsData[type].filter(p => p.toLowerCase().includes(query.toLowerCase()) && !selectedArray.includes(p)); listEl.innerHTML = suggestions.map(s => `<div class="suggestion-item" data-type="${type}" data-name="${s}">${s}</div>`).join(''); }

// --- Form & State ---
function clearFormAndState() {
    Object.values(ui.inputs).forEach(input => { if(input && !input.id.startsWith('gh-')) input.value = ''; });
    editingVideoId = null; selectedParticipants = []; selectedGenres = [];
    renderTagEditor('participants', selectedParticipants); renderTagEditor('genres', selectedGenres);
    ui.formTitle.textContent = "Th√™m Video M·ªõi"; hideSpinner(ui.deployBtn, "Th√™m Video");
    ui.inputs.youtubeUrl.readOnly = false;
    doc.querySelector('.video-card-item.active')?.classList.remove('active');
    ui.cancelEditBtn.classList.add('hidden');
renderBookmarkEditor([]);



}
function populateFormForEdit(videoId) {
    const video = currentLibrary.find(v => v.videoId === videoId); if (!video) return;
    clearFormAndState(); 
    editingVideoId = videoId;
    
    ui.inputs.youtubeUrl.value = `https://www.youtube.com/watch?v=${video.videoId}`;
    ui.inputs.userTitle.value = video.userTitle || "";
    
    // --- CODE M·ªöI ---
    ui.inputs.episodeNumber.value = video.episode || "";
    ui.inputs.seasonNumber.value = video.season || ""; // Load season
    // ----------------
    
    ui.inputs.programSelect.value = video.program || "";
    ui.inputs.description.value = video.description || "";
    renderBookmarkEditor(video.bookmarks || []); // Gi·∫£ s·ª≠ h√†m n√†y b·∫°n ƒë√£ c√≥

    selectedParticipants = [...(video.participants || [])]; 
    selectedGenres = [...(video.genres || [])];
    renderTagEditor('participants', selectedParticipants); 
    renderTagEditor('genres', selectedGenres);
    
    ui.formTitle.textContent = `Ch·ªânh s·ª≠a: ${video.userTitle}`; 
    hideSpinner(ui.deployBtn, "L∆∞u Thay ƒê·ªïi");
    ui.inputs.youtubeUrl.readOnly = true;
    doc.querySelector(`[data-video-id="${videoId}"]`)?.classList.add('active');
    ui.cancelEditBtn.classList.remove('hidden');
}

function setDirty(state) { isDirty = state; ui.saveOrderBtn.classList.toggle('hidden', !state); }

// --- Main Action Handlers ---
async function handleDeploy() {
    showSpinner(ui.deployBtn);
    try {
        const url = ui.inputs.youtubeUrl.value.trim();
        const videoId = editingVideoId || extractVideoID(url);
        if (!videoId) throw new Error("Link YouTube kh√¥ng h·ª£p l·ªá.");
        const srtFile = ui.inputs.srtFile.files[0];
        const existingEntry = currentLibrary.find(item => item.videoId === videoId);
        if (!existingEntry && !srtFile) throw new Error("C·∫ßn file .srt khi th√™m video m·ªõi.");
        let subtitleUrl = existingEntry?.subtitleUrl || "";
        // START: D√°n kh·ªëi m√£ n√†y v√†o ƒë·ªÉ thay th·∫ø
if (srtFile) {
    log("ƒêang t·∫£i l√™n file ph·ª• ƒë·ªÅ...");
    const srtName = `${videoId}.srt`;
    const srtContent = await toBase64(srtFile);
    
    // S·ª≠ d·ª•ng ghAPI ƒë√£ ƒë∆∞·ª£c s·ª≠a l·ªói
    const { data: existingSrtData } = await ghAPI(srtName, "GET", null, true); // true = isSrtFile
    
    const srtPayload = {
        message: `[DeployTool] Upload subtitle: ${srtName}`,
        content: srtContent,
        sha: existingSrtData?.sha
    };

    // G·ªçi ghAPI ƒë·ªÉ t·∫£i l√™n
    await ghAPI(srtName, "PUT", srtPayload, true); // true = isSrtFile

    subtitleUrl = `${config.srtPath}${srtName}`.replace(/\/\/+/g, '/');

}
// END: D√°n kh·ªëi m√£ n√†y v√†o
        let program = ui.inputs.programSelect.value;
        let tagsNeedUpdate = false;
        if (program === '--new--') { program = prompt("Nh·∫≠p t√™n ch∆∞∆°ng tr√¨nh m·ªõi:"); if (!program) throw new Error("H·ªßy b·ªè thao t√°c."); if (!tagsData.programs.includes(program)) { tagsData.programs.push(program); tagsNeedUpdate = true; } }
        const checkNewTags = (type, selected) => { let newTags = selected.filter(p => !tagsData[type].includes(p)); if (newTags.length > 0) { tagsData[type].push(...newTags); tagsData[type].sort(); tagsNeedUpdate = true; } };
        checkNewTags('participants', selectedParticipants); checkNewTags('genres', selectedGenres);
        
        const oembed = existingEntry ? {} : await getOEmbedData(videoId);
        const episodeValue = ui.inputs.episodeNumber.value;
        const seasonValue = ui.inputs.seasonNumber.value;
        const newEntryData = { 
            videoId, 
            userTitle: ui.inputs.userTitle.value.trim() || oembed.title, 
            program, 
            participants: selectedParticipants, 
            genres: selectedGenres, 
            description: ui.inputs.description.value.trim(), 
            subtitleUrl, 
            originalTitle_auto: existingEntry?.originalTitle_auto || oembed.title, 
            authorName_auto: existingEntry?.authorName_auto || oembed.author_name, 
            thumbnailUrl_auto: existingEntry?.thumbnailUrl_auto || oembed.thumbnail_url?.replace('hqdefault.jpg', 'maxresdefault.jpg'), 
            duration_auto: existingEntry?.duration_auto || oembed.duration, 
            uploadDate_auto: existingEntry?.uploadDate_auto || oembed.upload_date,
            publishedAt_official: existingEntry?.publishedAt_official || oembed.publishedAt_official || "" 
        };

        // Parse bookmark (Gi·ªØ nguy√™n)
        const bookmarks = getBookmarkList();
        if (bookmarks.length > 0) newEntryData.bookmarks = bookmarks;

        // X·ª≠ l√Ω T·∫≠p
        if (episodeValue && !isNaN(parseInt(episodeValue, 10))) { 
            newEntryData.episode = parseInt(episodeValue, 10); 
        } else { delete newEntryData.episode; }
        
        // --- X·ª¨ L√ù M√ôA (CODE M·ªöI) ---
        if (seasonValue && !isNaN(parseInt(seasonValue, 10))) { 
            newEntryData.season = parseInt(seasonValue, 10); 
        } else { delete newEntryData.season; }
        const idx = currentLibrary.findIndex(item => item.videoId === videoId);
        if (idx >= 0) { currentLibrary[idx] = newEntryData; } else { currentLibrary.unshift(newEntryData); }
        
       const { data: librarySha } = await ghAPI("library.json");
await commitFile("library.json", (editingVideoId ? "Update" : "Add") + ` video`, toBase64Str(JSON.stringify(currentLibrary, null, 2)), librarySha?.sha);

if (tagsNeedUpdate) {
    const { data: tagsSha } = await ghAPI("tags.json");
    await commitFile("tags.json", 'Update tags', toBase64Str(JSON.stringify(tagsData, null, 2)), tagsSha?.sha);
}

        alert("Thao t√°c th√†nh c√¥ng!"); clearFormAndState(); populateProgramSelect(); renderLibraryList();
    } catch (err) { log(err.message, true); alert(`L·ªói: ${err.message}`); } 
    finally { hideSpinner(ui.deployBtn, editingVideoId ? "L∆∞u Thay ƒê·ªïi" : "Th√™m Video"); }
}

async function handleDelete(videoId) {
    const video = currentLibrary.find(v => v.videoId === videoId);
    if (!confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a video "${video.userTitle}"?`)) return;
    const btn = doc.querySelector(`[data-video-id="${videoId}"] .delete-btn`);
    showSpinner(btn, '');
    try {
        currentLibrary = currentLibrary.filter(v => v.videoId !== videoId);
        const { data } = await ghAPI("library.json");
        await commitFile("library.json", `Delete video: ${video.userTitle}`, toBase64Str(JSON.stringify(currentLibrary, null, 2)), data.sha);
        log(`ƒê√£ x√≥a video: ${video.userTitle}`);
        if (editingVideoId === videoId) clearFormAndState();
        renderLibraryList();
    } catch (err) {
        log(err.message, true);
    } finally {
        hideSpinner(btn, 'üóëÔ∏è');
    }
}

async function handleRefreshSingle(videoId) {
    const btn = doc.querySelector(`[data-video-id="${videoId}"] .refresh-btn`);
    showSpinner(btn, '');
    try {
        const idx = currentLibrary.findIndex(v => v.videoId === videoId);
        if (idx === -1) throw new Error("Kh√¥ng t√¨m th·∫•y video.");
        log(`ƒêang l√†m m·ªõi metadata cho: ${currentLibrary[idx].userTitle}`);
        const meta = await getOEmbedData(videoId);
        currentLibrary[idx].originalTitle_auto = meta.title;
        currentLibrary[idx].authorName_auto = meta.author_name;
        currentLibrary[idx].thumbnailUrl_auto = meta.thumbnail_url?.replace('hqdefault.jpg', 'maxresdefault.jpg');
        currentLibrary[idx].duration_auto = meta.duration;
        currentLibrary[idx].uploadDate_auto = meta.upload_date;

        const { data } = await ghAPI("library.json");
        await commitFile("library.json", `Refresh metadata for ${currentLibrary[idx].userTitle}`, toBase64Str(JSON.stringify(currentLibrary, null, 2)), data.sha);
        renderLibraryList();
        log("L√†m m·ªõi th√†nh c√¥ng.");
    } catch (err) {
        log(err.message, true);
    } finally {
        hideSpinner(btn, 'üîÑ');
    }
}

async function handleSaveOrder() {
    showSpinner(ui.saveOrderBtn, "ƒêang l∆∞u...");
    try {
        const newLibrary = [];
        doc.querySelectorAll('.program-group').forEach(g => {
            g.querySelectorAll('.video-card-item').forEach(c => {
                const v = currentLibrary.find(vid => vid.videoId === c.dataset.videoId);
                if (v) {
                    v.program = g.dataset.program === 'Kh√°c' ? '' : g.dataset.program;
                    newLibrary.push(v);
                }
            });
        });
        currentLibrary = newLibrary;
        const { data } = await ghAPI("library.json");
        await commitFile("library.json", "Reorder library", toBase64Str(JSON.stringify(currentLibrary, null, 2)), data.sha);
        setDirty(false);
        renderLibraryList();
        log("ƒê√£ l∆∞u th·ª© t·ª± m·ªõi.");
    } catch (err) {
        log(err.message, true);
    } finally {
        hideSpinner(ui.saveOrderBtn, "L∆∞u Th·ª© t·ª±");
    }
}

function renderTagManagerLists() {
    const renderList = (type, container) => {
        container.innerHTML = '';
        tagsData[type].sort().forEach(tag => {
            const li = doc.createElement('li');
            li.innerHTML = `<span>${tag}</span><div class="tag-list-actions"><button class="edit-tag-btn" data-type="${type}" data-name="${tag}">‚úèÔ∏è</button><button class="delete-tag-btn" data-type="${type}" data-name="${tag}">üóëÔ∏è</button></div>`;
            container.appendChild(li);
        });
    };
    renderList('programs', ui.programsTagList);
    renderList('participants', ui.participantsTagList);
    renderList('genres', ui.genresTagList);
}

function openTagManager() {
    renderTagManagerLists();
    ui.tagManagerModal.classList.remove('hidden');
}

function handleTagListActions(e) {
    const btn = e.target.closest('button');
    if (!btn) return;
    const { type, name } = btn.dataset;
    if (btn.classList.contains('edit-tag-btn')) {
        const newName = prompt(`ƒê·ªïi t√™n tag "${name}":`, name);
        if (newName && newName.trim() && newName !== name) {
            const index = tagsData[type].indexOf(name);
            if (index > -1) {
                tagsData[type][index] = newName;
                currentLibrary.forEach(video => {
                    if (type === 'programs' && video.program === name) video.program = newName;
                    else if (video.hasOwnProperty(type) && video[type]?.includes(name)) {
                        const pIndex = video[type].indexOf(name);
                        video[type][pIndex] = newName;
                    }
                });
                renderTagManagerLists();
            }
        }
    } else if (btn.classList.contains('delete-tag-btn')) {
        if (confirm(`X√≥a vƒ©nh vi·ªÖn tag "${name}"? N√≥ s·∫Ω b·ªã g·ª° kh·ªèi t·∫•t c·∫£ video.`)) {
            tagsData[type] = tagsData[type].filter(t => t !== name);
            currentLibrary.forEach(video => {
                if (type === 'programs' && video.program === name) video.program = '';
                else if (video.hasOwnProperty(type) && video[type]?.includes(name)) {
                    video[type] = video[type].filter(p => p !== name);
                }
            });
            renderTagManagerLists();
        }
    }
}

function addNewTagFromInput(type) {
    const inputEl = ui[`new${type.charAt(0).toUpperCase() + type.slice(1, -1)}Input`];
    const newTag = inputEl.value.trim();
    if (newTag && !tagsData[type].includes(newTag)) {
        tagsData[type].push(newTag);
        inputEl.value = '';
        renderTagManagerLists();
    }
}

async function handleSaveTags() {
    showSpinner(ui.saveTagsBtn, "ƒêang l∆∞u...");
    try {
        const [libraryRes, tagsRes] = await Promise.all([
            ghAPI("library.json"), 
            ghAPI("tags.json")
        ]);
        await commitFile("tags.json", 'Update tags from manager', toBase64Str(JSON.stringify(tagsData, null, 2)), tagsRes.data?.sha);
        await commitFile("library.json", 'Sync library with tag updates', toBase64Str(JSON.stringify(currentLibrary, null, 2)), libraryRes.data?.sha);
        alert("ƒê√£ l∆∞u v√† ƒë·ªìng b·ªô th√†nh c√¥ng!");
        log("Tags v√† th∆∞ vi·ªán ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.");
        ui.tagManagerModal.classList.add('hidden');
        populateProgramSelect();
        renderLibraryList();
    } catch (err) {
        log(err.message, true);
        alert("C√≥ l·ªói x·∫£y ra, vui l√≤ng xem log.");
    } finally {
        hideSpinner(ui.saveTagsBtn, "L∆∞u v√† ƒê·ªìng b·ªô Thay ƒë·ªïi");
    }
}




function saveConfig() {
let appPath = ui.inputs.appPath.value.trim();
let srtPath = ui.inputs.srtPath.value.trim();

// ƒê·∫£m b·∫£o c√≥ d·∫•u `/` ·ªü cu·ªëi n·∫øu c·∫ßn
if (appPath && !appPath.endsWith("/")) appPath += "/";
if (srtPath && !srtPath.endsWith("/")) srtPath += "/";




    const cfg = {
    username: ui.inputs.username.value,
    repo: ui.inputs.repo.value,
    token: ui.inputs.token.value,
    youtubeApiKey: ui.inputs.ytApiKey.value.trim(), // <--- TH√äM D√íNG N√ÄY
    appPath,
    srtPath
};

    if (!cfg.username || !cfg.repo || !cfg.token) {
        return alert("Vui l√≤ng ƒëi·ªÅn ƒë·ªß T√™n ng∆∞·ªùi d√πng, Repo v√† Token.");
    }

    config = cfg;
    localStorage.setItem("ytDeployerConfig", JSON.stringify(config));
    initializeDashboard();
}

function resetConfig() { if (confirm("X√≥a c·∫•u h√¨nh?")) { localStorage.removeItem("ytDeployerConfig"); config = {}; ui.configPanel.classList.remove("hidden"); ui.uploaderPanel.classList.add("hidden"); } }
function loadConfig() { const stored = localStorage.getItem("ytDeployerConfig"); if (stored) { config = JSON.parse(stored); Object.keys(config).forEach(key => { if (ui.inputs[key]) { ui.inputs[key].value = config[key] || ''; } }); initializeDashboard(); } else { ui.configPanel.classList.remove("hidden"); } }

async function initializeDashboard() {
    ui.configPanel.classList.add("hidden");
    ui.uploaderPanel.classList.remove("hidden");

    ui.repoInfo.innerHTML = `ƒêang k·∫øt n·ªëi: <strong>${config.username}/${config.repo}</strong><br>ƒê∆∞·ªùng d·∫´n App: <strong>/${config.appPath || "(g·ªëc)"}</strong> | Th∆∞ m·ª•c Sub: <strong>/${config.srtPath || "(g·ªëc)"}</strong>`;
    log("ƒêang t·∫£i d·ªØ li·ªáu t·ª´ GitHub...");

    try {
        const [libraryRes, tagsRes] = await Promise.all([
            ghAPI("library.json"), 
            ghAPI("tags.json")
        ]);

        currentLibrary = libraryRes.notFound ? [] : JSON.parse(fromBase64(libraryRes.data.content));

        // ƒê·∫£m b·∫£o tagsData lu√¥n ƒë√∫ng c·∫•u tr√∫c
        tagsData = tagsRes.notFound 
            ? { programs: [], participants: [], genres: [] } 
            : JSON.parse(fromBase64(tagsRes.data.content));

        if (!tagsData.programs) tagsData.programs = [];
        if (!tagsData.participants) tagsData.participants = [];
        if (!tagsData.genres) tagsData.genres = [];

        log(`T·∫£i th√†nh c√¥ng ${currentLibrary.length} video v√† ${tagsData.programs.length + tagsData.participants.length + tagsData.genres.length} tags.`);
        populateProgramSelect(); 
        renderLibraryList();
    } catch (err) {
        log(`L·ªói t·∫£i d·ªØ li·ªáu: ${err.message}`, true);
    }
}

// --- [M·ªöI] H√ÄM C·∫¨P NH·∫¨T H√ÄNG LO·∫†T ---
async function handleBatchRefresh() {
    if (!confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën c·∫≠p nh·∫≠t metadata (·∫¢nh, Ng√†y ƒëƒÉng, T√™n g·ªëc) cho to√†n b·ªô ${currentLibrary.length} video?\nQu√° tr√¨nh n√†y c√≥ th·ªÉ m·∫•t v√†i ph√∫t.`)) return;

    const btn = document.getElementById('batch-refresh-btn');
    showSpinner(btn, "0%");
    
    let updatedCount = 0;
    let errorCount = 0;
    const total = currentLibrary.length;

    // H√†m delay ƒë·ªÉ tr√°nh b·ªã YouTube ch·∫∑n (Rate Limit)
    const delay = (ms) => new Promise(res => setTimeout(res, ms));

    try {
        for (let i = 0; i < total; i++) {
            const video = currentLibrary[i];
            
            // C·∫≠p nh·∫≠t % l√™n n√∫t
            btn.innerHTML = `‚è≥ ${Math.round(((i + 1) / total) * 100)}%`;

            try {
                // L·∫•y data m·ªõi t·ª´ NoEmbed/OEmbed
                const meta = await getOEmbedData(video.videoId);
                
                // C·∫≠p nh·∫≠t c√°c tr∆∞·ªùng t·ª± ƒë·ªông
                video.originalTitle_auto = meta.title;
                video.authorName_auto = meta.author_name;
                video.thumbnailUrl_auto = meta.thumbnail_url?.replace('hqdefault.jpg', 'maxresdefault.jpg');
                video.duration_auto = meta.duration;
                
                // [QUAN TR·ªåNG] L·∫•y ng√†y ƒëƒÉng
                // NoEmbed th∆∞·ªùng tr·∫£ v·ªÅ 'upload_date' d·∫°ng '2023-10-25'
                video.uploadDate_auto = meta.upload_date; 
                if (meta.publishedAt_official) {
    video.publishedAt_official = meta.publishedAt_official;
}
                updatedCount++;
            } catch (e) {
                console.warn(`L·ªói c·∫≠p nh·∫≠t video ${video.videoId}:`, e);
                errorCount++;
            }

            // Ngh·ªâ 0.5 gi√¢y gi·ªØa m·ªói video ƒë·ªÉ nh·∫π server
            await delay(500);
        }

        // L∆∞u 1 l·∫ßn duy nh·∫•t l√™n GitHub
        const { data } = await ghAPI("library.json");
        await commitFile("library.json", `Batch refresh metadata for ${updatedCount} videos`, toBase64Str(JSON.stringify(currentLibrary, null, 2)), data.sha);

        renderLibraryList();
        alert(`Ho√†n t·∫•t!\n‚úÖ C·∫≠p nh·∫≠t: ${updatedCount}\n‚ùå L·ªói: ${errorCount}`);

    } catch (err) {
        log(err.message, true);
        alert("C√≥ l·ªói x·∫£y ra trong qu√° tr√¨nh c·∫≠p nh·∫≠t h√†ng lo·∫°t.");
    } finally {
        hideSpinner(btn, '<svg class="icon"><use xlink:href="#icon-refresh"></use></svg> Update All');
    }
}
// --- Event Listeners Setup ---
const setupTagEditor = (type) => {
    const inputEl = ui.inputs[`${type}Input`];
    const containerEl = ui.inputs[`${type}TagsContainer`];
    const suggestionsEl = ui.inputs[`${type}AutocompleteList`];
    const getSelectedArray = () => type === 'participants' ? selectedParticipants : selectedGenres;
    const setSelectedArray = (arr) => { if (type === 'participants') selectedParticipants = arr; else selectedGenres = arr; };

    containerEl.addEventListener('click', e => { if (e.target.classList.contains('tag-remove-btn')) { const name = e.target.dataset.name; setSelectedArray(getSelectedArray().filter(p => p !== name)); renderTagEditor(type, getSelectedArray()); } });
    inputEl.addEventListener('input', e => showAutocomplete(type, e.target.value, getSelectedArray()));
    inputEl.addEventListener('keydown', e => { if (e.key === 'Enter' && e.target.value.trim()) { e.preventDefault(); const newTag = e.target.value.trim(); const selected = getSelectedArray(); if (!selected.includes(newTag)) { selected.push(newTag); setSelectedArray(selected); renderTagEditor(type, selected); } e.target.value = ''; showAutocomplete(type, '', selected); } else if (e.key === 'Backspace' && e.target.value === '') { const selected = getSelectedArray(); selected.pop(); setSelectedArray(selected); renderTagEditor(type, selected); } });
    suggestionsEl.addEventListener('click', e => { if (e.target.classList.contains('suggestion-item')) { const name = e.target.dataset.name; const selected = getSelectedArray(); if (!selected.includes(name)) { selected.push(name); setSelectedArray(selected); renderTagEditor(type, selected); } inputEl.value = ''; showAutocomplete(type, '', selected); inputEl.focus(); } });
};

ui.saveConfigBtn.addEventListener("click", saveConfig);
ui.resetConfigBtn.addEventListener("click", resetConfig);
ui.cancelEditBtn.addEventListener("click", clearFormAndState);
ui.deployBtn.addEventListener("click", handleDeploy);
ui.saveOrderBtn.addEventListener("click", handleSaveOrder);
ui.manageTagsBtn.addEventListener("click", openTagManager);
ui.tagManagerCloseBtn.addEventListener('click', () => ui.tagManagerModal.classList.add('hidden'));
ui.saveTagsBtn.addEventListener('click', handleSaveTags);
ui.programsTagList.addEventListener('click', handleTagListActions);
ui.participantsTagList.addEventListener('click', handleTagListActions);
ui.genresTagList.addEventListener('click', handleTagListActions);
ui.addProgramBtn.addEventListener('click', () => addNewTagFromInput('programs'));
ui.addParticipantBtn.addEventListener('click', () => addNewTagFromInput('participants'));
ui.addGenreBtn.addEventListener('click', () => addNewTagFromInput('genres'));
// [M·ªöI] S·ª± ki·ªán cho n√∫t Batch Update
document.getElementById('batch-refresh-btn').addEventListener('click', handleBatchRefresh);
ui.libraryListContainer.addEventListener('click', e => { const btn = e.target.closest('button'); if(!btn) return; const videoId = btn.closest('.video-card-item')?.dataset.videoId; if(!videoId) return; if(btn.classList.contains('edit-btn')) populateFormForEdit(videoId); if(btn.classList.contains('delete-btn')) handleDelete(videoId); if(btn.classList.contains('refresh-btn')) handleRefreshSingle(videoId); });
setupTagEditor('participants');
setupTagEditor('genres');

    // --- B·ªï sung nh·ªè ƒë·ªÉ ƒëi·ªÅu khi·ªÉn Modal m·ªõi ---
    const originalOpenTagManager = openTagManager;
    const tagManagerWrapper = document.getElementById('tag-manager-modal-wrapper');

    // Ghi ƒë√® h√†m c≈© ƒë·ªÉ hi·ªÉn th·ªã c·∫£ overlay
    window.openTagManager = function() {
      originalOpenTagManager(); // G·ªçi h√†m g·ªëc
      tagManagerWrapper.classList.remove('hidden');
      tagManagerWrapper.querySelector('#tag-manager-modal').classList.remove('hidden');
    }

    // Ghi ƒë√® n√∫t ƒë√≥ng modal c≈©
    document.getElementById('tag-manager-close-btn').addEventListener('click', () => {
        tagManagerWrapper.classList.add('hidden');
    });
    
    // Ghi ƒë√® n√∫t l∆∞u tags ƒë·ªÉ ·∫©n modal
    const originalSaveTags = handleSaveTags;
    window.handleSaveTags = async function() {
        await originalSaveTags(); // G·ªçi h√†m g·ªëc
        if (!document.querySelector('#save-tags-btn:disabled')) {
            tagManagerWrapper.classList.add('hidden');
        }
    }

    // S·ª≠a l·∫°i h√†m render video card ƒë·ªÉ th√™m icon k√©o th·∫£
    const originalRenderLibraryList = renderLibraryList;
    window.renderLibraryList = function() {
        originalRenderLibraryList(); // G·ªçi h√†m g·ªëc
        document.querySelectorAll('.program-group-header').forEach(header => {
            const icon = document.createElement('div');
            icon.innerHTML = '<svg class="icon icon-drag"><use xlink:href="#icon-drag"></use></svg>';
            header.prepend(icon);
        });
        document.querySelectorAll('.video-card-actions').forEach(actions => {
            actions.querySelector('.edit-btn').innerHTML = '<svg class="icon"><use xlink:href="#icon-edit"></use></svg>';
            actions.querySelector('.refresh-btn').innerHTML = '<svg class="icon"><use xlink:href="#icon-refresh"></use></svg>';
            actions.querySelector('.delete-btn').innerHTML = '<svg class="icon"><use xlink:href="#icon-trash"></use></svg>';
        });
    }

    // S·ª≠a l·∫°i n√∫t deploy/cancel ƒë·ªÉ ph√π h·ª£p v·ªõi layout m·ªõi
    const originalClearFormAndState = clearFormAndState;
    window.clearFormAndState = function() {
        originalClearFormAndState();
        document.getElementById('deploy-btn').innerHTML = 'Th√™m Video';
    }
    const originalPopulateFormForEdit = populateFormForEdit;
    window.populateFormForEdit = function(videoId) {
        originalPopulateFormForEdit(videoId);
        document.getElementById('deploy-btn').innerHTML = 'L∆∞u Thay ƒê·ªïi';
    }
    
    // C·∫ßn thay th·∫ø c√°c h√†m g·ªëc b·∫±ng c√°c h√†m ƒë√£ ƒë∆∞·ª£c "b·ªçc" l·∫°i
    document.getElementById('manage-tags-btn').removeEventListener('click', openTagManager);
    document.getElementById('manage-tags-btn').addEventListener('click', window.openTagManager);
    
    document.getElementById('save-tags-btn').removeEventListener('click', handleSaveTags);
    document.getElementById('save-tags-btn').addEventListener('click', window.handleSaveTags);
function renderBookmarkEditor(bookmarks = []) {
  const container = document.getElementById("bookmarks-list");
  container.innerHTML = '';
  bookmarks.forEach((b) => {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.gap = "8px";
    row.style.marginBottom = "6px";

    row.innerHTML = `
      <input type="text" placeholder="T√™n ph·∫ßn" value="${b.label || ''}" style="flex: 2" />
      <input type="text" value="${b.time || '00:00:00'}" onkeydown="handleTimeInputKey(event, this)" maxlength="8" style="flex: 1" />
      <label style="display: flex; align-items: center; gap: 4px;">
        <input type="checkbox" ${b.skip ? "checked" : ""} /> B·ªè qua
      </label>
      <button onclick="this.parentElement.remove()" class="btn-danger" style="padding: 4px 8px;">‚úñ</button>
    `;
    container.appendChild(row);
  });
}

/* --- H√ÄM H·ªñ TR·ª¢ LƒÇN CHU·ªòT CH·ªàNH GI·ªú --- */
function handleWheelTime(e, input) {
    if (document.activeElement !== input) return; // Ch·ªâ lƒÉn khi ƒëang focus
    e.preventDefault();
    
    // Parse th·ªùi gian hi·ªán t·∫°i
    const val = input.value;
    const p = val.split(':');
    const sStr = p[2].split(',');
    
    // Chuy·ªÉn sang mili-gi√¢y t·ªïng
    let totalMs = 
        parseInt(p[0]) * 3600000 + 
        parseInt(p[1]) * 60000 + 
        parseInt(sStr[0]) * 1000 + 
        parseInt(sStr[1] || 0);

    // LƒÉn l√™n tƒÉng 100ms, lƒÉn xu·ªëng gi·∫£m 100ms
    // Gi·ªØ Shift ƒë·ªÉ tƒÉng gi·∫£m 1000ms (1s)
    const step = e.shiftKey ? 1000 : 100;
    
    if (e.deltaY < 0) totalMs += step;
    else totalMs -= step;

    if (totalMs < 0) totalMs = 0;

    // Format l·∫°i th√†nh chu·ªói
    const date = new Date(totalMs);
    const ms = String(totalMs % 1000).padStart(3, '0');
    const timeStr = date.toISOString().substr(11, 8) + ',' + ms; // HH:mm:ss,ms

    input.value = timeStr;
    
    // K√≠ch ho·∫°t s·ª± ki·ªán change ƒë·ªÉ l∆∞u d·ªØ li·ªáu
    input.dispatchEvent(new Event('change'));
}
function handleTimeInputKey(e, input) {
  const val = input.value;
  let pos = input.selectionStart;

  const digitPositions = [0, 1, 3, 4, 6, 7];

  // G√µ s·ªë
  if (e.key >= '0' && e.key <= '9') {
    if (!digitPositions.includes(pos)) {
      e.preventDefault();
      return;
    }
    const chars = val.split('');
    chars[pos] = e.key;
    input.value = chars.join('');
    e.preventDefault();

    // T·ª± chuy·ªÉn con tr·ªè
    const next = digitPositions.find(p => p > pos);
    if (next !== undefined) {
      setTimeout(() => input.setSelectionRange(next, next), 0);
    }
    return;
  }

  // Backspace
  if (e.key === 'Backspace') {
    e.preventDefault();
    let newPos = pos;

    // N·∫øu ƒëang ·ªü d·∫•u `:` ‚Üí l√πi t·ªõi s·ªë tr∆∞·ªõc ƒë√≥
    while (newPos > 0 && !digitPositions.includes(newPos - 1)) {
      newPos--;
    }
    if (digitPositions.includes(newPos - 1)) {
      const chars = val.split('');
      chars[newPos - 1] = '0';
      input.value = chars.join('');
      setTimeout(() => input.setSelectionRange(newPos - 1, newPos - 1), 0);
    }
    return;
  }

  // Delete
  if (e.key === 'Delete') {
    e.preventDefault();
    if (!digitPositions.includes(pos)) return;
    const chars = val.split('');
    chars[pos] = '0';
    input.value = chars.join('');
    setTimeout(() => input.setSelectionRange(pos, pos), 0);
    return;
  }

  // NgƒÉn m·ªçi k√Ω t·ª± kh√°c
  if (!['ArrowLeft', 'ArrowRight', 'Tab'].includes(e.key)) {
    e.preventDefault();
  }
}


function addBookmarkRow() {
  const container = document.getElementById("bookmarks-list");
  const bookmarks = [];

  // Duy·ªát t·ª´ng h√†ng v√† thu th·∫≠p d·ªØ li·ªáu tr·ª±c ti·∫øp
  for (const row of container.children) {
    const inputs = row.querySelectorAll("input");
    const label = inputs[0]?.value?.trim();
    const time = inputs[1]?.value?.trim();
    const skip = inputs[2]?.checked;
    bookmarks.push({ label, time, ...(skip ? { skip: true } : {}) });
  }

  // ‚úÖ th√™m h√†ng m·ªõi
  bookmarks.push({ label: "", time: "00:00:00", skip: false });

  renderBookmarkEditor(bookmarks);
}


function getBookmarkList() {
  const container = document.getElementById("bookmarks-list");
   document.activeElement?.blur?.();

  return Array.from(container.children).map(row => {
    const inputs = row.querySelectorAll("input");
    const label = inputs[0].value.trim();
    const time = inputs[1].value.trim();
    const skip = inputs[2].checked;
    if (!label || !time) return null;
    return { label, time, ...(skip ? { skip: true } : {}) };
  }).filter(Boolean);
}
// 1. H√†m x√°c ƒë·ªãnh v√† b√¥i ƒëen v√πng (Gi·ªù, Ph√∫t, Gi√¢y, ho·∫∑c Ms) d·ª±a tr√™n v·ªã tr√≠ con tr·ªè
function selectTimeSegment(input) {
    const pos = input.selectionStart;
    let start = 0, end = 0;

    if (pos <= 2) { start = 0; end = 2; }       // Gi·ªù (HH)
    else if (pos <= 5) { start = 3; end = 5; }  // Ph√∫t (mm)
    else if (pos <= 8) { start = 6; end = 8; }  // Gi√¢y (ss)
    else { start = 9; end = 12; }               // Ms (mss)

    // ƒê·∫∑t selection ƒë·ªÉ ng∆∞·ªùi d√πng bi·∫øt m√¨nh ƒëang s·ª≠a c√°i g√¨
    input.setSelectionRange(start, end);
}

// 2. H√†m x·ª≠ l√Ω ph√≠m b·∫•m (M≈©i t√™n & Nh·∫≠p s·ªë)

// 2. H√†m x·ª≠ l√Ω ph√≠m b·∫•m Input Th·ªùi Gian (Logic: Overwrite & Smart Nav)
function handleSmartTimeInput(e, input) {
    const val = input.value; 
    const pos = input.selectionStart;

    // --- X·ª≠ l√Ω Space (D·∫•u c√°ch) ngay t·∫°i input ---
    // ƒê·ªÉ tr√°nh vi·ªác b·∫•m c√°ch n√≥ nh·∫≠p kho·∫£ng tr·∫Øng v√†o √¥ gi·ªù
    if (e.code === 'Space') {
        e.preventDefault();
        // Vi·ªác Play/Pause s·∫Ω do s·ª± ki·ªán global x·ª≠ l√Ω, ·ªü ƒë√¢y ch·ªâ c·∫ßn ch·∫∑n nh·∫≠p k√Ω t·ª±
        return;
    }

    // --- 1. M≈©i t√™n Tr√°i / Ph·∫£i (Nh·∫£y v√πng th√¥ng minh) ---
    // Quy ƒë·ªãnh v√πng: Gi·ªù(0-2), Ph√∫t(3-5), Gi√¢y(6-8), Ms(9-12)
    if (e.key === 'ArrowLeft') {
        e.preventDefault();
        if (pos > 9) input.setSelectionRange(6, 8);      // Ms -> Gi√¢y
        else if (pos > 6) input.setSelectionRange(3, 5); // Gi√¢y -> Ph√∫t
        else input.setSelectionRange(0, 2);              // Ph√∫t -> Gi·ªù (ho·∫∑c ƒëang ·ªü Gi·ªù th√¨ gi·ªØ nguy√™n)
        return;
    }
    if (e.key === 'ArrowRight') {
        e.preventDefault();
        if (pos < 3) input.setSelectionRange(3, 5);      // Gi·ªù -> Ph√∫t
        else if (pos < 6) input.setSelectionRange(6, 8); // Ph√∫t -> Gi√¢y
        else input.setSelectionRange(9, 12);             // Gi√¢y -> Ms
        return;
    }

    // --- 2. Backspace (X√≥a l√πi = Thay b·∫±ng s·ªë 0) ---
    if (e.key === 'Backspace') {
        e.preventDefault();
        if (pos === 0) return; // ƒê·∫ßu d√≤ng kh√¥ng x√≥a ƒë∆∞·ª£c

        // N·∫øu g·∫∑p d·∫•u : ho·∫∑c , th√¨ ch·ªâ nh·∫£y qua, kh√¥ng x√≥a
        if ([':', ','].includes(val[pos - 1])) {
            input.setSelectionRange(pos - 1, pos - 1);
            return;
        }

        // Thay s·ªë tr∆∞·ªõc con tr·ªè b·∫±ng '0'
        const chars = val.split('');
        chars[pos - 1] = '0';
        input.value = chars.join('');
        
        // L√πi con tr·ªè l·∫°i 1 ƒë∆°n v·ªã
        input.setSelectionRange(pos - 1, pos - 1);
        
        // Trigger l∆∞u v√† seek
        input.dispatchEvent(new Event('change'));
        return;
    }

    // --- 3. M≈©i t√™n L√™n / Xu·ªëng (TƒÉng gi·∫£m th·ªùi gian) ---
    if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        e.preventDefault();
        const p = val.split(':');
        const sStr = p[2].split(',');
        let h = parseInt(p[0]), m = parseInt(p[1]), s = parseInt(sStr[0]), ms = parseInt(sStr[1] || 0);
        let change = (e.key === 'ArrowUp') ? 1 : -1;

        if (pos <= 2) h += change;
        else if (pos <= 5) m += change;
        else if (pos <= 8) s += change;
        else ms += (change * 10); // Ms nh·∫£y 10 ƒë∆°n v·ªã

        let totalMs = h * 3600000 + m * 60000 + s * 1000 + ms;
        if (totalMs < 0) totalMs = 0;

        // Format l·∫°i
        const hh = Math.floor(totalMs / 3600000).toString().padStart(2, '0');
        const mm = Math.floor((totalMs % 3600000) / 60000).toString().padStart(2, '0');
        const ss = Math.floor((totalMs % 60000) / 1000).toString().padStart(2, '0');
        const mss = (totalMs % 1000).toString().padStart(3, '0');
        input.value = `${hh}:${mm}:${ss},${mss}`;

        // Kh√¥i ph·ª•c v√πng ch·ªçn c≈©
        if (pos <= 2) input.setSelectionRange(0, 2);
        else if (pos <= 5) input.setSelectionRange(3, 5);
        else if (pos <= 8) input.setSelectionRange(6, 8);
        else input.setSelectionRange(9, 12);
        
        input.dispatchEvent(new Event('change'));
        return;
    }

    // --- 4. Nh·∫≠p s·ªë (G√µ ƒë√®) ---
    if (e.key >= '0' && e.key <= '9') {
        e.preventDefault();
        const safePos = [0,1,3,4,6,7,9,10,11]; 
        if (!safePos.includes(pos)) { selectTimeSegment(input); return; }

        const chars = val.split('');
        chars[pos] = e.key;
        input.value = chars.join('');

        let nextPos = pos + 1;
        if (nextPos === 2 || nextPos === 5 || nextPos === 8) nextPos++; // Nh·∫£y qua d·∫•u ph√¢n c√°ch
        
        input.setSelectionRange(nextPos, nextPos);
        input.dispatchEvent(new Event('change'));
        return;
    }
    
    // Ch·∫∑n t·∫•t c·∫£ ph√≠m kh√°c tr·ª´ Tab
    if (e.key !== 'Tab') e.preventDefault();
}
/* --- SUBTITLE EDITOR HO√ÄN CH·ªàNH (C≈® + M·ªöI) --- */
const SubEditor = (() => {
    // --- VARIABLES C≈® GI·ªÆ NGUY√äN ---
    let ytPlayer = null;
    let currentData = [];
    let currentVideoId = null;
    let syncInterval = null;
    let activeRowIndex = -1; 
    let stopAtTime = null;

    // --- VARIABLES M·ªöI ---
    let selectedIndices = new Set(); // ƒê·ªÉ l∆∞u danh s√°ch ch·ªçn nhi·ªÅu

    const overlayText = document.getElementById('video-overlay-text');
    const currentRowLabel = document.getElementById('current-row-idx');

    // Helpers gi·ªØ nguy√™n
    const srtToSec = (str) => {
        if(!str) return 0;
        str = str.replace(',', '.');
        const p = str.split(':'); 
        const s = parseFloat(p[2]);
        return parseInt(p[0])*3600 + parseInt(p[1])*60 + s;
    };

    const secToSrt = (t) => {
        if (t < 0) t = 0;
        const date = new Date(0);
        date.setMilliseconds(Math.round(t * 1000));
        return date.toISOString().substr(11, 8) + ',' + String(date.getMilliseconds()).padStart(3,'0');
    };

    function init() {
        // --- LOGIC C≈® ---
        document.getElementById('editor-play-btn').onclick = () => {
            if(!ytPlayer || typeof ytPlayer.getPlayerState !== 'function') return;
            if(ytPlayer.getPlayerState() === 1) ytPlayer.pauseVideo();
            else ytPlayer.playVideo();
        };

        document.getElementById('save-srt-gh-btn').onclick = save;
        
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('editor-view').classList.contains('hidden')) return;
            
            // --- LOGIC M·ªöI: CTRL + H ---
            if (e.ctrlKey && e.code === 'KeyH') {
                e.preventDefault();
                openFindReplace();
                return;
            }

            // --- LOGIC C≈®: SPACE (ƒê√É FIX) ---
            if (e.code === 'Space') {
                const el = document.activeElement;
                const tag = el.tagName;
                
                // Ch·ªâ ch·∫∑n n·∫øu ƒëang g√µ Textarea HO·∫∂C Input th∆∞·ªùng (kh√¥ng ph·∫£i √¥ th·ªùi gian)
                // N·∫øu l√† .time-input th√¨ V·∫™N CHO PH√âP b·∫•m Space ƒë·ªÉ Play/Pause
                if (tag === 'TEXTAREA' || (tag === 'INPUT' && !el.classList.contains('time-input'))) {
                    return; 
                }

                e.preventDefault();
                if(ytPlayer && ytPlayer.getPlayerState) {
                    if(ytPlayer.getPlayerState() === 1) ytPlayer.pauseVideo();
                    else ytPlayer.playVideo();
                }
            }
        if (e.code === 'Delete') {
                const tag = document.activeElement.tagName;
                // Ch·ªâ x√≥a n·∫øu KH√îNG ƒëang g√µ trong √¥ Input ho·∫∑c Textarea
                if (tag !== 'INPUT' && tag !== 'TEXTAREA') {
                    if (selectedIndices.size > 0) {
                        e.preventDefault();
                        deleteSelectedRows();
                    }
                }
            }
        });
    const dropZone = document.getElementById('subtitle-editor-panel');
        
        // Khi k√©o file v√†o: ƒê·ªïi vi·ªÅn ƒë·ªÉ b√°o hi·ªáu
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.style.border = "2px dashed var(--accent-blue)";
        });

        // Khi k√©o ra ngo√†i: B·ªè vi·ªÅn
        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropZone.style.border = "none";
        });

        // Khi th·∫£ file: G·ªçi h√†m x·ª≠ l√Ω
        dropZone.addEventListener('drop', handleEditorDrop);
    }
    // --- H√ÄM HELPER M·ªöI: Parse SRT text ---
    const parseRawSRT = (text) => {
        // Chu·∫©n h√≥a d√≤ng m·ªõi v·ªÅ \n
        text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
        
        return text.trim().split('\n\n').map((b) => {
            const lines = b.split('\n');
            if (lines.length < 2) return null;

            // T√¨m d√≤ng ch·ª©a th·ªùi gian (c√≥ d·∫•u -->)
            const timeLineIdx = lines.findIndex(l => l.includes('-->'));
            if (timeLineIdx === -1) return null;

            const t = lines[timeLineIdx].split(' --> ');
            const content = lines.slice(timeLineIdx + 1).join('\n');

            return { 
                id: 0, // ID s·∫Ω ƒë∆∞·ª£c ƒë√°nh l·∫°i sau
                start: srtToSec(t[0].trim()), 
                end: srtToSec(t[1].trim()), 
                text: content 
            };
        }).filter(Boolean);
    };

    // --- H√ÄM X·ª¨ L√ù K√âO TH·∫¢ ---
    function handleEditorDrop(e) {
        e.preventDefault();
        e.stopPropagation();

        // X√≥a hi·ªáu ·ª©ng visual (n·∫øu c√≥)
        document.getElementById('subtitle-editor-panel').style.border = "none";

        const file = e.dataTransfer.files[0];
        if (file && file.name.toLowerCase().endsWith('.srt')) {
            const reader = new FileReader();
            reader.onload = (event) => {
                const newSubs = parseRawSRT(event.target.result);
                if (newSubs.length > 0) {
                    // 1. G·ªôp m·∫£ng c≈© v√† m·ªõi
                    currentData = currentData.concat(newSubs);
                    
                    // 2. S·∫Øp x·∫øp l·∫°i theo th·ªùi gian Start
                    currentData.sort((a, b) => a.start - b.start);
                    
                    // 3. Render l·∫°i b·∫£ng
                    renderTable();
                    
                    alert(`‚úÖ ƒê√£ merge th√™m ${newSubs.length} d√≤ng sub m·ªõi!`);
                } else {
                    alert("‚ö†Ô∏è File kh√¥ng c√≥ n·ªôi dung sub h·ª£p l·ªá.");
                }
            };
            reader.readAsText(file);
        } else {
            alert("‚ö†Ô∏è Vui l√≤ng ch·ªâ k√©o th·∫£ file .srt");
        }
    }
    async function load(videoId) {
        // --- LOGIC C≈® ---
        currentVideoId = videoId;
        const v = currentLibrary.find(x => x.videoId === videoId);
        if (!v) { alert("Kh√¥ng t√¨m th·∫•y th√¥ng tin video!"); return; }

        document.getElementById('editor-video-title').textContent = v.userTitle;
        switchTab('editor-view');

        // Reset state m·ªõi
        selectedIndices.clear();

        if (ytPlayer && typeof ytPlayer.destroy === 'function') ytPlayer.destroy();
        
        const onApiReady = () => {
            const vid = videoId; 
            ytPlayer = new YT.Player('editor-player', {
                height: '100%', width: '100%', 
                videoId: vid, 
                playerVars: { 'origin': window.location.origin, 'controls': 1 },
                events: {
                    'onReady': () => startSync(),
                    'onStateChange': (e) => {
                        const btn = document.getElementById('editor-play-btn');
                        if(btn) btn.textContent = e.data === 1 ? '‚è∏ Pause' : '‚ñ∂ Play';
                    }
                }
            });
        };

        if(window.YT && window.YT.Player) onApiReady();
        else window.onYouTubeIframeAPIReady = onApiReady;

        if(v.subtitleUrl) {
            try {
                const fname = v.subtitleUrl.split('/').pop();
                const {data} = await ghAPI(fname, 'GET', null, true);
                const text = fromBase64(data.content);
                currentData = text.trim().split('\n\n').map((b, i) => {
                    const l = b.split('\n');
                    if(l.length < 3) return null;
                    const t = l[1].split(' --> ');
                    return { id: i+1, start: srtToSec(t[0]), end: srtToSec(t[1]), text: l.slice(2).join('\n') };
                }).filter(Boolean);
                renderTable();
            } catch(e) { log("Ch∆∞a c√≥ sub ho·∫∑c l·ªói: " + e.message); currentData = []; renderTable(); }
        } else { currentData = []; renderTable(); }
    }

    // --- RENDER TABLE (ƒê√É C·∫¨P NH·∫¨T ƒê·ªÇ H·ªñ TR·ª¢ CLICK M·ªöI) ---
    function renderTable() {
        const tbody = document.getElementById('subtitle-tbody');
        tbody.innerHTML = currentData.map((s, i) => {
            // Check xem d√≤ng n√†y c√≥ ƒëang ƒë∆∞·ª£c ch·ªçn nhi·ªÅu kh√¥ng
            const isMultiSelected = selectedIndices.has(i) ? 'multi-selected' : '';
            const isActive = activeRowIndex === i ? 'active' : '';

            return `
            <tr class="sub-row ${isActive} ${isMultiSelected}" id="row-${i}">
                <td class="col-id" 
                    onclick="SubEditor.handleRowHeaderClick(event, ${i})" 
                    style="cursor:pointer; vertical-align:middle; text-align:center;" 
                    title="Click ƒë·ªÉ tua. Ctrl+Click ƒë·ªÉ ch·ªçn nhi·ªÅu.">
                    ${i+1}
                </td>
                
                <td class="col-time" style="vertical-align:middle;">
                    <div style="display:flex; align-items:center; gap:5px;flex-direction: column;">
                        <input class="time-input start" 
                               style="text-align:center; font-weight:600; color:var(--accent-blue); letter-spacing: 1px;"
                               value="${secToSrt(s.start)}" 
                               onchange="SubEditor.update(${i},'start',this.value)"
                               onkeydown="handleSmartTimeInput(event, this)"
                               onclick="SubEditor.handleInputClick(event, ${i}, 'start', this)"
                               onfocus="SubEditor.seekByStr(this.value)" 
                               > 
                        <span style="color:#aaa; font-size:12px;">‚ûú</span>
                        
                        <input class="time-input end" 
                               style="text-align:center; letter-spacing: 1px;"
                               value="${secToSrt(s.end)}" 
                               onchange="SubEditor.update(${i},'end',this.value)"
                               onkeydown="handleSmartTimeInput(event, this)"
                               onclick="SubEditor.handleInputClick(event, ${i}, 'end', this)"
                               
                               >
                    </div>
                </td>

                <td>
                    <textarea class="text-input" 
                              rows="1"
                              style="min-height:38px; height:38px;"
                              onfocus="this.style.height = ''; this.style.height = this.scrollHeight + 'px'; SubEditor.selectRow(${i})"
                              oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px'"
                              onchange="SubEditor.update(${i},'text',this.value)">${s.text}</textarea>
                </td>

                <td class="col-action" style="vertical-align:middle;">
                    <button class="btn-icon" onclick="SubEditor.del(${i})">üóë</button>
                </td>
            </tr>
            `;
        }).join('');
        
        document.querySelectorAll('.text-input').forEach(el => {
            if(el.value.includes('\n')) el.style.height = el.scrollHeight + 'px';
        });
    }
   
    // --- LOGIC SELECTION M·ªöI ---
    // --- LOGIC SELECTION ƒê√É FIX (TOGGLE & RESET) ---
    function handleRowHeaderClick(e, i) {
        if (e.ctrlKey) {
            e.preventDefault();
            if (e.altKey) {
                // --- S·ª¨A ƒêO·∫†N N√ÄY ---
                // Ctrl + Alt: Ch·ªçn/H·ªßy ch·ªçn t·ª´ ƒë√¢y ƒë·∫øn h·∫øt
                
                // Ki·ªÉm tra xem d√≤ng hi·ªán t·∫°i ƒëang ƒë∆∞·ª£c ch·ªçn hay ch∆∞a
                const isCurrentlySelected = selectedIndices.has(i);

                for (let k = i; k < currentData.length; k++) {
                    if (isCurrentlySelected) {
                        // N·∫øu ƒëang ch·ªçn -> B·∫•m l·∫ßn n·ªØa ƒë·ªÉ H·ªßy ch·ªçn (t·ª´ d√≤ng n√†y v·ªÅ sau)
                        selectedIndices.delete(k);
                    } else {
                        // N·∫øu ch∆∞a ch·ªçn -> Ch·ªçn (t·ª´ d√≤ng n√†y v·ªÅ sau)
                        selectedIndices.add(k);
                    }
                }
            } else {
                // Ctrl: Toggle t·ª´ng d√≤ng (Gi·ªØ nguy√™n)
                if (selectedIndices.has(i)) selectedIndices.delete(i);
                else selectedIndices.add(i);
            }
            refreshRowStyles(); // C·∫≠p nh·∫≠t m√†u s·∫Øc
        } else {
            // --- S·ª¨A TH√äM ƒêO·∫†N N√ÄY ---
            // Click th∆∞·ªùng (kh√¥ng ph√≠m): X√≥a h·∫øt ch·ªçn nhi·ªÅu (Reset)
            selectedIndices.clear(); 
            refreshRowStyles(); // X√≥a h·∫øt m√†u cam ƒëi
            
            // Logic c≈©: Tua v√† Active d√≤ng xanh
            seek(currentData[i].start);
            selectRow(i);
        }
    }

   // --- LOGIC SMART SNAP TRONG INPUT (ƒê√É C·∫¨P NH·∫¨T SHIFT + ALT + CLICK) ---
    function handleInputClick(e, i, type, inputEl) {
        
        // 1. [M·ªöI] Shift + Alt + Click: D·ªãch chuy·ªÉn th√¥ng minh (Snap Move & Clamp)
        if (e.shiftKey && e.altKey) {
            e.preventDefault(); e.stopPropagation();
            
            // L·∫•y ƒë·ªô d√†i hi·ªán t·∫°i c·ªßa d√≤ng
            const oldDuration = currentData[i].end - currentData[i].start;
            const container = inputEl.parentElement; // ƒê·ªÉ t√¨m √¥ input c√≤n l·∫°i

            if (type === 'start' && i > 0) {
                // --- LOGIC CHO √î START ---
                // 1. Start m·ªõi = End c·ªßa d√≤ng tr∆∞·ªõc
                const prevEnd = currentData[i-1].end;
                let newStart = prevEnd;
                
                // 2. End m·ªõi = Start m·ªõi + ƒë·ªô d√†i c≈©
                let newEnd = newStart + oldDuration;

                // 3. Gi·ªõi h·∫°n: End kh√¥ng ƒë∆∞·ª£c v∆∞·ª£t qu√° Start c·ªßa d√≤ng sau (n·∫øu c√≥)
                if (i < currentData.length - 1) {
                    const nextStart = currentData[i+1].start;
                    if (newEnd > nextStart) newEnd = nextStart; // B·ªã c·∫Øt ng·∫Øn n·∫øu v∆∞·ªõng
                }

                // C·∫≠p nh·∫≠t d·ªØ li·ªáu & Giao di·ªán
                update(i, 'start', secToSrt(newStart)); // S·∫Ω seek t·ªõi ƒë√¢y
                update(i, 'end', secToSrt(newEnd));
                
                inputEl.value = secToSrt(newStart);
                const endInput = container.querySelector('.end');
                if(endInput) endInput.value = secToSrt(newEnd);
                
                highlightInput(inputEl);
            } 
            else if (type === 'end' && i < currentData.length - 1) {
                // --- LOGIC CHO √î END ---
                // 1. End m·ªõi = Start c·ªßa d√≤ng sau
                const nextStart = currentData[i+1].start;
                let newEnd = nextStart;

                // 2. Start m·ªõi = End m·ªõi - ƒë·ªô d√†i c≈©
                let newStart = newEnd - oldDuration;

                // 3. Gi·ªõi h·∫°n: Start kh√¥ng ƒë∆∞·ª£c l√πi qu√° End c·ªßa d√≤ng tr∆∞·ªõc (n·∫øu c√≥)
                if (i > 0) {
                    const prevEnd = currentData[i-1].end;
                    if (newStart < prevEnd) newStart = prevEnd; // B·ªã c·∫Øt ng·∫Øn n·∫øu v∆∞·ªõng
                }

                // C·∫≠p nh·∫≠t d·ªØ li·ªáu & Giao di·ªán
                update(i, 'end', secToSrt(newEnd)); // S·∫Ω seek/preview
                update(i, 'start', secToSrt(newStart));

                inputEl.value = secToSrt(newEnd);
                const startInput = container.querySelector('.start');
                if(startInput) startInput.value = secToSrt(newStart);

                highlightInput(inputEl);
            }
        }
        // 2. N·∫øu gi·ªØ Ctrl (Logic N·ªëi d√≤ng c≈© - Snap Anchor)
        else if (e.ctrlKey) {
            e.preventDefault(); e.stopPropagation();

            if (type === 'start' && i > 0) {
                const newVal = currentData[i-1].end;
                update(i, 'start', secToSrt(newVal)); 
                inputEl.value = secToSrt(newVal);
                highlightInput(inputEl);
            } else if (type === 'end' && i < currentData.length - 1) {
                const newVal = currentData[i+1].start;
                update(i, 'end', secToSrt(newVal));
                inputEl.value = secToSrt(newVal);
                highlightInput(inputEl);
            }
        } 
        // 3. N·∫øu gi·ªØ Alt + Click (L·∫•y gi·ªù hi·ªán t·∫°i - Stamp)
        else if (e.altKey && type === 'start') {
            e.preventDefault(); e.stopPropagation();
            if (ytPlayer && typeof ytPlayer.getCurrentTime === 'function') {
                const timeStr = secToSrt(ytPlayer.getCurrentTime());
                update(i, 'start', timeStr);
                inputEl.value = timeStr;
                highlightInput(inputEl);
            }
        }
        // 4. Click th∆∞·ªùng (Tua & Preview)
        else {
            if(typeof selectTimeSegment === 'function') selectTimeSegment(inputEl);

            if (ytPlayer && typeof ytPlayer.seekTo === 'function') {
                if (type === 'start') {
                    ytPlayer.seekTo(currentData[i].start, true);
                    
                } else if (type === 'end') {
                    const t = currentData[i].end;
                    const previewStart = Math.max(currentData[i].start, t - 0.5);
                    ytPlayer.seekTo(previewStart, true);
                    ytPlayer.playVideo();
                    stopAtTime = t;
                }
            }
        }
    }

    function highlightInput(el) {
        el.style.backgroundColor = "#ccffcc";
        setTimeout(() => el.style.backgroundColor = "", 300);
    }

    function refreshRowStyles() {
        document.querySelectorAll('.sub-row').forEach((row, idx) => {
            row.classList.remove('multi-selected');
            if (selectedIndices.has(idx)) row.classList.add('multi-selected');
        });
    }

    // --- LOGIC C≈® GI·ªÆ NGUY√äN ---
    function selectRow(index) {
        activeRowIndex = index;
        currentRowLabel.textContent = `#${index + 1}`;
        document.querySelectorAll('.sub-row.active').forEach(el => el.classList.remove('active'));
        const row = document.getElementById(`row-${index}`);
        if(row) row.classList.add('active');
    }

    function startSync() {
        if(syncInterval) clearInterval(syncInterval);
        syncInterval = setInterval(() => {
            if(!ytPlayer || !ytPlayer.getCurrentTime) return;
            const t = ytPlayer.getCurrentTime();

            // --- M·ªöI: C·∫≠p nh·∫≠t ƒë·ªìng h·ªì hi·ªÉn th·ªã ---
            const timeDisplay = document.getElementById('video-current-time-display');
            
            // -------------------------------------

            // Logic t·ª± ƒë·ªông d·ª´ng (C≈®)
            if (stopAtTime !== null && t >= stopAtTime) {
                ytPlayer.pauseVideo();
                stopAtTime = null;
            }

            const idx = currentData.findIndex(s => t >= s.start && t <= s.end);
            
            if(idx !== -1) {
                overlayText.innerHTML = currentData[idx].text.replace(/\n/g, '<br>');
            } else {
                overlayText.textContent = '';
            }

        }, 100);
    }

    // --- C√ÅC C√îNG C·ª§ TOOLING (M·ªöI) ---
    function openFindReplace() {
        document.getElementById('find-replace-modal').style.display = 'flex';
        document.getElementById('find-input').focus();
    }
    function performFindReplace() {
        const findStr = document.getElementById('find-input').value;
        const replaceStr = document.getElementById('replace-input').value;
        const scope = document.getElementById('fr-scope').value;
        if (!findStr) return alert("Vui l√≤ng nh·∫≠p t·ª´ kh√≥a.");
        let count = 0;
        currentData.forEach((item, idx) => {
            if (scope === 'selected' && !selectedIndices.has(idx)) return;
            if (item.text.includes(findStr)) {
                item.text = item.text.split(findStr).join(replaceStr);
                count++;
            }
        });
        renderTable();
        closeModal('find-replace-modal');
        alert(`ƒê√£ thay th·∫ø ${count} d√≤ng.`);
    }
    function openOffset() {
        if (selectedIndices.size === 0) return alert("Vui l√≤ng ch·ªçn c√°c d√≤ng c·∫ßn d·ªãch (Ctrl + Click s·ªë th·ª© t·ª±).");
        document.getElementById('time-offset-modal').style.display = 'flex';
        document.getElementById('offset-input').focus();
    }
    function performOffset() {
        const ms = parseInt(document.getElementById('offset-input').value);
        if (isNaN(ms) || ms === 0) return;
        const sec = ms / 1000;
        currentData.forEach((item, idx) => {
            if (selectedIndices.has(idx)) {
                item.start = Math.max(0, item.start + sec);
                item.end = Math.max(0, item.end + sec);
            }
        });
        renderTable();
        closeModal('time-offset-modal');
    }
    // --- H√ÄM X√ìA H√ÄNG LO·∫†T ---
    function deleteSelectedRows() {
        // 1. Ki·ªÉm tra xem c√≥ ch·ªçn d√≤ng n√†o kh√¥ng
        if (selectedIndices.size === 0) {
            return alert("Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt d√≤ng (Ctrl + Click v√†o s·ªë th·ª© t·ª±) ƒë·ªÉ x√≥a.");
        }

        // 2. H·ªèi x√°c nh·∫≠n
        if (!confirm(`‚ö†Ô∏è C·∫¢NH B√ÅO: B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a vƒ©nh vi·ªÖn ${selectedIndices.size} d√≤ng ƒëang ch·ªçn?`)) return;

        // 3. Chuy·ªÉn Set th√†nh M·∫£ng v√† S·∫Øp x·∫øp GI·∫¢M D·∫¶N (Quan tr·ªçng!)
        // Ph·∫£i x√≥a t·ª´ d∆∞·ªõi l√™n (index l·ªõn x√≥a tr∆∞·ªõc) ƒë·ªÉ kh√¥ng l√†m l·ªách index c·ªßa c√°c d√≤ng b√™n tr√™n
        const indicesToDelete = Array.from(selectedIndices).sort((a, b) => b - a);

        // 4. Th·ª±c hi·ªán x√≥a
        indicesToDelete.forEach(idx => {
            currentData.splice(idx, 1);
        });

        // 5. D·ªçn d·∫πp v√† v·∫Ω l·∫°i
        selectedIndices.clear(); // X√≥a xong th√¨ reset l·ª±a ch·ªçn
        activeRowIndex = -1;     // Reset d√≤ng active
        renderTable();
    }
    function closeModal(id) { document.getElementById(id).style.display = 'none'; }

    // --- H√ÄM L∆ØU (GI·ªÆ NGUY√äN) ---
    async function save() {
        if (!currentVideoId) return alert("Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c Video ID.");
        const btn = document.getElementById('save-srt-gh-btn');
        const originalText = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = "‚è≥ ƒêang l∆∞u...";

        try {
            const srtContent = currentData.map((s, index) => {
                return `${index + 1}\n${secToSrt(s.start)} --> ${secToSrt(s.end)}\n${s.text}`;
            }).join('\n\n');
            const contentBase64 = toBase64Str(srtContent);
            const fileName = `${currentVideoId}.srt`;
            const { data: existingData } = await ghAPI(fileName, 'GET', null, true);
            await ghAPI(fileName, 'PUT', {
                message: `[SubEditor] Update subtitle for ${currentVideoId}`,
                content: contentBase64,
                sha: existingData?.sha 
            }, true);
            alert("‚úÖ ƒê√£ l∆∞u ph·ª• ƒë·ªÅ l√™n GitHub th√†nh c√¥ng!");
        } catch (e) {
            console.error(e);
            alert("‚ùå L·ªói khi l∆∞u: " + e.message);
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalText;
        }
    }

    // --- H√ÄM UPDATE (GI·ªÆ NGUY√äN LOGIC C≈® + STOP AT TIME) ---
    // --- H√ÄM UPDATE (C·∫¨P NH·∫¨T LOGIC PREVIEW 0.5s) ---
    function update(i, k, v) {
        if (k === 'text') { currentData[i].text = v; return; }
        
        // Logic th·ªùi gian
        const timeVal = srtToSec(v);
        currentData[i][k] = timeVal;
        
        if (k === 'start') { 
            // Thay ƒë·ªïi Start: Tua ƒë·∫øn ngay l·∫≠p t·ª©c
            if(ytPlayer) {
                ytPlayer.seekTo(timeVal, true);
                
            }
        } 
        else if (k === 'end') { 
            // Thay ƒë·ªïi End: Xem th·ª≠ ƒëo·∫°n k·∫øt (l√πi l·∫°i 0.5s)
            if(ytPlayer) {
                // S·ª¨A: Thay v√¨ -2, ƒë·ªïi th√†nh -0.5
                const previewStart = Math.max(currentData[i].start, timeVal - 0.5);
                
                ytPlayer.seekTo(previewStart, true);
                ytPlayer.playVideo();
                stopAtTime = timeVal; // G√°n bi·∫øn n√†y ƒë·ªÉ startSync t·ª± ƒë·ªông pause
            }
        }
    }

    // --- H√ÄM SEEK C≈® ---
    function seek(t) { if(ytPlayer && ytPlayer.seekTo) ytPlayer.seekTo(t, true); }

    // --- PUBLIC INTERFACE (K·∫øt h·ª£p c·∫£ c≈© v√† m·ªõi) ---
    return {
        init, load, selectRow, seek,
        
        // H√†m c·ªßa b·∫°n (gi·ªØ nguy√™n logic)
        update, 
        
        // C√°c h√†m n√∫t b·∫•m c≈© (ƒë√£ kh√¥i ph·ª•c)
        snapStart: () => {
            if (activeRowIndex <= 0 || activeRowIndex >= currentData.length) {
                alert("H√£y ch·ªçn m·ªôt d√≤ng (tr·ª´ d√≤ng ƒë·∫ßu ti√™n)."); return;
            }
            const prevEnd = currentData[activeRowIndex - 1].end;
            currentData[activeRowIndex].start = prevEnd;
            renderTable(); selectRow(activeRowIndex);
        },
        snapEnd: () => {
            if (activeRowIndex < 0 || activeRowIndex >= currentData.length - 1) {
                alert("H√£y ch·ªçn m·ªôt d√≤ng (tr·ª´ d√≤ng cu·ªëi c√πng)."); return;
            }
            const nextStart = currentData[activeRowIndex + 1].start;
            currentData[activeRowIndex].end = nextStart;
            renderTable(); selectRow(activeRowIndex);
        },
        del: (i) => { 
            if(confirm("X√≥a d√≤ng n√†y?")) { currentData.splice(i, 1); renderTable(); } 
        },
        insertRow: () => {
            const t = ytPlayer ? ytPlayer.getCurrentTime() : 0;
            let startT = t;
            if (currentData.length > 0) {
                const prevIdx = currentData.findIndex(s => s.start > t) - 1;
                if (prevIdx >= 0) startT = currentData[prevIdx].end;
                else if (currentData.length > 0) startT = currentData[currentData.length-1].end;
            }
            currentData.push({ id: 0, start: startT, end: startT + 2, text: '' });
            currentData.sort((a,b) => a.start - b.start);
            renderTable();
        },
        close: () => { 
            if(confirm("ƒê√≥ng tr√¨nh ch·ªânh s·ª≠a?")) { 
                if(ytPlayer) ytPlayer.stopVideo(); 
                switchTab('library-view'); 
            } 
        },
        seekByStr: (str) => {
            const t = srtToSec(str);
            if(ytPlayer && ytPlayer.seekTo) ytPlayer.seekTo(t, true);
        },

        // --- C√ÅC H√ÄM M·ªöI (PH·ª§C V·ª§ CLICK & TOOLS) ---
        handleRowHeaderClick,
        handleInputClick,
        openFindReplace, performFindReplace,
        openOffset, performOffset, closeModal,deleteSelectedRows,
    };
})();
// --- Tab Switching Logic ---
document.querySelectorAll('.nav-tab').forEach(btn => {
    btn.addEventListener('click', () => switchTab(btn.dataset.target));
});

function switchTab(targetId) {
    document.querySelectorAll('.view-content').forEach(el => el.classList.add('hidden'));
    document.querySelectorAll('.nav-tab').forEach(el => el.classList.remove('active'));
    document.getElementById(targetId).classList.remove('hidden');
    document.querySelector(`[data-target="${targetId}"]`).classList.add('active');
}

// Initialize Editor Module
SubEditor.init();

// --- Inject "Edit Subs" Button into Library Card ---
// Ghi ƒë√® l·∫°i h√†m renderLibraryList l·∫ßn n·ªØa ƒë·ªÉ th√™m n√∫t "S·ª≠a Sub"
const prevRenderWithDrag = window.renderLibraryList;
window.renderLibraryList = function() {
    prevRenderWithDrag();
    // Th√™m n√∫t Edit Sub v√†o action bar c·ªßa m·ªói th·∫ª video
    document.querySelectorAll('.video-card-actions').forEach(actions => {
        if (!actions.querySelector('.edit-sub-btn')) {
            const btn = document.createElement('button');
            btn.className = 'edit-sub-btn';
            btn.title = "Ch·ªânh s·ª≠a Ph·ª• ƒë·ªÅ";
            btn.innerHTML = 'üé¨'; // Icon clapperboard
            btn.style.marginLeft = '5px';
            btn.onclick = (e) => {
                e.stopPropagation();
                const card = btn.closest('.video-card-item');
                SubEditor.load(card.dataset.videoId);
            };
            actions.appendChild(btn);
        }
    });
};
loadConfig();
</script>
</body>
</html>
